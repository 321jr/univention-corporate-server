#!/usr/bin/python2.7
"""
Univention Directory Notifier Transaction log admin commmand
"""
# Copyright 2019 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.
from __future__ import print_function
from array import array
from os import SEEK_SET, fstat, fchmod, fchown, lstat, chmod, lchown, rename, unlink, getuid
from stat import S_ISREG, S_IMODE
from sys import stderr
from argparse import ArgumentParser, ArgumentTypeError
from collections import namedtuple
from logging import basicConfig, getLogger, CRITICAL, DEBUG
from time import strftime, time
from ctypes import c_bool, c_ulong, sizeof, Structure
from errno import ENOENT
from contextlib import contextmanager
from itertools import chain
from grp import getgrnam
import ldap
from ldap.ldapobject import ReconnectLDAPObject
from ldap.modlist import addModlist
from ldap.dn import is_dn
from univention.config_registry import ConfigRegistry
try:
    from typing import BinaryIO, Callable, Iterator, List, Optional, Tuple, Type, NamedTuple  # noqa F401
    from types import TracebackType  # noqa F401
    from argparse import Namespace  # noqa F401
    Transaction = NamedTuple("Transaction", [("tid", int), ("dn", str), ("command", str)])
    from mypy_extensions import DefaultArg  # noqa F401
except ImportError:
    Transaction = namedtuple("Transaction", ["tid", "dn", "command"])  # type: ignore

LOG_FORMAT = "%(asctime)-15s:%(levelname)s:%(message)s"
BSIZE = 4096
INVALID = 1  # file offset 1 is invalid as a transaction line contains of 3 parts
GR_GID = -1


class IndexHeader(Structure):
    """
    Header for index file.

    .. warning::

        The header is architecture dependant due to the use of `c_ulong`.
    """
    MAGIC = 0x3395e0d4L
    _fields_ = [("magic", c_ulong)]
    _pack_ = 1


class IndexEntry(Structure):
    """
    Entry of index file.

    .. warning::

        The header is architecture dependant due to the use of `c_ulong`.

    .. warning::

        The source is compiled with `-D_FILE_OFFSET_BITS=64` which makes `off_t` 64 bit on i386, too, but `ulong` remains 32 bit.
    """
    _fields_ = [("valid", c_bool), ("offset", c_ulong)]
    _pack_ = 1


class Index(object):
    """
    Index to efficiently lookup transactions in the translog file.
    :file:`/var/lib/univention-ldap/notify/transaction.index`
    """

    def __init__(self, filename):
        # type: (str) -> None
        self.filename = filename + ".index"
        self.log = getLogger(__name__).getChild("Index")
        self.index = None  # type: Optional[BinaryIO]
        self.size = 0
        self.count = 0

    def __enter__(self):
        # type: () -> Index
        try:
            self.index = index = open(self.filename, 'rb+')

            data = index.read(sizeof(IndexHeader))
            assert data, "Empty index"
            header = IndexHeader.from_buffer_copy(data)
            assert header.magic == header.MAGIC, header.magic

            size = self._update_size()
        except EnvironmentError as ex:
            self.log.warning("Failed to open %s: %s", self.filename, ex)
            if ex.errno != ENOENT:
                raise

            self.log.info("Creating empty %s", self.filename)
            self.index = index = open(self.filename, 'wb+')

            header = IndexHeader(IndexHeader.MAGIC)
            data = buffer(header)[:]  # type: ignore
            self.index.write(data)

            self.size = size = len(data)

        count, reminder = divmod(size - sizeof(IndexHeader), sizeof(IndexEntry))
        self.log.info("Index of size %d contains %d entries", size, count)
        self.count = count - 1 if count else 0  # transaction 0 is never used
        assert reminder == 0, reminder

        return self

    def _update_size(self):
        # type: () -> int
        """
        Update and return index file size.

        :returns: file size in bytes.
        """
        assert self.index
        stat = fstat(self.index.fileno())
        self.size = size = stat.st_size
        return size

    def __exit__(self, exc_type, exc_value, traceback):
        # type: (Optional[Type[BaseException]], Optional[BaseException], Optional[TracebackType]) -> None
        assert self.index
        self.index.close()

    def __getitem__(self, tid):
        # type: (int) -> IndexEntry
        """
        Retrun index entry for given transaction.

        :param tid: Transaction id.
        :returns: The index entry.
        :raises IndexEntry: for transactions before 0 or after the current count.
        """
        if tid < 0 or tid > self.count:
            raise IndexError(tid)

        assert self.index
        self.seek(tid)

        data = self.index.read(sizeof(IndexEntry))
        assert data, "Invalid index entry"
        entry = IndexEntry.from_buffer_copy(data)
        self.log.debug("Transaction %d is %s and at position %d", tid, entry.valid, entry.offset)

        return entry

    def __setitem__(self, tid, offset):
        # type: (int, Optional[int]) -> None
        """
        Set index entry for given transaction.

        :param tid: Transaction id.
        :param offset: File offset or `None` to invalidate entry.
        :raises IndexEntry: for transactions before 0.
        """
        if tid < 0:
            raise IndexError(tid)

        if tid > self.count:
            self.count = tid

        assert self.index
        self.seek(tid)

        entry = IndexEntry(offset is not None, offset or 0)
        data = buffer(entry)[:]  # type: ignore
        self.index.write(data)
        self._update_size()
        self.log.debug("Transaction %d is %s and at position %d", tid, entry.valid, entry.offset)

    def seek(self, tid):
        # type: (int) -> None
        """
        Seek to given transaction id.

        :param tid: Transaction id.
        """
        assert 0 <= tid <= self.count
        assert self.index

        pos = sizeof(IndexHeader) + tid * sizeof(IndexEntry)
        self.log.debug("Looking up transaction %d at position %d in index", tid, pos)
        self.index.seek(pos, SEEK_SET)


class RawTranslog(object):
    """
    Transactions log file unparsed.
    :file:`/var/lib/univention-ldap/notify/transaction`
    """
    MODE = 'r'

    def __init__(self, filename):
        # type: (str) -> None
        self.filename = filename
        self.log = getLogger(__name__).getChild("Log")
        self.translog = None  # type: Optional[BinaryIO]
        self.size = 0
        self.offset = 0

    @staticmethod
    def parse_line(line):
        # type: (str) -> Transaction
        """
        Parse line from transaction line.

        :param line: One transaction line
        :returns: 3-tuples (transaction_number, distinguished_name, command)
        """
        line = line.strip()
        tid, rest = line.split(' ', 1)
        dn, command = rest.rsplit(' ', 1)
        return Transaction(int(tid), dn, command)

    def __enter__(self):
        # type: () -> RawTranslog
        self.translog = translog = open(self.filename, self.MODE)
        self.offset = 0

        stat = fstat(translog.fileno())
        self.size = stat.st_size

        return self

    def __exit__(self, exc_type, exc_value, traceback):
        # type: (Optional[Type[BaseException]], Optional[BaseException], Optional[TracebackType]) -> None
        assert self.translog
        self.translog.close()

    def __iter__(self):
        # type: () -> Iterator[str]
        """
        Iterate over all transactions.
        """
        assert self.translog
        for line in self.translog:
            self.log.debug("Read line %r", line)
            yield line
            self.offset += len(line)

    def seek(self, pos):
        # type: (int) -> None
        """
        Seek to given transaction id.

        :param pos: File offset.
        """
        assert 0 <= pos < self.size, pos
        assert self.translog
        self.translog.seek(pos, SEEK_SET)
        self.offset = pos


class Translog(RawTranslog):
    """
    Transactions log file.
    :file:`/var/lib/univention-ldap/notify/transaction`
    """

    def __init__(self, filename, index=None):
        # type: (str, Optional[Index]) -> None
        super(Translog, self).__init__(filename)
        self.index = index or Index(filename)  # type: Index
        self.first = 0
        self.last = 0

    @property
    def count(self):
        # type: () -> int
        """
        Return count of transactions.
        """
        if self.last == 0:
            return 0
        return self.last - self.first + 1

    def __enter__(self):
        # type: () -> Translog
        super(Translog, self).__enter__()
        self.index.__enter__()

        if self.size:
            assert self.translog
            line = self.translog.readline()
            rec = self.parse_line(line)
            assert 1 <= rec.tid, rec.tid
            self.first = rec.tid

            last = self.index.count
            if last:
                self.log.debug("Seeking to last transaction %d...", last)
                self.seek(last)
            else:
                offset = 0 if self.size < BSIZE else self.size - BSIZE
                self.read(offset)

            for line in self.translog:
                pass
            rec = self.parse_line(line)
            if last != rec.tid:
                self.log.warn("Index=%d != translog=%d entries", last, rec.tid)
            self.last = rec.tid

            self.translog.seek(0, SEEK_SET)

        return self

    def __exit__(self, exc_type, exc_value, traceback):
        # type: (Optional[Type[BaseException]], Optional[BaseException], Optional[TracebackType]) -> None
        self.index.__exit__(exc_type, exc_value, traceback)
        super(Translog, self).__exit__(exc_type, exc_value, traceback)

    def __getitem__(self, tid):
        # type: (int) -> Transaction
        """
        Retrun given transaction.

        :param tid: Transaction id.
        :returns: The transaction.
        :raises IndexEntry: for transactions before 1 or after the current count.
        """
        assert self.index
        if tid < 1 or tid > self.index.count:
            raise IndexError(tid)

        assert self.translog
        self.seek(tid)

        line = self.translog.readline()
        self.log.debug("Read line %r", line)

        rec = self.parse_line(line)
        assert tid == rec.tid, rec.tid

        return rec

    def __iter__(self):
        # type: () -> Iterator[Transaction]
        """
        Iterate over all transactions.
        """
        for line in super(Translog, self).__iter__():
            rec = self.parse_line(line)
            yield rec

    def seek(self, tid):
        # type: (int) -> int
        """
        Seek to given transaction id.

        :param tid: Transaction id.
        :returns: Offset.
        """
        assert self.index
        assert self.first <= tid <= self.index.count

        rec = self.index[tid]
        if not rec.valid:
            self.log.warn("Transaction %d is invalid", tid)
            raise IndexError(tid)
        pos = rec.offset
        self.log.debug("Seeking to transaction %d at position %d", tid, pos)
        assert 0 <= pos < self.size, pos
        assert self.translog
        self.translog.seek(pos, SEEK_SET)
        return pos

    def read(self, offset):
        # type: (int) -> Transaction
        """
        Read next transaction after given offset.

        :param offset: absolute file offset.
        :retruns: The transaction.
        :raises EOFError: if reading past the end.
        """
        assert 0 <= offset <= self.size, offset
        if offset >= self.size:
            raise EOFError()

        assert self.translog
        pos = max(0, offset - BSIZE)
        self.translog.seek(pos, SEEK_SET)
        data = self.translog.read(offset - pos)
        self.log.debug("Read from offset %d: %r", pos, data)

        before = data.rsplit('\n', 1)[-1]
        after = self.translog.readline()
        self.log.debug("Read line %r %r", before, after)

        line = before + after
        rec = self.parse_line(line)

        return rec


class WriteableTranslog(Translog):
    """
    Transactions log file writeable.
    :file:`/var/lib/univention-ldap/notify/transaction`
    """
    MODE = 'a+'

    def __init__(self, filename):
        # type: (str) -> None
        rewrite_filename = filename + '.rewrite'
        index = Index(rewrite_filename)  # type: Index
        super(WriteableTranslog, self).__init__(rewrite_filename, index)
        self.orig_filename = filename
        self.changed = False

    def __enter__(self):
        # type: () -> WriteableTranslog
        super(WriteableTranslog, self).__enter__()
        assert self.translog
        fchmod(self.translog.fileno(), 0o640)
        fchown(self.translog.fileno(), 0, GR_GID)
        self.changed = False
        return self

    def write(self, rec, changed=True):
        # type: (Transaction, bool) -> None
        """
        Append transaction.

        :param rec: The transaction to append.
        :param changed: Transaction is modified compared to original.
        """
        line = self.format(rec)
        length = len(line)

        assert self.index
        self.index[rec.tid] = self.offset

        assert self.translog
        self.translog.write(line)
        self.offset += length
        self.size += length
        if self.first == 0:
            self.first = rec.tid
        if rec.tid > self.last:
            self.last = rec.tid

        self.changed |= changed

    def format(self, rec):
        # type: (Transaction) -> str
        return '%d %s %s\n' % rec

    def __exit__(self, exc_type, exc_value, traceback):
        # type: (Optional[Type[BaseException]], Optional[BaseException], Optional[TracebackType]) -> None
        super(WriteableTranslog, self).__exit__(exc_type, exc_value, traceback)

        if exc_type is not None:
            self.log.info('Dropping %s after %s', self.filename, exc_value)
            unlink(self.filename)
            unlink(self.index.filename)
        elif self.changed:
            self.log.info('Replacing %s with %s ...', self.orig_filename, self.filename)
            rename(self.filename, self.orig_filename)
            new_name = self.orig_filename + '.index'  # FIXME hard-coded name.
            self.log.info('Replacing %s with %s ...', new_name, self.index.filename)
            rename(self.index.filename, new_name)  # FIXME hard-coded name
        else:
            self.log.info('Dropping unchanged %s', self.filename)
            unlink(self.filename)
            unlink(self.index.filename)


class Abort(Exception):
    pass


def main():
    # type: () -> int
    """
    Work with transaction log in LDAP server.
    """
    opt = parse_args()

    basicConfig(stream=stderr, level=max(DEBUG, CRITICAL - DEBUG * opt.verbose), format=LOG_FORMAT)

    try:
        return opt.func(opt) or 0
    except Abort:
        return 1


@contextmanager
def ldapi(opt):
    # type: (Namespace) -> Iterator[ReconnectLDAPObject]
    """
    Return local LDAP connection.

    :param opt: Command line options.
    :returns: A initialized LDAP connection.
    """
    log = getLogger(__name__).getChild("ldap")

    log.debug("ldap_set_option(PROTOCOL_VERSION)")
    ldap.set_option(ldap.OPT_PROTOCOL_VERSION, ldap.VERSION3)
    log.debug("ldap_initialize(%s)", opt.translog_ldap)
    ld = ReconnectLDAPObject(
        opt.translog_ldap,
        trace_level=max(0, opt.verbose - 4),
        retry_max=3,
        retry_delay=10.0,
    )
    log.debug("ldap_bind()")
    ld.sasl_external_bind_s()

    yield ld

    log.debug("ldap_unbind()")
    ld.unbind_ext_s()


def import_all(opt):
    # type: (Namespace) -> None
    """
    Load transaction from file into LDAP server.

    :param opt: Command line options.
    """
    log = getLogger(__name__).getChild("import")
    log.info("Reading transactions from file '%s'...", opt.translog_file)

    with Index(opt.translog_file) as index, Translog(opt.translog_file, index) as translog, ldapi(opt) as ld:
        if not translog.size:
            log.debug("File is empty; no transactions to process.")
            return

        c_tid = max(1, translog.last - opt.count + 1)
        log.debug("count.tid=%d count=%d", c_tid, opt.count)

        p_offset = int(translog.size * (1.0 - opt.percent))
        try:
            p_trans = translog.read(p_offset)
            p_tid = p_trans.tid
        except EOFError:
            p_tid = translog.last
        log.debug("percent.tid=%d off=%d percent=%f", p_tid, p_offset, opt.percent)

        s_offset = max(0, translog.size - opt.size)
        try:
            s_trans = translog.read(s_offset)
            s_tid = s_trans.tid
        except EOFError:
            s_tid = translog.last
        log.debug("size.tid=%d off=%d size=%d", s_tid, s_offset, opt.size)

        start = max(1, min(c_tid, p_tid, s_tid), translog.first)
        assert translog.first <= start <= translog.last, start
        end = min(opt.max or translog.last, translog.last)

        if opt.index and index.count:
            log.info("Processing transactions %d .. %d", start, end)
            translog.seek(start)
            lead = []  # type: List[Transaction]
        else:
            offset = min(p_offset, s_offset)
            log.info("Processing transaction from offset %d .. %d", offset, end)
            rec = translog.read(offset)
            lead = [rec]

        t_begin = t_last = time()
        count = end - start
        for rec in chain(lead, translog):
            if rec.tid < start:
                continue
            if rec.tid > end:
                break

            add_transaction(opt, ld, rec)

            if stderr.isatty():
                t_now = time()
                if t_now - t_last >= 5.0:
                    p_done = float(rec.tid - start) / count
                    t_used = t_now - t_begin
                    stderr.write('\rprocessed {:d} of {:d} [{:.1f}%] in {:.1f}s, {:d} remaining in {:.1f}s  \r'.format(
                        rec.tid - start,
                        count,
                        p_done * 100.0,
                        t_used,
                        end - rec.tid,
                        t_used / p_done - t_used,
                    ))
                    t_last = t_now


def load_single(opt):
    # type: (Namespace) -> None
    """
    Load given transactions into LDAP server.

    :param opt: Command line options.
    """
    with Index(opt.translog_file) as index, Translog(opt.translog_file, index) as translog, ldapi(opt) as ld:
        for tid in opt.trans:
            try:
                rec = translog[tid]
            except IndexError:
                continue

            add_transaction(opt, ld, rec)


def show_stat(opt):
    # type: (Namespace) -> None
    """
    Show statistics

    :param opt: Command line options.
    """
    with Index(opt.translog_file) as index, Translog(opt.translog_file, index) as translog:
        print("Index.file: %s" % index.filename)
        print("Index.size: %d" % index.size)
        print("Index.count: %d" % index.count)
        print("Index.okay: %s" % ('yes' if index.count == translog.count else 'no',))
        print("Translog.file: %s" % translog.filename)
        print("Translog.size: %d" % translog.size)
        print("Translog.first: %d" % translog.first)
        print("Translog.last: %d" % translog.last)
        print("Translog.count: %d" % translog.count)
        first, last = translog.first, translog.last

    tid = last
    with ldapi(opt) as ld:
        while tid >= first:
            dn = "reqSession={},{}".format(tid, opt.translog_base)
            try:
                ld.search_ext_s(dn, ldap.SCOPE_BASE)
                break
            except ldap.NO_SUCH_OBJECT:
                tid -= 1
    print("Ldap.last: %d" % tid)
    print("Ldap.okay: %s" % ('yes' if last == tid else 'no',))


def check(opt):
    # type: (Namespace) -> None
    """
    Check transaction files for consistency.

    :param opt: Command line options.
    """
    grpent = getgrnam("DC Backup Hosts")
    global GR_GID
    GR_GID = grpent.gr_gid

    checker = Checker(opt)
    checker.run()


class Checker(object):
    """
    Check transaction files for consistency.
    """

    def __init__(self, opt):
        # type: (Namespace) -> None
        """
        Check transaction files for consistency.

        :param opt: Command line options.
        """
        self.opt = opt
        self.index = Index(opt.translog_file)
        self.translog = Translog(opt.translog_file)
        self.new_translog = WriteableTranslog(opt.translog_file)
        self.log = getLogger(__name__).getChild("Check")
        self.changed_index = False

    @contextmanager
    def check(self, text):
        # type: (str) -> Iterator[Callable[[DefaultArg(str, 'text')], bool]]
        print('%s: ...' % (text,))

        result = []

        def fail_and_fix(text=''):
            # type: (str) -> bool
            result.append(text)
            print('%s: %s' % (text, ': '.join(result)))
            return self.opt.fix

        try:
            yield fail_and_fix
            result.append('FIXED' if result else 'OKAY')
        except Exception as ex:
            self.log.error("Exception: %s", ex, exc_info=True)
            result.append('FAIL')
            if not isinstance(ex, StandardError):
                raise
        finally:
            print('%s: %s' % (text, ': '.join(result)))

    def run(self):
        # type: () -> None
        for name in sorted(dir(self)):
            if not name.startswith('check_'):
                continue
            func = getattr(self, name)
            func()

    def skip_if(cond):  # type: ignore
        # type: (bool) -> Callable[[Callable], Callable]
        if not cond:
            return lambda f: lambda self: None
        else:
            return lambda f: f

    def check_00transactions_exists(self):
        # type: () -> None
        with self.check("Checking %s exists" % (self.translog.filename,)) as check:
            try:
                stats = lstat(self.translog.filename)
                if S_ISREG(stats.st_mode):
                    return
                if check('not a file'):
                    unlink(self.translog.filename)
            except EnvironmentError:
                pass
            if check('missing file'):
                with self.translog:
                    pass

    @skip_if(getuid() != 0)
    def check_02transactions_permissions(self):
        # type: () -> None
        with self.check("Checking %s permissions" % (self.translog.filename,)) as check:
            stats = lstat(self.translog.filename)
            if S_IMODE(stats.st_mode) == 0o640:
                return
            if check('chmod: %03o -> %03o' % (S_IMODE(stats.st_mode), 0o640)):
                chmod(self.translog.filename, 0o640)

    @skip_if(getuid() != 0)
    def check_03transactions_ownership(self):
        # type: () -> None
        with self.check("Checking %s owner" % (self.translog.filename,)) as check:
            stats = lstat(self.translog.filename)
            if stats.st_uid == 0 and stats.st_gid == GR_GID:
                return
            if check('chown owner: %s:%s -> %s:%s' % (stats.st_uid, stats.st_gid, 0, GR_GID)):
                lchown(self.translog.filename, 0, GR_GID)

    def check_04transaction_lines(self):
        # type: () -> None
        with self.check("Checking transaction lines") as check, RawTranslog(self.opt.translog_file) as translog, self.new_translog as new_translog:
            for line in translog:
                if line.endswith('\n'):
                    line = line[:-1]
                elif check('Missing newline'):
                    pass

                if line == line.strip():
                    pass
                elif check('Extra whitespace'):
                    line = line.strip()

                try:
                    tid_, rest = line.split(' ', 1)
                    tid = int(tid_)
                    if tid < 1 and check('Invalid TID: %d' % (tid,)):
                        tid = 1
                except ValueError:
                    if check('Invalid transaction: %r' % (line,)):
                        continue

                try:
                    dn, command = rest.rsplit(' ', 1)
                    if command not in {'r', 'd', 'a', 'm'}:  # mod_Rdn Delete Add Modify
                        raise ValueError()
                except ValueError:
                    if check('Missing command'):
                        command = 'm'

                if dn.endswith(self.opt.base) and is_dn(dn):
                    pass
                elif check('Invalid DN: %s' % (dn,)):
                    dn = self.opt.base
                    command = 'm'

                rec = Transaction(tid, dn, command)
                new_line = new_translog.format(rec)
                self.log.debug('Replacing %r with %r', line, new_line)
                new_translog.write(rec, new_line != line)

    def check_05transaction_duplicates(self):
        # type: () -> None
        index = array('L')
        with self.check("Checking transaction duplicates") as check, self.translog as translog, self.new_translog as new_translog:
            assert translog.translog
            for rec in translog:
                try:
                    old_offset = index[rec.tid]
                    if old_offset == INVALID:
                        raise IndexError()
                    cur_offset = translog.offset
                    try:
                        old_rec = translog.read(old_offset)
                    finally:
                        translog.translog.seek(cur_offset, SEEK_SET)

                    if old_rec == rec and check('Duplicate transaction %s from %d already at %d' % (rec.tid, cur_offset, old_offset)):
                        new_translog.changed = True
                        continue
                except IndexError:
                    if len(index) <= rec.tid:
                        index.extend([INVALID] * (rec.tid - len(index) + 1))

                    index[rec.tid] = translog.offset

                new_translog.write(rec, False)



    def check_06transaction_order(self):
        # type: () -> None
        index = array('L')
        with self.check("Checking transaction order") as check, self.translog as translog, self.new_translog as new_translog:
            assert translog.translog
            last = 0
            for rec in translog:
                if rec.tid < last and check('Out-of-order transaction %s at %d' % (rec.tid, translog.offset)):
                    new_translog.changed = True

                last = rec.tid

                if len(index) <= rec.tid:
                    index.extend([INVALID] * (rec.tid - len(index) + 1))

                self.log.debug('TID=%d @ %d', rec.tid, translog.offset)
                index[rec.tid] = translog.offset

            if not new_translog.changed:
                return

            self.log.info('Re-writing ordered ... %r', index)
            for offset in index[1:]:
                if index == INVALID:
                    continue
                rec = translog.read(offset)
                new_translog.write(rec)

    def check_07transaction_holes(self):
        # type: () -> None
        with self.check("Checking transaction holes") as check, self.translog as translog, self.new_translog as new_translog:
            last = 0
            for rec in translog:
                if last == 0:
                    if rec.tid != 1:
                        self.log.info("assuming truncated transactions starting wtih %d" % (rec.tid,))
                elif last + 1 < rec.tid:
                    if check('Hole between %d and %d' % (last, rec.tid)):
                        self.changed_translog = True
                        last += 1
                        while last < rec.tid:
                            hole = Transaction(last, self.opt.base, 'm')
                            new_translog.write(hole)
                            last += 1
                else:
                    assert last + 1 == rec.tid
                last = rec.tid
                new_translog.write(rec, False)

    def check_10index_exists(self):
        # type: () -> None
        with self.check("Checking %s exists" % (self.index.filename,)) as check:
            try:
                stats = lstat(self.index.filename)
                if S_ISREG(stats.st_mode):
                    return
                if check('not a file'):
                    unlink(self.index.filename)
            except EnvironmentError:
                pass
            if check('missing file'):
                with self.index:
                    pass

    def check_11index_header(self):
        # type: () -> None
        with self.check("Checking %s header" % (self.index.filename,)) as check:
            stats = lstat(self.index.filename)
            if stats.st_size >= sizeof(IndexHeader):
                return
            if check('Re-create'):
                unlink(self.index.filename)
                with self.index:
                    pass

    @skip_if(getuid() != 0)
    def check_12index_permissions(self):
        # type: () -> None
        with self.check("Checking %s permissions.index" % (self.index.filename,)) as check:
            stats = lstat(self.index.filename)
            if S_IMODE(stats.st_mode) == 0o644:
                return
            if check('chmod: %03o -> %03o' % (S_IMODE(stats.st_mode), 0o644)):
                chmod(self.index.filename, 0o644)

    @skip_if(getuid() != 0)
    def check_13index_ownership(self):
        # type: () -> None
        with self.check("Checking %s owner" % (self.index.filename,)) as check:
            stats = lstat(self.index.filename)
            if stats.st_uid == 0 and stats.st_gid == 0:
                return
            if check('chown owner: %s:%s -> %s:%s' % (stats.st_uid, stats.st_gid, 0, 0)):
                lchown(self.index.filename, 0, 0)

    def check_14index_size(self):
        # type: () -> None
        with self.check("Checking %s size" % (self.index.filename,)) as check, self.index as index:
            quotient, remainder = divmod(index.size - sizeof(IndexHeader), sizeof(IndexEntry))
            if remainder == 0:
                return
            size = sizeof(IndexHeader) + quotient * sizeof(IndexEntry)
            assert size < index.size
            if check('truncating %d' % (index.size - size,)):
                assert index.index
                index.index.truncate(size)

    def check_15index_tid0(self):
        # type: () -> None
        with self.check("Checking transaction 0") as check, self.index as index:
            if index.count == 0:
                return
            try:
                entry = index[0]
                if not entry.valid and entry.offset == 0:
                    return
            except IndexError:
                pass
            if check('invalidating'):
                index[0] = None

    def check_16index_offsets(self):
        # type: () -> None
        return
        with self.check("Checking transaction offsets") as check, self.index as index, self.translog as translog:
            last = 0
            tid = 1
            for lnr, line in enumerate(translog):
                offset = translog.offset
                self.log.debug('Processing line %d at %d: %r', lnr + 1, offset, line)

                if last == 0:
                    if tid < 1 and check('Invalid first transaction'):
                        tid = 1
                    if tid != 1:
                        self.log.info("assuming truncated transactions starting wtih %s" % (tid,))
                elif last + 1 < tid:
                    if check('Hole'):
                        self.changed_translog = True
                        self.changed_index = True
                        last += 1
                        while last < tid:
                            index[last] = new_translog.tell()
                            new_translog.write('%d %s %s\n' % (last, self.opt.base, 'm'))
                            last += 1
                elif last >= tid:
                    if check('Repeated'):
                        try:
                            rec = index[tid]
                            if not rec.valid:
                                raise IndexError()
                        except IndexError:
                            if check("Wrong order"):
                                # FIXME
                                pass
                else:
                    assert last + 1 == tid

                new_line = '%d %s %s\n' % (tid, dn, command)
                if new_line != line:
                    self.changed_translog = True
                    offset = new_translog.tell()
                    new_translog.write(new_line)

                try:
                    rec = index[tid]
                    if not rec.valid or rec.offset != offset:
                        raise IndexError()
                except IndexError:
                    if check('Wrong offset'):
                        self.changed_index = True
                        index[tid] = translog.offset

                last = tid

    def check_20ldap(self):
        # type: () -> None
        pass


def dump_index(opt):
    # type: (Namespace) -> None
    """
    Dump transaction index

    :param opt: Command line options.
    """
    log = getLogger(__name__).getChild("INDEX")

    with Index(opt.translog_file) as index:
        begin = opt.min
        end = min(opt.max or index.count, index.count)
        log.debug('Dumping index from [%d, %d] ...', begin, end)
        for tid in xrange(begin, end + 1):
            rec = index[tid]
            print('%8d[%c]: %d' % (tid, 'x' if rec.valid else ' ', rec.offset))


def lookup(opt):
    # type: (Namespace) -> None
    """
    Lookup transactions.

    :param opt: Command line options.
    """
    with Index(opt.translog_file) as index, Translog(opt.translog_file, index) as translog:
        for tid in opt.trans:
            print(translog[tid])


def lookup_ldap(opt):
    # type: (Namespace) -> None
    """
    Check transactions.

    :param opt: Command line options.
    """
    log = getLogger(__name__).getChild("LDAP")

    with ldapi(opt) as ld:
        for tid in opt.trans:
            dn = "reqSession={},{}".format(tid, opt.translog_base)
            try:
                result = ld.search_ext_s(dn, ldap.SCOPE_BASE)
            except ldap.NO_SUCH_OBJECT as ex:
                if not opt.lenient:
                    log.critical("ldap_search(%s): %s", dn, ex.args[0]["desc"])
                    raise Abort()
            ((dn, attrs),) = result
            print('tid={0[reqSession][0]} dn={0[reqDN][0]} command={0[reqType][0]}'.format(attrs))


def add_transaction(opt, ld, rec):
    # type: (Namespace, ReconnectLDAPObject, Transaction) -> None
    """
    Load single transaction into LDAP server.

    :param opt: Command line options.
    :param ld: LDAP server connection.
    :param rec: Transaction to add.
    :raises Abort: on fatal errors.
    """
    log = getLogger(__name__).getChild("LDAP")

    dn = "reqSession={.tid},{}".format(rec, opt.translog_base)
    modlist = addModlist({
        "objectClass": ["auditObject"],
        "reqStart": [opt.datetime],
        "reqType": ["{.command}".format(rec)],
        "reqSession": ["{.tid}".format(rec)],
        "reqDN": ["{.dn}".format(rec)],
    })
    try:
        log.debug("ldap_add(%s)", dn)
        if not opt.dry_run:
            ld.add_ext_s(dn, modlist)
    except (ldap.ALREADY_EXISTS, ldap.INVALID_SYNTAX) as ex:
        if not opt.lenient:
            log.critical("ldap_add(%s): %s", rec, ex.args[0]["desc"])
            raise Abort()
        log.error("ldap_add(%s): %s", rec, ex.args[0]["desc"])
    except ldap.LDAPError as ex:
        log.critical("ldap_add(%s): %s", rec, ex)
        raise Abort()


def parse_args(args=None):
    # type: (List[str]) -> Namespace
    """
    Parse command line arguments.

    :param args: the list of arguments to process (default: `sys.argv[1:]`)
    :returns: a Namespace instance.
    """
    ucr = ConfigRegistry()
    ucr.load()

    parser = ArgumentParser(description=__doc__)
    parser.add_argument("--translog-file", "-T", metavar="FILENAME", help="Transaction file [%(default)s]", default="/var/lib/univention-ldap/notify/transaction")
    parser.add_argument("--translog-ldap", "-H", metavar="URL", help="LDAP URL [%(default)s]", default="ldapi:///")
    parser.add_argument("--translog-base", "-B", metavar="DN", help="LDAP base for translog [%(default)s]", default="cn=translog")
    parser.add_argument("--lenient", "-l", action="store_true", help="Ignore existing entries")
    parser.add_argument("--verbose", "-v", action="count", help="Increase verbosity", default=0)
    parser.add_argument("--dry-run", "-n", action="store_true", help="Do not modify anything")
    parser.add_argument("--datetime", "-d", help="Overwrite time-stamp for import [%(default)s]", default=strftime("%Y%m%d%H%M%SZ"))
    subparsers = parser.add_subparsers(title="subcommands", description="valid subcommands")

    parser_import = subparsers.add_parser("import", help="Import transaction file into LDAP")
    parser_import.add_argument("--index", "-i", action="store_false", help="Do not use index to find transactions")
    import_amount = parser_import.add_argument_group("minimum", description="Amount of transactions to import")
    import_amount.add_argument("--count", "-c", action="store", type=parse_count, help="Minimum number of transaction [%(default)s]", default=100000)
    import_amount.add_argument("--percent", "-p", action="store", type=parse_percent, help="Minimum percentage of transaction file [%(default)s%%]", default="0")
    import_amount.add_argument("--size", "-s", action="store", type=parse_size, help="Minimum number of bytes from transaction file [%(default)s]", default="10M")
    import_limit = parser_import.add_argument_group("limit", description="Limit transactions to process")
    import_limit.add_argument("--min", "-m", action="store", type=parse_count, help="First transaction ID to process [%(default)s]", default=1)
    import_limit.add_argument("--max", "-M", action="store", type=parse_count, help="Last transaction ID to process")
    parser_import.set_defaults(func=import_all)

    parser_load = subparsers.add_parser("load", help="Load sepcified transactions into LDAP")
    parser_load.add_argument("trans", metavar="tid", type=int, nargs='+', help="Transaction number to process")
    parser_load.add_argument("--index", "-i", action="store_false", help="Do not use index to find transactions")
    parser_load.set_defaults(func=load_single)

    parser_lookup = subparsers.add_parser("lookup", help="Lookup transaction in file")
    parser_lookup.add_argument("trans", metavar="tid", type=int, nargs='+', help="Transaction number to lookup")
    parser_lookup.set_defaults(func=lookup)

    parser_ldap = subparsers.add_parser("ldap", help="Lookup transaction in LDAP")
    parser_ldap.add_argument("trans", metavar="tid", type=int, nargs='+', help="Transaction number to lookup")
    parser_ldap.set_defaults(func=lookup_ldap)

    parser_stat = subparsers.add_parser("stat", help="Show statistics")
    parser_stat.set_defaults(func=show_stat)

    parser_check = subparsers.add_parser("check", help="Check transaction files")
    parser_check.add_argument("--fix", "-f", action="store_true", help="Try to fix issues")
    parser_check.add_argument("--base", "-b", metavar="DN", help="LDAP base [%(default)s]", default=ucr['ldap/base'])
    parser_check.set_defaults(func=check)

    parser_index = subparsers.add_parser("index", help="Dump index file")
    parser_index.add_argument("--min", "-m", action="store", type=parse_count, help="First transaction ID to process [%(default)s]", default=1)
    parser_index.add_argument("--max", "-M", action="store", type=parse_count, help="Last transaction ID to process")
    parser_index.set_defaults(func=dump_index)

    opt = parser.parse_args(args)

    return opt


def parse_count(string):
    # type: (str) -> long
    """
    Parse count string.

    :param str: The command line string.
    :returns: The parsed count.
    :raises ArgumentTypeError: if the string is valid.
    """
    try:
        val = long(string)
        if not 0 < val:
            raise ValueError
    except ValueError:
        raise ArgumentTypeError("Invalid count")
    return val


def parse_percent(string):
    # type: (str) -> float
    """
    Parse percentage string.

    :param str: The command line string.
    :returns: The parsed percentage.
    :raises ArgumentTypeError: if the string is valid.
    """
    try:
        val = float(string.rstrip('%'))
        if not 0.0 <= val <= 100.0:
            raise ValueError()
    except ValueError:
        raise ArgumentTypeError("Invalid percentage")
    return val / 100.0


def parse_size(string):
    # type: (str) -> long
    """
    Parse size string.

    :param str: The command line string.
    :returns: The parsed size.
    :raises ArgumentTypeError: if the string is valid.
    """
    suffix = string.lstrip(".0123456789")
    try:
        unit, = suffix.rstrip("iIbB").upper() or ' '
        scale = 1L << (10 * " KMGTPE".index(unit))
    except ValueError:
        raise ArgumentTypeError("Invalid unit")

    prefix = string[:-len(suffix)] if suffix else string
    try:
        value = float(prefix)
        if not 0.0 <= value:
            raise ValueError()
    except ValueError:
        raise ArgumentTypeError("Invalid value")

    return long(value * scale)


if __name__ == "__main__":
    exit(main())
