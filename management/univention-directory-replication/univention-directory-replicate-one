#!/usr/bin/python2.6
#
# Univention Directory Replication
#  replicate one LDAP object
#
# Copyright 2004-2012 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.
# Univention Directory Listener replication module

import sys, os, pwd, types, ldap, ldap.schema, re, time, copy, codecs, base64
import univention_baseconfig, univention.debug

baseConfig = univention_baseconfig.baseConfig()
baseConfig.load()
baseConfig = baseConfig

baseDN = baseConfig['ldap/base']

def print_usage():
	print "\nUse: univention-directory-replicate-one <dn> (<server>)\n"
	print "The given <dn> will be read from <server> (or if server is not given from ldap_master)",
	print "and differences of the local settings will be changed to meet the given one.",

# replication-module
slave=0
if baseConfig['ldap/server/type'] == 'slave':
	slave=1

if baseConfig['ldap/slave/filter']:
	filter=baseConfig['ldap/slave/filter']

LDIF_FILE = '/var/lib/univention-directory-replication/failed.ldif'

EXCLUDE_ATTRIBUTES=['subschemaSubentry', 'hasSubordinates']

# don't use built-in OIDs from slapd
BUILTIN_OIDS=[
	# attributeTypes
	'1.3.6.1.1.4',			# vendorName
	'1.3.6.1.1.5',			# vendorVersion
	'1.3.6.1.4.1.250.1.57',         # labeledURI
	'1.3.6.1.4.1.250.1.32',         # krbName
	'1.3.6.1.4.1.1466.101.119.2',   # dynamicObject
	'1.3.6.1.4.1.1466.101.119.3',   # entryTtl
	'1.3.6.1.4.1.1466.101.119.4',   # dynamicSubtrees
	'1.3.6.1.4.1.1466.101.120.5',	# namingContexts
	'1.3.6.1.4.1.1466.101.120.6',	# altServer
	'1.3.6.1.4.1.1466.101.120.7',	# supportedExtension
	'1.3.6.1.4.1.1466.101.120.13',	# supportedControla
	'1.3.6.1.4.1.1466.101.120.14',	# supportedSASLMechanisms
	'1.3.6.1.4.1.1466.101.120.15',	# supportedLDAPVersion
	'1.3.6.1.4.1.1466.101.120.16',	# ldapSyntaxes (operational)
	'1.3.6.1.4.1.1466.101.120.111',	# extensibleObject
	'1.3.6.1.4.1.4203.1.4.1',	# OpenLDAProotDSE
	'1.3.6.1.4.1.4203.1.3.1',       # entry
	'1.3.6.1.4.1.4203.1.3.2',       # children
	'1.3.6.1.4.1.4203.1.3.3',       # supportedAuthPasswordSchemes
	'1.3.6.1.4.1.4203.1.3.4',       # authPassword
	'1.3.6.1.4.1.4203.1.3.5',	# supportedFeatures
	'1.3.6.1.4.1.4203.666.1.5',     # OpenLDAPaci
	'1.3.6.1.4.1.4203.666.1.6',     # entryUUID
	'1.3.6.1.4.1.4203.666.1.7',     # entryCSN
	'1.3.6.1.4.1.4203.666.1.8',     # saslAuthzTo
	'1.3.6.1.4.1.4203.666.1.9',     # saslAuthzFrom
	'1.3.6.1.4.1.4203.666.1.10',    # monitorContext
	'1.3.6.1.4.1.4203.666.1.11',    # superiorUUID
	'1.3.6.1.4.1.4203.666.1.13',    # namingCSN
	'1.3.6.1.4.1.4203.666.1.23',    # syncreplCookie
	'1.3.6.1.4.1.4203.666.1.25',    # contextCSN
	'1.3.6.1.4.1.4203.666.1.33',    # entryDN
	'1.3.6.1.4.1.4203.666.3.4',     # glue
	'1.3.6.1.4.1.4203.666.3.5',     # syncConsumerSubentry
	'1.3.6.1.4.1.4203.666.3.6',     # syncProviderSubentry
	'2.5.4.0',			# objectClass
	'2.5.4.1',			# aliasedObjectName
	'2.5.4.3',			# cn
	'2.5.4.35',			# userPassword
	'2.5.4.41',			# name
	'2.5.4.49',			# dn
	'2.5.6.0',			# top
	'2.5.6.1',			# alias
	'2.5.17.0',			# subentry
	'2.5.17.2',                     # collectiveAttributeSubentry
	'2.5.18.1',			# createTimestamp
	'2.5.18.2',			# modifyTimestamp
	'2.5.18.3',			# creatorsName
	'2.5.18.4',			# modifiersName
	'2.5.18.5',                     # administrativeRole
	'2.5.18.6',                     # subtreeSpecification
	'2.5.18.7',                     # collectiveExclusions
	'2.5.18.9',			# hasSubordinates
	'2.5.18.10',			# subschemaSubentry
	'2.5.18.12',                    # collectiveAttributeSubentries
	'2.5.20.1',			# subschema
	'2.5.21.1',                     # ditStructureRules
	'2.5.21.2',                     # ditContentRules
	'2.5.21.4',			# matchingRules
	'2.5.21.5',			# attributeTypes
	'2.5.21.6',			# objectClasses
	'2.5.21.7',                     # nameForms
	'2.5.21.8',			# matchingRuleUse
	'2.5.21.9',			# structuralObjectClass
	# objectClasses
	'2.16.840.1.113730.3.2.6',	# referral
	'2.16.840.1.113730.3.1.34',	# ref (operational)
]

class LDIFObject:
	def __init__(self, file):
		self.fp = open(file, 'a')

	def __print_attribute(self, attribute, value):
		pos = len(attribute)+2 # +colon+space
		encode = 0
		if '\n' in value:
			encode = 1
		try:
			(newval,leng)=value
			newval=newval.encode('ascii')
		except UnicodeError:
			encode = 1
		if encode:
			pos += 1 # value will be base64 encoded, thus two colons
			print >>self.fp, '%s::' % attribute,
			value=base64.encodestring(value).replace('\n', '')
		else:
			print >>self.fp, '%s:' % attribute,

		while value:
			if pos == 1:
				# first column is space
				print >>self.fp, '',
			print >>self.fp, value[0:60-pos]
			value = value[60-pos:]
			pos = 1

	def __new_entry(self, dn):
		self.__print_attribute('dn', dn)
	def __end_entry(self):
		print >>self.fp
		self.fp.flush()
	def __new_section(self):
		pass
	def __end_section(self):
		print >>self.fp, '-'

	def add_s(self, dn, al):
		self.__new_entry(dn)
		self.__print_attribute('changetype', 'add')
		for attr, vals in al:
			for val in vals:
				self.__print_attribute(attr, val)
		self.__end_entry()

	def modify_s(self, dn, ml):
		self.__new_entry(dn)
		self.__print_attribute('changetype', 'modify')
		for type, attr, vals in ml:
			self.__new_section()
			if type == ldap.MOD_REPLACE:
				op = 'replace'
			elif type == ldap.MOD_ADD:
				op = 'add'
			elif type == ldap.MOD_DELETE:
				op = 'delete'
			self.__print_attribute(op, attr)
			for val in vals:
				self.__print_attribute(attr, val)
			self.__end_section()
		self.__end_entry()

	def delete_s(self, dn):
		self.__new_entry(dn)
		self.__print_attribute('changetype', 'delete')
		self.__end_entry()

reconnect=0
connection=None
def connect(ldif=0):
	global connection
	global reconnect

	if connection and not reconnect:
		return connection

	if not os.path.exists(LDIF_FILE) and not ldif:
		# ldap connection
		if os.path.exists('/var/run/ldapi.sock'):
			sock='/var/run/ldapi.sock'
		else:
			sock='/var/lib/ldapi.sock'

		if not os.path.exists('/etc/ldap/rootpw.conf'):
			pw=new_password()
			init_slapd('restart')
		else:
			pw=get_password()
			if not pw:
				pw=new_password()
				init_slapd('restart')

		try:
			connection=ldap.open(sock)
			connection.simple_bind_s('cn=update,'+baseConfig['ldap/base'], pw)
		finally:
			pass
	else:
		try:
			connection=LDIFObject(LDIF_FILE)
		finally:
			pass

	reconnect=0
	return connection

def addlist(new):
	al=[]
	for key in new.keys():
		if key in EXCLUDE_ATTRIBUTES:
			continue
		al.append((key, new[key]))
	return al

def modlist(old, new):
	ml=[]
	for key in new.keys():
		if key in EXCLUDE_ATTRIBUTES:
			continue
		if not old.has_key(key):
			ml.append((ldap.MOD_ADD, key, new[key]))
		elif new[key] != old[key]:
			ml.append((ldap.MOD_REPLACE, key, new[key]))
	for key in old.keys():
		if key in EXCLUDE_ATTRIBUTES:
			continue
		if not new.has_key(key):
			ml.append((ldap.MOD_DELETE, key, []))
	return ml

def subschema_oids_with_sup(subschema, type, oid, result):
	if oid in BUILTIN_OIDS or oid in result:
		return

	obj = subschema.get_obj(type, oid)
	for i in obj.sup:
		sup_obj = subschema.get_obj(type, i)
		subschema_oids_with_sup(subschema, type, sup_obj.oid, result)
	result.append(oid)

def subschema_sort(subschema, type):

	result = []
	for oid in subschema.listall(type):
		subschema_oids_with_sup(subschema, type, oid, result)
	return result

def update_schema(attr):

	try:
		fp = open('/var/lib/univention-ldap/schema.conf.new', 'w')
	finally:
		pass

	queue = []

	print >>fp, '# This schema was automatically replicated from the master server'
	print >>fp, '# Please do not edit this file\n'
	subschema = ldap.schema.SubSchema(attr)

	for oid in subschema_sort(subschema, ldap.schema.AttributeType):
		if oid in BUILTIN_OIDS:
			continue
		obj = subschema.get_obj(ldap.schema.AttributeType, oid)
		print >>fp, 'attributetype', str(obj)

	for oid in subschema_sort(subschema, ldap.schema.ObjectClass):
		if oid in BUILTIN_OIDS:
			continue
		obj = subschema.get_obj(ldap.schema.ObjectClass, oid)
		print >>fp, 'objectclass', str(obj)

	fp.close()

	# move temporary file

	try:
		os.rename('/var/lib/univention-ldap/schema.conf.new', '/var/lib/univention-ldap/schema.conf')
	finally:
		pass

	init_slapd('restart')

def handler(dn, new, listener_old):
	global reconnect
	global slave
	if not slave:
		return 1

	if dn == 'cn=Subschema':
		return update_schema(new)

	connect_count=0
	connected=0

	while connect_count < 31 and not connected:
		try:
			l=connect()
		except ldap.LDAPError, msg:
			connect_count=connect_count+1
			if connect_count >= 30:
				print "connect to local LDAP failed, exit"
				sys.exit(1)
			else:
				univention.debug.debug(univention.debug.LISTENER, univention.debug.WARN, 'Can not connect LDAP Server (%s), retry in 10 seconds' % msg[0]['desc'])
				time.sleep(10)
		else:
			connected=1
	try:
		# Read old entry directly from LDAP server
		if not listener_old or not isinstance(l, LDIFObject):
			try:
				res=l.search_s(dn, ldap.SCOPE_BASE, '(objectClass=*)', ['*', '+'])
			except ldap.NO_SUCH_OBJECT:
				old={}
			except ldap.SERVER_DOWN:
				old=listener_old
			else:
				if res:
					old=res[0][1]
				else:
					old={}
		else:
			old=listener_old
		# add
		if new and not old:
			al=addlist(new)
			univention.debug.debug(univention.debug.LISTENER, univention.debug.ALL, 'add: %s' % dn)
			try:
				l.add_s(dn, al)
			except ldap.OBJECT_CLASS_VIOLATION, msg:
				univention.debug.debug(univention.debug.LISTENER, univention.debug.ERROR, 'replication: object class violation while adding %s' % dn)
		# delete
		elif old and not new:
			univention.debug.debug(univention.debug.LISTENER, univention.debug.ALL, 'delete: %s' % dn)
			try:
				l.delete_s(dn)
			except ldap.NOT_ALLOWED_ON_NONLEAF, msg:
				univention.debug.debug(univention.debug.LISTENER, univention.debug.WARN, 'Failed to delete non leaf object: dn=[%s];' % dn)
				dns=[]
				for dn,attr in l.search_s(dn, ldap.SCOPE_SUBTREE, '(objectClass=*)'):
					dns.append(dn)
				dns.reverse()
				for dn in dns:
					l.delete_s(dn)
		# modify
		else:
			ml=modlist(old, new)
			if ml:
				univention.debug.debug(univention.debug.LISTENER, univention.debug.ALL, 'modify: %s' % dn)
				l.modify_s(dn, ml)
	except ldap.SERVER_DOWN, msg:
		univention.debug.debug(univention.debug.LISTENER, univention.debug.WARN, '%s: retrying' % msg[0]['desc'])
		reconnect=1
		handler(dn, new, old)
	except ldap.ALREADY_EXISTS, msg:
		univention.debug.debug(univention.debug.LISTENER, univention.debug.WARN, '%s: %s; trying to apply changes' % (msg[0]['desc'], dn))
		try:
			cur = l.search_s(dn, ldap.SCOPE_BASE, '(objectClass=*)')[0][1]
		except LDAPError, msg:
			univention.debug.debug(univention.debug.LISTENER, univention.debug.ERROR, '%s: going into LDIF mode' % msg[0]['desc'])
			reconnect=1
			connect(ldif=1)
			handler(dn, new, old)
		handler(dn, new, cur)

	except ldap.CONSTRAINT_VIOLATION, msg:
		univention.debug.debug(univention.debug.LISTENER, univention.debug.ERROR, 'Constraint violation: dn=%s: %s' % (dn,msg[0]['desc']))
	except ldap.LDAPError, msg:
		univention.debug.debug(univention.debug.LISTENER, univention.debug.ERROR, 'dn=%s: %s' % (dn,msg[0]['desc']))
		reconnect=1
		connect(ldif=1)
		handler(dn, new, old)


def new_password():
	pw=univention_baseconfig.randpw()

	try:
		f = open('/etc/ldap/rootpw.conf', 'w')
		f.close()
		os.chmod('/etc/ldap/rootpw.conf', 0600)
		f = open('/etc/ldap/rootpw.conf', 'w')
		print >>f, 'rootpw "%s"' % pw
		f.close()
	finally:
		pass

	return pw

def get_password():
	pwd=''
	try:
		f = open('/etc/ldap/rootpw.conf', 'r')
		rootdn_pattern=re.compile('^rootpw[ \t]+"([^"]+)"')
		for line in f.readlines():
			line=line[0:-1]
			if rootdn_pattern.match(line):
				pwd = rootdn_pattern.findall(line)[0]
				break
		f.close()
	finally:
		pass
	return pwd


if len(sys.argv) < 2 or len(sys.argv) > 3:
	print_usage();
	sys.exit(1)

replicationDN = sys.argv[1]

ldapServer = baseConfig['ldap/master']
if len(sys.argv) > 2:
	ldapServer = sys.argv[2]

#bind to remote server
lomaster = ldap.open(ldapServer, 7389)
bindpw = open('/etc/machine.secret').read()
if bindpw[-1] == '\n':
	bindpw=bindpw[0:-1]
	lomaster.simple_bind_s(baseConfig['ldap/hostdn'], bindpw)

res = lomaster.search_s(replicationDN, ldap.SCOPE_BASE, '(objectClass=*)', ['*', '+'])
#print "found: \n%s" % res

if not res or len(res)<1:
	print "Failed to get search-result for %s" % replicationDN
	sys.exit(2)
handler(replicationDN, res[0][1], '')
print "replication done for %s" % replicationDN
