#!/usr/bin/python2.6
# -*- coding: utf-8 -*-
#
# Univention Management Console
#  UMC web server
#
# Copyright 2011 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.

import sys
import os
import cherrypy
import threading
import notifier
import Queue
import univention.management.console.protocol as umcp
import univention.debug as ud
import simplejson

from optparse import OptionParser
from daemon.runner import DaemonRunner, DaemonRunnerStopFailureError, DaemonRunnerStartFailureError

from univention.management.console.log import *

import univention.config_registry as ucr
configRegistry = ucr.ConfigRegistry()
configRegistry.load()

_thread_http = None
_sessionclients = {}
_queue_send = Queue.Queue()

_sessionidcounter = 1


# Traceback (most recent call last):
#   File "./umc2-webserver.py", line 507, in ?
#     main()
#   File "./umc2-webserver.py", line 503, in main
#     notifier.loop()
#   File "/usr/lib/python2.4/site-packages/notifier/nf_generic.py", line 272, in loop
#     step()
#   File "/usr/lib/python2.4/site-packages/notifier/nf_generic.py", line 264, in step
#     __min_timer = dispatch.dispatcher_run()
#   File "/usr/lib/python2.4/site-packages/notifier/dispatch.py", line 71, in dispatcher_run
#     if not disp():
#   File "./umc2-webserver.py", line 116, in check_queue
#     client.send_request( queuerequest.request, queuerequest.response_queue )
#   File "./umc2-webserver.py", line 61, in send_request
#     self.client.request( request )
#   File "/usr/lib/python2.4/site-packages/univention/management/console/protocol/client.py", line 228, in request
#     if self._resend( sock ):
#   File "/usr/lib/python2.4/site-packages/univention/management/console/protocol/client.py", line 199, in _resend
#     self.__realsocket.shutdown( socket.SHUT_RDWR )
#   File "<string>", line 1, in shutdown
#   File "/usr/lib/python2.4/socket.py", line 136, in _dummy
#     raise error(EBADF, 'Bad file descriptor')
# socket.error: (9, 'Bad file descriptor')


class SessionClient(object):
	def __init__(self):
		CORE.info('SessionClient: creating new session')
		self.client = umcp.Client()
		self.client.signal_connect( 'authenticated', self._authenticated )
		self.client.signal_connect( 'response', self._response )
		self.client.signal_connect( 'closed', self._closed )
		if self.client.connect():
			CORE.info('SessionClient: connected to UMC server')
		else:
			CORE.error('SessionClient: connection to UMC server failed')
		self._auth_response = None
		self._auth_response_queue = None
		self._requestid2response_queue = {}

	def _authenticated(self, success, status, message):
		CORE.error('SessionClient: _authenticated: success=%s  status=%s  message=%s' % (success, status, message) )
		self._auth_response.status = status
		self._auth_response_queue.put( self._auth_response )
		# release queue object
		self._auth_response_queue = None

	def authenticate_user(self, request, response_queue):
		CORE.info('SessionClient: authenticate_user: sending authentication request for user %s' % request.body[ 'username' ])
		self._auth_response = umcp.Response( request )
		self._auth_response.body['sessionid'] = request.body.get('sessionid','')
		self._auth_response_queue = response_queue
		self.client.authenticate( request.body[ 'username' ], request.body[ 'password' ] )

	def _closed(self):
		global _sessionclients
		CORE.error('SessionClient: lost connection to UMC server')

		# remove client from global dict _sessionclients
		#TODO: client should not manipulate the _sessionclients, this should
		#      be done elsewhere, e.g., in the dispatcher
		sessionID = None
		for iid, v in _sessionclients.iteritems():
			if v == self:
				sessionID = iid
		if sessionID:
			del _sessionclients[sessionID]

	def _response(self, response):
		if not response.id in self._requestid2response_queue:
			CORE.error('SessionClient: could not find request id for response %s, status %d:' % ( str( response.id ), response.status ) )
		else:
			CORE.info('SessionClient: got response with id=%s and status=%s' % ( response.id, response.status ) )
			self._requestid2response_queue[ response.id ].put( response )
			# remove response_queue from internal mapping
			self.cleanup_request( response )

	def send_request(self, request, response_queue):
		CORE.info('SessionClient: sending request with id=%s' % request.id)
		self._requestid2response_queue[request.id] = response_queue
		self.client.request( request )

	def cleanup_request(self, request):
		del self._requestid2response_queue[request.id]


class UMCP_Dispatcher(object):
	def __init__(self):
		pass

	def check_queue(self):
		global _sessionclients, _sessionidcounter, _queue_send
		while _queue_send.qsize():
			CORE.info('UMCP_Dispatcher: check_queue: new object in queue')
			try:
				queuerequest = _queue_send.get_nowait()
			except Queue.Empty:
				# Queue is empty - nothing to do
				return

			if not type(queuerequest.sessionid) == str and not queuerequest.sessionid == None:
				CORE.error('UMCP_Dispatcher: check_queue: got invalid sessionid: %s' % repr(queuerequest.sessionid))
			if not isinstance(queuerequest.request, umcp.Request):
				CORE.error('UMCP_Dispatcher: check_queue: got invalid UMCP request: %s' % repr(queuerequest.request))
			if not isinstance(queuerequest.response_queue, Queue.Queue):
				CORE.error('UMCP_Dispatcher: check_queue: got invalid response_queue: %s' % repr(queuerequest.response_queue))

			# stop here if sessionid is missing or unknown and request is no AUTH request
			if ( not queuerequest.sessionid or not queuerequest.sessionid in _sessionclients.keys() ) and not queuerequest.request.command == 'AUTH':
				CORE.error('UMCP_Dispatcher: check_queue: invalid session: sessionid=%s' % repr(queuerequest.sessionid))
				response = umcp.Response( queuerequest.request )
				response.status = 401 # set status to unauthorized
				queuerequest.response_queue.put( response )
				return True

			if queuerequest.request.command == 'AUTH':
				# AUTH request
				CORE.info('UMCP_Dispatcher: check_queue: AUTH request')
				if not queuerequest.sessionid:
					CORE.info('UMCP_Dispatcher: check_queue: creating new sessionid')
					# FIXME: create nice session id via uuid or something else
					queuerequest.sessionid = '%d' % _sessionidcounter
					_sessionidcounter += 1
				# create new session / umcp client
				_sessionclients[ queuerequest.sessionid ] = SessionClient()
				client = _sessionclients.get(queuerequest.sessionid)

				# save new sessionid in UMCP request so it can be returned after authentication
				queuerequest.request.body['sessionid'] = queuerequest.sessionid
				client.authenticate_user( queuerequest.request, queuerequest.response_queue )
			else:
				# COMMAND / GET / SET request
				CORE.info('UMCP_Dispatcher: check_queue: normal request')
				client = _sessionclients.get(queuerequest.sessionid)
				try:
					client.send_request( queuerequest.request, queuerequest.response_queue )
				except umcp.client.NotAuthenticatedError:
					response = umcp.Response( queuerequest.request )
					response.status = 401 # set status to unauthorized
					queuerequest.response_queue.put( response )
					# remove response_queue from internal mapping
					client.cleanup_request( queuerequest.request )

		return True


class QueueRequest(object):
	def __init__(self, sessionid, request, response_queue):
		self.sessionid = sessionid
		self.request = request
		self.response_queue = response_queue

def update_session_cookie(cookiejar, sessionid):
	cookiejar['UMCSessionId'] = sessionid
	cookiejar['UMCSessionId']['max-age'] = 180
	cookiejar['UMCSessionId']['version'] = 1
	cookiejar['UMCSessionId']['path'] = '/'
	# TODO FIXME set session timeout via UCR variable


class CPgeneric(object):
	name = 'CPgeneric'

	_logOptions = {
		'error': CORE.error,
		'warn': CORE.warn,
		'info': CORE.info,
	}

	def _log(self, loglevel, _msg):
		remote = cherrypy.request.remote
		msg = '%s (%s:%s) %s' % (self.name,  remote.ip, remote.port, _msg)
		self._logOptions.get(loglevel, CORE.info)(msg)

	def get_request(self, request, json):
		req = umcp.Request( [ 'generic' ], opts = {} )
		return req

	@cherrypy.expose
	def default(self, *args):
		global _queue_send
		remote = cherrypy.request.remote
		self._log('info', 'got new request')

		cookie = cherrypy.request.cookie
		if cookie.get('UMCSessionId'):
			sessionid = cookie['UMCSessionId'].value
			self._log('info', 'found sessionid')
			self._log(99, 'sessionid="%s"' % (sessionid))
		else:
			# a sessionid is required to use this command
			self._log('info', 'no sessionid found')
			raise cherrypy.HTTPError(401)

		if not cherrypy.request.headers.get(u"Content-Length", u""):
			json = ''
			self._log('warn', 'missing Content-Length header')
		else:
			# get body and parse json
			body = ''
			if cherrypy.request.body:
				body = cherrypy.request.body.read()

			try:
				json = simplejson.loads(body)
			except ValueError:
				self._log('error', 'cannot parse JSON body')
				raise cherrypy.HTTPError(400, 'Invalid JSON document')

		# create new UMCP request
		req = self.get_request( cherrypy.request, json )

		# create new response queue
		response_queue = Queue.Queue()

		# send request to UMC server
		request = QueueRequest(sessionid, req, response_queue)
		_queue_send.put(request)

		self._log('info', 'pushed request %s to queue - waiting for response (sessionid="%s")' % (req.id, sessionid))
		response = response_queue.get()
		self._log('info', 'got response %s with status %s (sessionid="%s")' % (response.id, response.status, sessionid))

		if response.status == 200:
			update_session_cookie(cherrypy.response.cookie, sessionid)
			return simplejson.dumps(response.body)

		elif response.status in (401,403,404, 411):
			# user is unauthorized
			raise cherrypy.HTTPError(response.status)

		# something bad happened
		self._log('error', 'unhandled response status code: %s' % response.status)
		raise cherrypy.HTTPError(500)


class CPGet(CPgeneric):
	name = 'CPGet'
	requestprefix = '/get'

	def get_request(self, request, json):
		args = request.path_info

		if args.startswith( self.requestprefix ):
			args = args[ len(self.requestprefix)+1 : ]

		if not args:
			self._log('error', 'get_request: args is empty')
			raise cherrypy.HTTPError(404)

		req = umcp.Request( 'GET', arguments = [ args ] )

		return req


class CPSet(CPgeneric):
	name = 'CPSet'
	requestprefix = '/set'

	def get_request(self, request, json):
		args = request.path_info

		req = umcp.Request( 'SET', options = json.get( 'options', {} ) )

		return req


class CPCommand(CPgeneric):
	name = 'CPCommand'
	requestprefix = '/command'

	def get_request(self, request, json):
		args = request.path_info

		if args.startswith( self.requestprefix ):
			args = args[ len(self.requestprefix)+1 : ]

		if not args:
			self._log('error', 'get_request: args is empty')
			raise cherrypy.HTTPError(404)

		req = umcp.Command( [ args ], options = json.get( 'options', {} ) )
		if 'flavor' in json:
			req.flavor = json[ 'flavor' ]

		return req


# class CPCommand(object):
# 	@cherrypy.expose
# 	def default(self, *args):
# 		global _queue_send
# 		remote = cherrypy.request.remote
# 		CORE.info('CPRoot/command: got new request (%s:%s <=> %s)' % (remote.ip, remote.port, remote.name))

# 		cookie = cherrypy.request.cookie
# 		if cookie.get('UMCSessionId'):
# 			sessionid = cookie['UMCSessionId'].value
# 			CORE.info('CPRoot/command: sessionid="%s"' % (sessionid))
# 		else:
# 			# a sessionid is required to use this command
# 			CORE.info('CPRoot/command: no sessionid found')
# 			raise cherrypy.HTTPError(401)

# 		if not cherrypy.request.headers.get(u"Content-Length", u""):
# 			CORE.error('CPRoot/command: missing Content-Length header')
# 			raise cherrypy.HTTPError(411)

# 		# get body and parse json
# 		body = ''
# 		if cherrypy.request.body:
# 			body = cherrypy.request.body.read()

# 		try:
# 			json = simplejson.loads(body)
# 		except ValueError:
# 			CORE.error('CPRoot/auth: cannot parse JSON body')
# 			raise cherrypy.HTTPError(400, 'Invalid JSON document')

# 		command = cherrypy.request.path_info
# 		if command.startswith('/command'):
# 			command = command[9:]
# 		CORE.info('CPRoot/command: request: command=%s' % command )
# 		CORE.info('CPRoot/command: json=%s' % json)

# 		if not command:
# 			CORE.error('CPRoot/command: request: command is empty')
# 			raise cherrypy.HTTPError(404)

# 		# create new UMCP request
# 		req = umcp.Command( [ command ], opts = json )

# 		# create new response queue
# 		response_queue = Queue.Queue()

# 		# send request to UMC server
# 		request = QueueRequest(sessionid, req, response_queue)
# 		_queue_send.put(request)

# 		CORE.info('CPRoot/command: pushed request %s to queue - waiting for response (sessionid="%s")' % (request.id, sessionid))
# 		response = response_queue.get()
# 		CORE.info('CPRoot/command: got response %s with status %s (sessionid="%s")' % (response.id, response.status, sessionid))

# 		if response.status == 200:
# 			update_session_cookie(cherrypy.response.cookie, sessionid)
# 			return "I got my response: %s<br>\n%s" % (response.status, response)

# 		elif response.status == 410:
# 			# user is unauthorized
# 			raise cherrypy.HTTPError(401)

# 		elif response.status == 401:
# 			# unknown command
# 			CORE.error('CPRoot/command: unknown command: %s (response.status=%s)' % (command, response.status))
# 			raise cherrypy.HTTPError(404)

# 		# something bad happened
# 		CORE.error('CPRoot/command: unhandled response status: %s' % response.status)
# 		raise cherrypy.HTTPError(500)


class CPAuth(object):
	@cherrypy.expose
	def default(self):
		global _queue_send
		remote = cherrypy.request.remote
		CORE.info('CPRoot/auth: got new auth request (%s:%s <=> %s)' % (remote.ip, remote.port, remote.name))

		if not cherrypy.request.headers.get(u"Content-Length", u""):
			CORE.error('CPRoot/auth: missing Content-Length header')
			raise cherrypy.HTTPError(411)

		# TODO FIXME check body length and stop here if too much data has been sent by client

		# get body and parse json
		body = ''
		if cherrypy.request.body:
			body = cherrypy.request.body.read()

		try:
			json = simplejson.loads(body)
		except ValueError:
			CORE.error('CPRoot/auth: cannot parse JSON body')
			raise cherrypy.HTTPError(400, 'Invalid JSON document')

		CORE.info('CPRoot/command: request: command=%s' % cherrypy.request.path_info )
		CORE.info('CPRoot/command: json=%s' % json)

		# create new UMCP request
		req = umcp.Request( 'AUTH' )
		req.body[ 'username' ] = json[ 'options' ].get('username','')
		req.body[ 'password' ] = json[ 'options' ].get('password','')

		# create new response queue
		response_queue = Queue.Queue()

		# send request to UMC server
		request = QueueRequest(None, req, response_queue)
		_queue_send.put(request)

		CORE.info('CPRoot/auth: pushed request to queue - waiting for response')
		response = response_queue.get()
		CORE.info('CPRoot/auth: got response with status %s' % response.status)

		if response.status == 200 and response.body.get('sessionid'):
			CORE.info('CPRoot/auth: creating cookie with sessionid=%s' % response.body.get('sessionid'))
			update_session_cookie(cherrypy.response.cookie, response.body['sessionid'])
			return ""

		elif response.status in (401,410,411):
			CORE.error('CPRoot/auth: authorization for %s failed' % json.get('username'))
			raise cherrypy.HTTPError(401)

		CORE.error('CPRoot/auth: unhandled status code: %s' % response.status)
		raise cherrypy.HTTPError(500)


# class CPGet(object):
# 	@cherrypy.expose
# 	def default(self, *args):
# 		global _queue_send
# 		remote = cherrypy.request.remote
# 		CORE.info('CPRoot/get: got new request (%s:%s <=> %s)' % (remote.ip, remote.port, remote.name))

# 		cookie = cherrypy.request.cookie
# 		if cookie.get('UMCSessionId'):
# 			sessionid = cookie['UMCSessionId'].value
# 			CORE.info('CPRoot/get: sessionid="%s"' % (sessionid))
# 		else:
# 			# a sessionid is required to use this command
# 			CORE.info('CPRoot/get: no sessionid found')
# 			raise cherrypy.HTTPError(401)

# 		if not cherrypy.request.headers.get(u"Content-Length", u""):
# 			CORE.error('CPRoot/get: missing Content-Length header')
# 			raise cherrypy.HTTPError(411)

# 		# get body and parse json
# 		body = ''
# 		if cherrypy.request.body:
# 			body = cherrypy.request.body.read()

# 		try:
# 			json = simplejson.loads(body)
# 		except ValueError:
# 			CORE.error('CPRoot/auth: cannot parse JSON body')
# 			raise cherrypy.HTTPError(400, 'Invalid JSON document')

# 		command = cherrypy.request.path_info
# 		if command.startswith('/get'):
# 			command = command[9:]
# 		CORE.info('CPRoot/get: request: command=%s' % command )
# 		CORE.info('CPRoot/get: json=%s' % json)

# 		if not command:
# 			CORE.error('CPRoot/get: request: command is empty')
# 			raise cherrypy.HTTPError(404)

# 		# create new UMCP request
# 		req = umcp.Request( 'GET', args = [ command ] )

# 		# create new response queue
# 		response_queue = Queue.Queue()

# 		# send request to UMC server
# 		request = QueueRequest(sessionid, req, response_queue)
# 		_queue_send.put(request)

# 		CORE.info('CPRoot/get: pushed request %s to queue - waiting for response (sessionid="%s")' % (request.id, sessionid))
# 		response = response_queue.get()
# 		CORE.info('CPRoot/get: got response %s with status %s (sessionid="%s")' % (response.id, response.status, sessionid))

# 		if response.status == 200:
# 			update_session_cookie(cherrypy.response.cookie, sessionid)
# 			return "I got my response: %s<br>\n%s" % (response.status, response)

# 		elif response.status == 410:
# 			# user is unauthorized
# 			raise cherrypy.HTTPError(401)

# 		elif response.status == 401:
# 			# unknown command
# 			CORE.error('CPRoot/get: unknown command: %s (response.status=%s)' % (command, response.status))
# 			raise cherrypy.HTTPError(404)

# 		# something bad happened
# 		CORE.error('CPRoot/get: unhandled response status: %s' % response.status)
# 		raise cherrypy.HTTPError(500)


class CPRoot(object):
	def index(self):
		"""
		http://localhost:8080/
		"""
		raise cherrypy.HTTPError(404)
	index.exposed = True


def run_cherrypy():
	# TODO FIXME Folgenden Configeintrag einbauen, wenn loglevel in (0,1,2)
	# 'server.environment': 'production',
	cherrypy.config.update( { 'server.socket_port': 8080,
							  'server.socket_host': '0.0.0.0',
							  'engine.autoreload_on': False,
							  } )
	cherrypy.tools.proxy(base=None, local='X-Forwarded-Host', remote='X-Forwarded-For', scheme='X-Forwarded-Proto')

	root = CPRoot()
	root.command = CPCommand()
	root.auth = CPAuth()
	root.get = CPGet()
	root.set = CPSet()

	cherrypy.quickstart(root=root)


class UMC_HTTP_Daemon(DaemonRunner):
	def __init__( self ):
		self.parser = OptionParser()
		self.parser.add_option( '-n', '--no-daemon', action = 'store_false',
						   dest = 'daemon_mode', default = True,
						   help = 'if set the process will not fork into the background' )
		try:
			default_debug = int( configRegistry.get( 'umc/server/debug/level', '1' ) )
		except:
			default_debug = 1
		self.parser.add_option( '-d', '--debug', action = 'store', type = 'int', dest = 'debug', default = default_debug,
						   help = 'if given than debugging is activated and set to the specified level [default: %default]' )
		self.parser.add_option( '-L', '--log-file', action = 'store',  dest = 'logfile', default = 'management-console-web-server',
						   help = 'specifies an alternative log file [default: %default]' )
		( self.options, self.arguments ) = self.parser.parse_args()

		# init logging
		if not self.options.daemon_mode:
			debug_fd = log_init( '/dev/stderr', self.options.debug )
		else:
			debug_fd = log_init( self.options.logfile, self.options.debug )

		# default action: start
		if not self.arguments:
			sys.argv[ 1 ] = 'start'
		elif self.arguments:
			sys.argv[ 1 ] = self.arguments[ 0 ]

		# for daemon runner
		if self.options.daemon_mode:
			self.stdin_path = os.path.devnull
			self.stdout_path = os.path.devnull
			self.stderr_path = os.path.devnull
		else:
			self.stdin_path = '/dev/stdin'
			self.stdout_path = '/dev/stderr'
			self.stderr_path = '/dev/stderr'
		self.pidfile_path = '/var/run/umc-web-server.pid'
		self.pidfile_timeout = 10

		# init daemon runner
		DaemonRunner.__init__( self, self )
		self.daemon_context.detach_process = self.options.daemon_mode
		self.daemon_context.files_preserve = [ debug_fd ]

	def _usage_exit( self, argv ):
		self.parser.error( 'invalid action' )
		sys.exit( 1 )

	def run(self):
		# start webserver as separate thread
		_thread_http = threading.Thread( target = run_cherrypy )
		_thread_http.deamon = True
		_thread_http.start()

		try:
			# start notifier loop
			umcp_dispatcher = UMCP_Dispatcher()
			notifier.init( notifier.GENERIC )
			notifier.dispatcher_add( umcp_dispatcher.check_queue )
			notifier.loop()
		except (SystemExit, KeyboardInterrupt), e:
			# stop the web server
			CORE.info('stopping cherrypy: %s' % str(e))
			cherrypy.engine.exit()
			CORE.info('cherrypy stopped')

if __name__ == '__main__':
	http_daemon = UMC_HTTP_Daemon()
	try:
		http_daemon.do_action()
	except DaemonRunnerStopFailureError, e:
		CORE.error( 'Failed to shutdown server gracefully (may be its already dead): %s' % str( e ) )
	except DaemonRunnerStartFailureError, e:
		CORE.error( 'Failed to start server: %s' % str( e ) )
