#!/usr/bin/python2.7
# -*- coding: utf-8 -*-
#
# Univention Management Console
#  UMC web server
#
# Copyright 2011-2015 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.

import os
import threading
from optparse import OptionParser
import signal
import sys
import tempfile
import time
import traceback
import functools
import uuid
import datetime
import json
import socket
from urlparse import urlparse
from httplib import REQUEST_ENTITY_TOO_LARGE, LENGTH_REQUIRED, NOT_FOUND, BAD_REQUEST, UNAUTHORIZED, SERVICE_UNAVAILABLE

import notifier
import cherrypy
from cherrypy.lib.httputil import valid_status
import Queue
from ipaddr import IPAddress
from cherrypy import HTTPError, HTTPRedirect
from daemon.runner import DaemonRunner, DaemonRunnerStopFailureError, DaemonRunnerStartFailureError

import univention.management.console.protocol as umcp
from univention.management.console.log import CORE, log_init
from univention.management.console.log import log_reopen
from univention.config_registry import ConfigRegistry

from saml2 import BINDING_HTTP_POST, BINDING_HTTP_ARTIFACT, BINDING_HTTP_REDIRECT, element_to_extension_element, time_util, ecp
from saml2.client import Saml2Client
from saml2.extension.pefim import SPCertEnc
from saml2.metadata import create_metadata_string
from saml2.ecp_client import PAOS_HEADER_INFO
from saml2.httputil import make_cookie, parse_cookie
from saml2.response import VerificationError, UnsolicitedResponse, StatusError
from saml2.s_utils import UnknownPrincipal, UnsupportedBinding, sid as generate_sid, rndstr
from saml2.samlp import Extensions
from saml2.sigver import MissingKey
#from saml2 import xmldsig as ds  # FIXME: pysaml2 v3 required

ucr = ConfigRegistry()
ucr.load()

_thread_http = None

try:
	_session_timeout = int(ucr.get('umc/http/session/timeout', 300))
except (TypeError, ValueError):
	CORE.process('Failed to read session timeout from UCR variable umc/http/session/timeout. Using default of 300 seconds')
	_session_timeout = 300


def log_exceptions(func):
	@functools.wraps(func)
	def _decorated(*args, **kwargs):
		try:
			return func(*args, **kwargs)
		except (HTTPError, HTTPRedirect, KeyboardInterrupt, SystemExit):
			raise # ignore system and common cherrypy exceptions
		except Exception:
			CORE.error('Traceback in %s(%r, %r):\n%s' % (func.__name__, args, kwargs, traceback.format_exc()))
			raise
	return _decorated


@log_exceptions
def _fix_uri_for_saml():
	scheme = cherrypy.request.scheme
	if cherrypy.request.headers.get('X-UMC-HTTPS') == 'on':
		scheme = 'https'
	cherrypy.request.uri = '%s://%s%s?%s' % (scheme, cherrypy.request.headers['Host'], cherrypy.request.path_info, cherrypy.request.query_string)
	foo = cherrypy.request.params
	try:
		cherrypy.request.params = {}
		cherrypy.request.process_query_string()
		cherrypy.request.query = cherrypy.request.params
	finally:
		cherrypy.request.params = foo
cherrypy.tools.fix_uri = cherrypy.Tool('before_handler', _fix_uri_for_saml)


class SessionClient(object):

	def __init__(self, timeout=300, ip=None):
		CORE.info('SessionClient(0x%x): creating new session' % (id(self),))
		self.client = umcp.Client()
		self.client.signal_connect('authenticated', self._authenticated)
		self.client.signal_connect('response', self._response)
		self.client.signal_connect('closed', self._closed)
		try:
			self.client.connect()
			CORE.info('SessionClient(0x%x): connected to UMC server' % (id(self),))
		except umcp.NoSocketError:
			CORE.warn('SessionClient(0x%x): connection to UMC server failed' % (id(self),))
			raise umcp.NoSocketError('Connection failed')
		self._auth_response = None
		self._auth_response_queue = None
		self._requestid2response_queue = {}
		self._timeout = timeout
		self._time_remaining = timeout
		self._timer()  # launch the timer
		self._lock = threading.Lock()
		self.ip = ip

	def renew_timer(self):
		"""Refresh the remaining time the session is will be held open."""
		self._time_remaining = self._timeout

	def _timer(self):
		"""In order to avoid problems when the system time is changed (e.g.,
		via rdate), we register a timer event that counts down the session
		timeout second-wise."""
		# count down the remaining time
		self._time_remaining -= 1

		if self._time_remaining <= 0:
			# session has timed out
			self._timed_out()
		else:
			# count down the timer second-wise (in order to avoid problems when
			# changing the system time, e.g. via rdate)
			notifier.timer_add(1000, self._timer)

	def _timed_out(self):
		"""Timer event: the session has expired and therefor the
		connection to the UMC server is closed as long as there are no
		open requests."""
		CORE.info('SessionClient(0x%x): timed out!' % (id(self),))
		if self._requestid2response_queue:
			CORE.info('SessionClient(0x%x): There are open requests (%s). Postpone session shutdown' % (id(self), ','.join(self._requestid2response_queue.keys())))
			self._timeout = 0  # wait until all requests are answered
		else:
			CORE.info('SessionClient(0x%x): Closing connection to UMC server' % (id(self),))
			self.client.disconnect()
		return False

	def _authenticated(self, success, response):
		"""Callback function for 'authenticated' from UMCP-Server."""
		CORE.process('SessionClient(0x%x): _authenticated: success=%s  status=%s  message=%s' % (id(self), success, response.status, response.message))
		self._auth_response.status = response.status
		self._auth_response.result = response.result
		self._auth_response.message = response.message
		self._auth_response_queue.put(self._auth_response)
		# release queue object
		self._auth_response_queue = None

	def authenticate_user(self, request, response_queue):
		"""Send authentication request to UMC server."""
		CORE.info('SessionClient(0x%x): authenticate_user: sending authentication request for user %s' % (id(self), request.body['username']))
		self._auth_response = umcp.Response(request)
		self._auth_response.body['sessionid'] = request.body.get('sessionid', '')
		self._auth_response_queue = response_queue
		self.client.authenticate(request)

	def _response(self, response):
		"""Queue response from UMC server."""
		self._lock.acquire()
		try:
			try:
				# get and remove queue for response
				queue = self._requestid2response_queue.pop(response.id)[0]
			except KeyError:
				CORE.process('SessionClient(0x%x): no request(%s) found: status=%s' % (id(self), response.id, response.status))
			else:
				CORE.info('SessionClient(0x%x): got response(%s): status=%s queue=0x%x' % (id(self), response.id, response.status, id(queue)))
				queue.put(response)
		finally:
			self._lock.release()

		# shutdown connection when the session is expired and there are no open requests
		if self._timeout == 0 and not self._requestid2response_queue:
			self.client.disconnect()

	def send_request(self, request, response_queue):
		"""Send request to UMC server."""
		CORE.info('SessionClient(0x%x): sending request(%s)' % (id(self), request.id))
		self._lock.acquire()
		try:
			self._requestid2response_queue[request.id] = (response_queue, request)
		finally:
			self._lock.release()
		try:
			self.client.request(request)
		except IOError:
			CORE.error(traceback.format_exc())
			self.client.disconnect()
			return
		self.renew_timer()

	def _closed(self):
		message = '\n'.join((
			'The connection to the Univention Management Console Server broke up unexpectedly. ',
			'If you have root permissions on the system you can restart UMC by executing the following commands:',
			' * invoke-rc.d univention-management-console-server restart',
			' * invoke-rc.d univention-management-console-web-server restart',
			'Otherwise please contact an administrator or try again later.'
		))
		if self._auth_response_queue is not None:
			self._auth_response.status = SERVICE_UNAVAILABLE
			self._auth_response.message = message
			self._auth_response_queue.put(self._auth_response)
			self._auth_response_queue = None
		for id, (queue, request) in self._requestid2response_queue.items():
			self._requestid2response_queue.pop(id)
			response = umcp.Response(request)
			response.status = SERVICE_UNAVAILABLE
			response.message = message
			queue.put(response)

	def cleanup_request(self, request):
		"""Remove request from mapping."""
		self._lock.acquire()
		try:
			del self._requestid2response_queue[request.id]
		finally:
			self._lock.release()


class UMCP_Dispatcher(object):

	"""Dispatcher used to exchange the requests between CherryPy and UMC"""
	# sessionid ==> SessionClient
	sessions = {}
	_queue_send = Queue.Queue()

	@classmethod
	@log_exceptions
	def check_queue(cls):
		while True:
			try:
				queuerequest = cls._queue_send.get_nowait()
			except Queue.Empty:
				# Queue is empty - nothing to do (for now)
				return True
			CORE.info('UMCP_Dispatcher: check_queue: new request: 0x%x' % (id(queuerequest),))

			if not isinstance(queuerequest.sessionid, basestring) and queuerequest.sessionid is not None:
				CORE.process('UMCP_Dispatcher: check_queue: got invalid sessionid: %r' % (queuerequest.sessionid,))
			if not isinstance(queuerequest.request, umcp.Request):
				CORE.process('UMCP_Dispatcher: check_queue: got invalid UMCP request: %r' % (queuerequest.request,))
			if not isinstance(queuerequest.response_queue, Queue.Queue):
				CORE.process('UMCP_Dispatcher: check_queue: got invalid response_queue: %r' % (queuerequest.response_queue,))

			# stop here if sessionid is missing or unknown and request is no AUTH request
			try:
				client = cls.sessions[queuerequest.sessionid]
				if queuerequest.ip != client.ip and not (queuerequest.ip in ('127.0.0.1', '::1') and client.ip in ('127.0.0.1', '::1')):
					CORE.process('The sessionid (ip=%s) is not valid for this IP address (%s)' % (client.ip, queuerequest.ip))
					raise ValueError()
			except (KeyError, ValueError):
				if queuerequest.request.command != 'AUTH':
					CORE.process('UMCP_Dispatcher: check_queue: invalid session: sessionid=%r' % (queuerequest.sessionid))
					response = umcp.Response(queuerequest.request)
					response.status = UNAUTHORIZED
					queuerequest.response_queue.put(response)
					continue  # with next request

			if queuerequest.request.command == 'AUTH':
				# AUTH request
				CORE.info('UMCP_Dispatcher: check_queue: AUTH request')
				if not queuerequest.sessionid:
					CORE.info('UMCP_Dispatcher: check_queue: creating new sessionid')
					# FIXME: create nice session id via uuid or something else
					queuerequest.sessionid = str(uuid.uuid4())
				# create new session / umcp client
				# add a small offset to the timeout in order to avoid a mismatch between frontend and backend
				try:
					client = SessionClient(timeout=_session_timeout + 5, ip=queuerequest.ip)
				except Exception as exc:
					CORE.process('Failed to create UMC connection: %s' % (exc,))
					response = umcp.Response(queuerequest.request)
					response.status = SERVICE_UNAVAILABLE
					response.message = '\n'.join((
						'The Univention Management Console Server is currently not running. ',
						'If you have root permissions on the system you can restart it by executing the following command:',
						' * invoke-rc.d univention-management-console-server restart',
						'The following logfile may contain information why the server is not running:',
						' * /var/log/univention/management-console-server.log',
						'Otherwise please contact an administrator or try again later.'
					))
					queuerequest.response_queue.put(response)
					continue

				cls.sessions[queuerequest.sessionid] = client
				callback = notifier.Callback(cls.cleanup_session, queuerequest.sessionid)
				client.client.signal_connect('closed', callback)

				# save new sessionid in UMCP request so it can be returned after authentication
				queuerequest.request.body['sessionid'] = queuerequest.sessionid
				client.authenticate_user(queuerequest.request, queuerequest.response_queue)
			else:
				# COMMAND / GET / SET request
				CORE.info('UMCP_Dispatcher: check_queue: normal request')
				try:
					client.send_request(queuerequest.request, queuerequest.response_queue)
				except umcp.client.NotAuthenticatedError:
					response = umcp.Response(queuerequest.request)
					response.status = UNAUTHORIZED
					queuerequest.response_queue.put(response)
					# remove response_queue from internal mapping
					client.cleanup_request(queuerequest.request)

	@classmethod
	def cleanup_session(cls, sessionid):
		"""Removes a session when the connection to the UMC server has died or the session is expired"""
		CORE.info('Open sessions: %s' % (','.join(cls.sessions.keys())))
		try:
			del cls.sessions[sessionid]
			CORE.info('Cleaning up session %s' % sessionid)
		except KeyError:
			CORE.info('Session %s not found' % sessionid)


class UploadManager(dict):

	def add(self, request_id, store):
		tmpfile = tempfile.NamedTemporaryFile(prefix=request_id, dir=umcp.TEMPUPLOADDIR, delete=False)
		if hasattr(store, 'file') and store.file is None:
			tmpfile.write(store.value)
		else:
			tmpfile.write(store.file.read())
		tmpfile.close()
		if request_id in self:
			self[request_id].append(tmpfile.name)
		else:
			self[request_id] = [tmpfile.name]

		return tmpfile.name

	def cleanup(self, request_id):
		if request_id in self:
			filenames = self[request_id]
			for filename in filenames:
				if os.path.isfile(filename):
					os.unlink(filename)
			del self[request_id]
			return True

		return False

_upload_manager = UploadManager()


class QueueRequest(object):

	"""Element for the request queue containing the assoziated session
	ID, the request object, a response queue and the request ip address."""

	def __init__(self, sessionid, request, response_queue, ip):
		self.sessionid = sessionid
		self.request = request
		self.response_queue = response_queue
		self.ip = ip


@log_exceptions
def default_error_page(status, message, traceback, version, result=None):
	""" The default error page for UMCP responses """
	status, _, description = valid_status(status)
	if status == 401 and message == description:
		message = ''
	response = {
		'status': status,
		'message': cherrypy._cperror._escape(str(message), True)  # html escaped
	}
	if result:
		response['result'] = result
	if traceback:
		response['message'] = '%s\n\n%s' % (response['message'], traceback)
	cherrypy.response.headers['Content-type'] = 'application/json'
	return json.dumps(response)


class UMC_HTTPError(HTTPError):

	""" HTTPError which sets a error result """

	def __init__(self, status=500, message=None, body=None):
		HTTPError.__init__(self, status, message)
		self.body = body

	def set_response(self):
		cherrypy._cperror.clean_headers(self.status)

		cherrypy.response.status = self.status
		content = default_error_page(self.status, self._message, None, None, self.body)
		cherrypy.response.body = content

		cherrypy.response.headers['Content-Length'] = len(content)

		cherrypy._cperror._be_ie_unfriendly(self.status)


class CPgeneric(object):

	# NOTE: only use CORE.process, _not_ CORE.error; since CORE.error writes as
	#	   well to /var/log/syslog, this seems to cause problems with cherrypy.
	# (Bug #22634)
	_logOptions = {
		'error': CORE.process,
		'warn': CORE.warn,
		'info': CORE.info,
	}

	@property
	def name(self):
		"""returns class name"""
		return self.__class__.__name__

	def _log(self, loglevel, _msg):
		remote = cherrypy.request.remote
		msg = '%s (%s:%s) %s' % (self.name, get_ip_address(), remote.port, _msg)
		self._logOptions.get(loglevel, CORE.info)(msg)

	def get_request(self, path, args):
		return umcp.Request(['generic'], opts={})

	def _get_cookie_names(self):
		req = cherrypy.request
		host = req.headers.get('Host', '')
		suffix = ''
		if ':' in host:
			suffix = '-%s' % host.split(':')[-1]
		return ('UMCSessionId%s' % suffix, 'UMCUsername%s' % suffix)

	@log_exceptions
	def get_session_id(self):
		"""get the current session ID, either set via headers or cookie."""
		# check for a valid session key
		req = cherrypy.request
		idCookie, userCookie = self._get_cookie_names()
		if req.cookie.get(idCookie):
			sessionid = req.cookie[idCookie].value
		elif req.cookie.get('UMCSessionId'):
			sessionid = req.cookie['UMCSessionId'].value
		else:
			# a sessionid is required to use this command
			self._log('info', 'no sessionid found')
			raise UMC_HTTPError(UNAUTHORIZED)

		self._log('info', 'found sessionid')
		self._log(99, 'sessionid="%s"' % (sessionid))
		return sessionid

	def set_cookies(self, sessionid=None, username=None):
		# set the cookie once during successful authentication
		# force expiration of cookie in 5 years from now on...
		# IE does not support max-age
		expiration = datetime.datetime.now()
		expiration = expiration.replace(year=expiration.year + 5)
		expirationStr = expiration.strftime("%a, %d-%b-%Y %H:%M:%S GMT")
		idCookie, userCookie = self._get_cookie_names()
		if sessionid:
			cherrypy.response.cookie[idCookie] = sessionid
			cherrypy.response.cookie[idCookie]['expires'] = expirationStr
			cherrypy.response.cookie[idCookie]['version'] = 1
			cherrypy.response.cookie[idCookie]['path'] = '/'
		if username:
			cherrypy.response.cookie[userCookie] = username
			cherrypy.response.cookie[userCookie]['expires'] = expirationStr
			cherrypy.response.cookie[userCookie]['version'] = 1
			cherrypy.response.cookie[userCookie]['path'] = '/'

	@log_exceptions
	def load_json(self, body):
		try:
			json_ = json.loads(body)
			if not isinstance(json_, dict):
				raise UMC_HTTPError(BAD_REQUEST, 'JSON document have to be dict')
		except ValueError:
			self._log('error', 'cannot parse JSON body')
			raise UMC_HTTPError(BAD_REQUEST, 'Invalid JSON document')
		return json_

	@cherrypy.expose
	@log_exceptions
	def default(self, *path, **kwargs):
		self._log('info', 'got new request')

		# get the session id from the request
		sessionid = self.get_session_id()

		if cherrypy.request.headers.get('Content-Type', '').startswith('application/json'):  # normal (json) request
			# get body and parse json
			body = '{}'
			if cherrypy.request.method in cherrypy.request.methods_with_bodies:
				if not cherrypy.request.headers.get(u"Content-Length"):
					self._log('warn', 'missing Content-Length header')
					raise UMC_HTTPError(LENGTH_REQUIRED, 'Missing Content-Length header')
				body = cherrypy.request.body.read()

			args = self.load_json(body)
		else:
			# request is not json
			args = {'options': kwargs}
			if 'flavor' in kwargs:
				args['flavor'] = kwargs['flavor']

		return self.get_response(sessionid, path, args)

	@log_exceptions
	def get_response(self, sessionid, path, args):
		# create new UMCP request
		req = self.get_request('/'.join(path), args)

		# create new response queue
		response_queue = Queue.Queue()

		# send request to UMC server
		request = QueueRequest(sessionid, req, response_queue, get_ip_address())
		UMCP_Dispatcher._queue_send.put(request)

		self._log('info', 'pushed request(0x%x) to queue(0x%x) - waiting for response (sessionid="%s")' % (id(req), id(response_queue), sessionid))
		response = response_queue.get()
		self._log('info', 'got response(0x%x) from queue(0x%x): status=%s (sessionid="%s")' % (id(response), id(response_queue), response.status, sessionid))

		status = response.status
		body = response.body
		if status is None:
			# if status is not set, treat as SUCCESS. See Bug #29957
			# UMCP responses which are not json do not have a status
			status = 200
		if 200 <= status < 300:
			if response.mimetype == umcp.MIMETYPE_JSON:
				# convert data to JSON
				body = json.dumps(response.body)

			# return response
			cherrypy.response.headers['Content-Type'] = response.mimetype
			cherrypy.response.status = status
			return body

		# TODO: 3xx handling

		# something bad happened
		self._log('error', 'response status code: %s' % response.status)
		self._log('error', 'response message: %s' % response.message)
		self._log('error', 'response result: %s' % response.result)
		raise UMC_HTTPError(response.status, response.message, response.result)


class CPGet(CPgeneric):

	@log_exceptions
	def get_request(self, path, args):
		if not path:
			self._log('error', 'get_request: path is empty')
			raise UMC_HTTPError(NOT_FOUND)

		return umcp.Request('GET', arguments=[path], options=args.get('options', {}))


class IPAddresses(object):

	@cherrypy.expose
	@log_exceptions
	def default(self, *a, **kw):
		try:
			addresses = self.addresses
		except ValueError:
			# hacking attempt
			addresses = [cherrypy.request.remote.ip]
		return json.dumps(addresses)

	@property
	def addresses(self):
		addresses = cherrypy.request.headers.get('X-FORWARDED-FOR', cherrypy.request.remote.ip).split(',') + [cherrypy.request.remote.ip]
		addresses = set(map(IPAddress, map(str.strip, addresses)))
		addresses.discard(IPAddress('::1'))
		addresses.discard(IPAddress('127.0.0.1'))
		return tuple(address.exploded for address in addresses)


class CPSet(CPgeneric):

	@log_exceptions
	def get_request(self, path, args):
		return umcp.Request('SET', options=args.get('options', {}))


class CPUpload(CPgeneric):

	@log_exceptions
	def get_request(self, path, args):
		self._log('info', 'Handle upload command')
		global _upload_manager
		req = umcp.Request('UPLOAD', arguments=[path])

		options = []
		body = {}

		# check if enough free space is available
		min_size = int(ucr.get('umc/server/upload/min_free_space', 51200))  # kilobyte
		s = os.statvfs(umcp.TEMPUPLOADDIR)
		free_disk_space = s.f_bavail * s.f_frsize / 1024  # kilobyte
		if free_disk_space < min_size:
			self._log('error', 'there is not enough free space to upload files')
			raise UMC_HTTPError(BAD_REQUEST, 'There is not enough free space on disk')

		for iid, ifield in args.iteritems():
			if isinstance(ifield, cherrypy._cpreqbody.Part):
				options.append(self._check_field_storage(req, iid, ifield))
			elif isinstance(ifield, list):
				# multiple files
				for jfield in ifield:
					if isinstance(jfield, cherrypy._cpreqbody.Part):
						options.append(self._check_field_storage(req, iid, jfield))
					else:
						CORE.warn('Unknown type of multipart/form-data entry: %r=%r' % (iid, jfield))
			elif isinstance(ifield, basestring):
				# field is a string :)
				body[iid] = ifield
			else:
				CORE.warn('Unknown type of multipart/form-data entry: %r=%r' % (iid, ifield))

		req.body = body
		req.body['options'] = options
		return req

	def _check_field_storage(self, req, iid, ifield):
		# field is a FieldStorage object
		store = ifield
		tmpfile = _upload_manager.add(req.id, store)

		# check if filesize is allowed
		st = os.stat(tmpfile)
		max_size = int(ucr.get('umc/server/upload/max', 64)) * 1024
		if st.st_size > max_size:
			self._log('warn', 'file of size %d could not be uploaded' % (st.st_size))
			raise UMC_HTTPError(BAD_REQUEST, 'The size of the uploaded file is too large')

		filename = store.filename
		# some security
		for c in ('<>/'):
			filename = filename.replace(c, '_')

		return {'filename': filename, 'name': store.name, 'tmpfile': tmpfile}

	@cherrypy.expose
	@log_exceptions
	def default(self, *path, **kwargs):
		self._log('info', 'got new request')

		# get the session id from the request
		sessionid = self.get_session_id()

		if not cherrypy.request.headers.get('Content-Type', '').startswith('multipart/form-data'):
			raise UMC_HTTPError(BAD_REQUEST, 'Content type and URL do not match')

		response = self.get_response(sessionid, path, kwargs)

		# check if the request is a iframe upload
		if 'iframe' in kwargs and (kwargs['iframe'] not in ('false', False, 0, '0')):
			# this is a workaround to make iframe uploads work, they need the textarea field
			cherrypy.response.headers['Content-Type'] = umcp.MIMETYPE_HTML
			return '<html><body><textarea>%s</textarea></body></html>' % (response)

		return response


class CPCommand(CPgeneric):

	@log_exceptions
	def get_request(self, path, args):
		if not path:
			self._log('error', 'get_request: path is empty')
			raise UMC_HTTPError(NOT_FOUND)

		req = umcp.Command([path], options=args.get('options', {}))
		if 'flavor' in args:
			req.flavor = args['flavor']

		return req


class CPAuth(CPgeneric):

	@cherrypy.expose
	@log_exceptions
	def sso(self, *args, **kwargs):
		remote = cherrypy.request.remote
		CORE.info('CPAuth/auth/sso: got new auth request (%s:%s <=> %s)' % (get_ip_address(), remote.port, remote.name))

		user = SAMLUser.get_user()
		if user is None or user.timed_out():
			SAMLUser.delete_cookie()
			raise HTTPRedirect('/umcp/saml/')

		req = umcp.Request('AUTH')
		req.body = {
			"auth_type": "SAML",
			"username": user.username,
			"password": user.message
		}

		try:
			response = self._auth_request(req)
		except UMC_HTTPError as exc:
			if exc.status == UNAUTHORIZED:
				SAMLUser.delete_cookie()
				raise HTTPRedirect('/umcp/saml/')  # FIXME: this might cause a endless redirection loop e.g. if slapd is down
			raise

		cherrypy.response.status = 303
		cherrypy.response.headers['Location'] = '/univention-management-console/'
		return response

	@cherrypy.expose
	@log_exceptions
	def default(self, **kw):
		remote = cherrypy.request.remote
		CORE.info('CPAuth/auth: got new auth request (%s:%s <=> %s)' % (get_ip_address(), remote.port, remote.name))

		content_length = cherrypy.request.headers.get("Content-Length")
		if not content_length and content_length != 0:
			CORE.process('CPRoot/auth: missing Content-Length header')
			raise UMC_HTTPError(LENGTH_REQUIRED)

		# get body and parse json
		body = ''
		if cherrypy.request.method in cherrypy.request.methods_with_bodies:
			max_length = 2000 * 1024
			if content_length <= max_length:  # prevent some DoS
				raise UMC_HTTPError(REQUEST_ENTITY_TOO_LARGE, 'Request data is too large, allowed length is %d' % max_length)
			body = cherrypy.request.body.read()

		data = self.load_json(body)

		CORE.info('CPRoot/command: request: command=%s' % cherrypy.request.path_info)

		# create new UMCP request
		req = umcp.Request('AUTH')
		req.body["auth_type"] = data['options'].get('auth_type')
		req.body['username'] = data['options'].get('username', '')
		req.body['password'] = data['options'].get('password', '')
		req.body['new_password'] = data['options'].get('new_password')
		return self._auth_request(req)

	def _auth_request(self, req):
		req.body['locale'] = (cherrypy.request.headers.values('Accept-Language') or ['C'])[0].replace('-', '_')

		# create new response queue
		response_queue = Queue.Queue()

		# send request to UMC server
		request = QueueRequest(None, req, response_queue, get_ip_address())
		UMCP_Dispatcher._queue_send.put(request)

		CORE.info('CPRoot/auth: pushed request to queue - waiting for response')
		response = response_queue.get()
		CORE.info('CPRoot/auth: got response with status %s' % response.status)

		if response.status == umcp.SUCCESS and response.body.get('sessionid'):
			sessionid = response.body.pop('sessionid')
			CORE.info('CPRoot/auth: creating session with sessionid=%s' % (sessionid,))

			self.set_cookies(sessionid=sessionid, username=req.body.get('username'))

			cherrypy.response.headers['Content-Type'] = response.mimetype
			if response.mimetype == 'application/json':
				return json.dumps(response.body)
			return response.body

		CORE.process('CPRoot/auth: username: %s, status code: %s' % (req.body.get('username'), response.status))
		raise UMC_HTTPError(response.status, response.message)


class CPRoot(object):

	@cherrypy.expose
	@log_exceptions
	def index(self, **kw):
		"""
		http://localhost:<ucr:umc/http/port>/
		"""
		raise HTTPRedirect('/univention-management-console/')


def get_ip_address():
	"""get the IP address of client by last entry (from apache) in X-FORWARDED-FOR header"""
	return cherrypy.request.headers.get('X-FORWARDED-FOR', cherrypy.request.remote.ip).rsplit(', ', 1).pop()


class SAML(object):

	def __init__(self):
		self.configfile = '/usr/share/univention-management-console/saml/sp.py'
		self.__sp = None
		self.seed = 'SnabbtInspel'  # FIXME: generate a secure random seed?

		self.idp_query_param = "IdpQuery"
		self.wayf = None
		self.discosrv = None
		self.bindings = [BINDING_HTTP_REDIRECT, BINDING_HTTP_POST, BINDING_HTTP_ARTIFACT]

		self.outstanding_queries = {}
		self.outstanding_certs = {}
		self.relay_state = {}
		self.user = {}
		try:
			self._reload_sp()
		except Exception:
			CORE.warn('Startup of SAML2.0 service provider failed:\n%s' % (traceback.format_exc(),))

	@property
	def sp(self):
		if not self.__sp:
			try:
				self._reload_sp()
			except Exception:
				raise UMC_HTTPError(500, 'Single sign on is not available due to misconfiguration. See logfiles.')
		return self.__sp

	def _reload_sp(self):
		self.__sp = Saml2Client(config_file=self.configfile)

	@cherrypy.expose
	@log_exceptions
	@cherrypy.tools.fix_uri()
	def metadata(self, *args, **kwargs):
		metadata = create_metadata_string(self.configfile, None, valid='4', cert=None, keyfile=None, mid=None, name=None, sign=False)
		cherrypy.response.headers['Content-Type'] = 'text/xml'
		return metadata

	@cherrypy.expose
	@log_exceptions
	@cherrypy.tools.fix_uri()
	def index(self, *args, **kwargs):
		user = SAMLUser.get_user()

		if user is None:
			message, binding, relay_state = self._get_saml_arguments()
			if message is None:
				return self.do_single_sign_on()
			return self.acs(message, binding, relay_state)

		raise HTTPRedirect('/umcp/auth/sso')
		cherrypy.response.headers['Content-Type'] = 'text/html'
		return '<a href="./logout">logout</a>'

	def acs(self, message, binding, relay_state):  # assertion consumer service
		try:
			response = self.sp.parse_authn_request_response(message, binding, self.outstanding_queries, self.outstanding_certs)
		except UnknownPrincipal as exc:
			raise UMC_HTTPError(500, "UnknownPrincipal: %s" % (exc,))
		except UnsupportedBinding as exc:
			raise UMC_HTTPError(500, "UnsupportedBinding: %s" % (exc,))
		except VerificationError as exc:
			raise UMC_HTTPError(500, "Verification error: %s" % (exc,))
		except UnsolicitedResponse as exc:  # e.g. UMC-webserver restart between IDP→SP authentication
			# TODO: redirect to SSO?
			raise UMC_HTTPError(500, 'Unsolicited response: %s' % (exc,))
		except StatusError as exc:
			CORE.error('Status error: %s' % (exc,))
			raise UMC_HTTPError(500, 'Status error: %s' % (exc,))
		except MissingKey as exc:
			raise UMC_HTTPError(500, 'Unknown issuer: %s' % (exc,))
		if response is None:
			raise UMC_HTTPError(400, "The SAML message is invalid for this service provider.")

		CORE.info('Got IDP response: %r' % (response.ava,))
		user = SAMLUser(response, message)
		SAMLUser.set_cookie(user)

		raise HTTPRedirect('/umcp/auth/sso')

	@cherrypy.expose
	@log_exceptions
	@cherrypy.tools.fix_uri()
	def slo(self, *args, **kwargs):  # single logout service
		message, binding, relay_state = self._get_saml_arguments()
		if message is None:
			raise UMC_HTTPError(400, 'The HTTP request is missing required SAML parameter.')
		self.sp.parse_logout_request_response(message, binding)
		return self._logout_success()

	@cherrypy.expose
	@log_exceptions
	@cherrypy.tools.fix_uri()
	def logout(self, *args, **kwargs):
		user = SAMLUser.get_user()

		if user is None:
			return self.do_single_sign_on()

		# What if more than one
		data = self.sp.global_logout(user.response.name_id)

		for entity_id, logout_info in data.items():
			if not isinstance(logout_info, tuple):
				continue  # result from logout, should be OK

			binding, http_args = logout_info

			if binding == BINDING_HTTP_POST:
				body = ''.join(http_args['data'])
				cherrypy.response.headers['Content-Type'] = 'text/html'
				return body
			elif binding == BINDING_HTTP_REDIRECT:
				for key, value in http_args['headers']:
					if key.lower() == 'location':
						raise HTTPRedirect(value, status=302)
				raise UMC_HTTPError(500, 'Cannot redirect due to missing Location header')
			else:
				raise UMC_HTTPError(500, 'unknown logout binding: %s', binding)
		return self._logout_success()

	def _logout_success(self):
		SAMLUser.delete_cookie()
		cherrypy.response.headers['Content-Type'] = 'text/html'
		return 'You are now logged out of this service. <a href="../">Relogin</a>'

	@cherrypy.expose
	@log_exceptions
	@cherrypy.tools.fix_uri()
	def disco(self, *args, **kwargs):
		try:
			sid = kwargs['sid']
			entity_id = kwargs['entityID']
		except KeyError as key:
			raise UMC_HTTPError(400, 'missing query string parameter: %s' % (key,))
		try:
			came_from = self.outstanding_queries[sid]
		except KeyError:
			raise UMC_HTTPError(400, 'unknown sid!')

		resp = self.redirect_to_auth(entity_id, came_from)

		# Add cookie
		key, value = make_cookie("ve_disco", entity_id, "SEED_SAW")  # TODO: find out why "SEED_SAW"
		cherrypy.response.headers[key] = value

		return resp

	def _get_saml_arguments(self):
		if cherrypy.request.method not in ('GET', 'POST'):
			cherrypy.response.headers['Allow'] = 'GET, HEAD, POST'
			raise UMC_HTTPError(405)

		if cherrypy.request.method == 'GET':
			binding = BINDING_HTTP_REDIRECT
			args = cherrypy.request.query
		elif cherrypy.request.method == "POST":
			binding = BINDING_HTTP_POST
			args = cherrypy.request.params

		relay_state = args.get('RelayState', '')
		try:
			message = args['SAMLResponse']
		except KeyError:
			try:
				message = args['SAMLRequest']
			except KeyError:
				try:
					message = args['SAMLart']
				except KeyError:
					return None, None, None
				message = self.sp.artifact2message(message, 'spsso')
				binding = BINDING_HTTP_ARTIFACT

		return message, binding, relay_state

	def do_single_sign_on(self):
		came_from = cherrypy.request.uri

		if 'Paos' in cherrypy.request.headers:
			done, response = self.enhanced_client_proxy_profile()
			if done > 0:
				self.outstanding_queries[done] = came_from
				cherrypy.response.headers['Content-Type'] = 'text/xml'
				return response
			identity_provider = response
		else:
			identity_provider = self._pick_idp(came_from)

		if identity_provider is None:
			raise UMC_HTTPError(500, 'Could not pick an identity provider. You can specify one via the query string parameter %r' % (self.idp_query_param,))

		return self.redirect_to_auth(identity_provider, came_from)

	def _pick_idp(self, came_from):
		idps = self._get_idps()

		if self.idp_query_param in cherrypy.request.query and cherrypy.request.query[self.idp_query_param] in idps:
			return cherrypy.request.query[self.idp_query_param]

		if cherrypy.request.cookie.get('ve_disco'):
			return parse_cookie("ve_disco", "SEED_SAW", cherrypy.request.headers.get('Cookie'))[0]

		if self.wayf:
			wayf_selected = cherrypy.request.query.get('wayf_selected')
			if not wayf_selected:
				sid = generate_sid()
				self.outstanding_queries[sid] = came_from
				raise HTTPRedirect("%s?sid=%s" % (self.wayf, sid), status=303)
			return wayf_selected

		if self.discosrv and cherrypy.request.query_string:
			idp_entity_id = self.sp.parse_discovery_service_response(query=cherrypy.request.query_string)
			if not idp_entity_id:
				sid_ = generate_sid()
				self.outstanding_queries[sid_] = came_from
				eid = self.sp.config.entityid
				ret = self.sp.config.getattr("endpoints", "sp")["discovery_response"][0][0]
				ret += "?sid=%s" % sid_
				loc = self.sp.create_discovery_service_request(self.discosrv, eid, **{"return": ret})
				raise HTTPRedirect(loc, status=303)
			return idp_entity_id

		if len(idps) == 1:
			return idps.keys()[0]

		for idp in idps:
			idp_ = urlparse(idp)
			host, port = idp_.netloc, idp_.port or {'https': 443, 'http': 80}[idp_.scheme]
			s = socket.socket()
			try:
				s.settimeout(1.0)
				s.connect((host, port))
				s.close()
			except IOError:
				continue
			return idp

	def _get_idps(self):
		idps = self.sp.metadata.with_descriptor("idpsso")
		if not idps:  # dynamic reload of IDP's
			try:
				self._reload_sp()
			except Exception:
				pass
			else:
				idps = self.sp.metadata.with_descriptor("idpsso")
		return idps

	def enhanced_client_proxy_profile(self):
		if cherrypy.request.headers['Paos'] != PAOS_HEADER_INFO:
			raise UMC_HTTPError(500, 'unknown ECP version')

		if 'application/vnd.paos+xml' not in cherrypy.request.headers.values('Accept'):
			raise UMC_HTTPError(406, 'application/vnd.paos+xml must be acceptable.')

		# Where should I redirect the user to
		# entityid -> the IdP to use
		# relay_state -> when back from authentication

		relay_state = rndstr()
		self.relay_state[relay_state] = cherrypy.request.uri
		_entityid = self.sp.config.ecp_endpoint(get_ip_address())

		if not _entityid:
			raise UMC_HTTPError(500, "Could not determine identity provider.")
		return ecp.ecp_auth_request(self.sp, _entityid, relay_state)

	def redirect_to_auth(self, entity_id, came_from, sigalg=""):
		binding, destination = self.sp.pick_binding("single_sign_on_service", self.bindings, "idpsso", entity_id=entity_id)
		acs = self.sp.config.getattr("endpoints", "sp")["assertion_consumer_service"]

		service_url, reply_binding = acs[0]
		for _url, _binding in acs:
			p1 = urlparse(_url)
			p2 = urlparse(came_from)
			if p1.scheme == p2.scheme and p1.netloc == p2.netloc:
				service_url, reply_binding = _url, _binding
				break
			elif p1.netloc == p2.netloc:
				service_url, reply_binding = _url, _binding

		extensions = None
		cert = None
		if self.sp.config.generate_cert_func is not None:
			cert_str, req_key_str = self.sp.config.generate_cert_func()
			cert = {
				"cert": cert_str,
				"key": req_key_str
			}
			spcertenc = SPCertEnc(x509_data=ds.X509Data(x509_certificate=ds.X509Certificate(text=cert_str)))
			extensions = Extensions(extension_elements=[element_to_extension_element(spcertenc)])

		sid, message = self.sp.create_authn_request(destination, binding=reply_binding, extensions=extensions, assertion_consumer_service_urls=(service_url,))

		relay_state = rndstr()
		self.relay_state[relay_state] = came_from

		http_args = self.sp.apply_binding(binding, message, destination, relay_state=relay_state, sigalg=sigalg)

		if cert is not None:
			self.outstanding_certs[sid] = cert
		self.outstanding_queries[sid] = came_from

		for key, value in http_args["headers"]:
			cherrypy.response.headers[key] = value

		body = ''.join(http_args["data"])
		if binding == BINDING_HTTP_ARTIFACT:
			raise HTTPRedirect(None, status=302)  # FIXME: hmm, no location header?
		elif binding == BINDING_HTTP_REDIRECT:
			if 'Location' not in cherrypy.response.headers:
				raise UMC_HTTPError(500, "Parameter error")
			cherrypy.response.status = 303
			if not body:
				raise HTTPRedirect(cherrypy.response.headers['Location'], status=303)

		return body


class SAMLUser(object):

	uid2user = {}
	cookie_name = "UMCSSOSessionId"

	def __init__(self, response, message):
		self.response = response
		self.message = message
		self.data = response.ava
		self.username = ''.join(self.data['uid'])

	def timed_out(self):
		if self.response.not_on_or_after == 0:
			return False
		return self.response.not_on_or_after - time.time() < 0

	@classmethod
	def get_user(cls):
		morsel = cherrypy.request.cookie.get(cls.cookie_name, None)
		if morsel:
			return cls.uid2user.get(morsel.value)

	@classmethod
	def delete_cookie(cls):
		cookie = cherrypy.response.cookie
		cookie[cls.cookie_name] = ""
		cookie[cls.cookie_name]['path'] = "/"  # FIXME?
		cookie[cls.cookie_name]["expires"] = cls._expiration()

	@classmethod
	def set_cookie(cls, user):
		uid = rndstr(32)
		cls.uid2user[uid] = user
		cookie = cherrypy.response.cookie
		cookie[cls.cookie_name] = uid
		cookie[cls.cookie_name]['path'] = "/"  # FIXME?
		cookie[cls.cookie_name]["expires"] = cls._expiration(int(user.response.not_on_or_after - time.time()))
		cookie['UMCUsername'] = user.username
		cookie['UMCUsername']['path'] = '/'  # FIXME

	@classmethod
	def _expiration(cls, timeout=None, tformat='%a, %d-%b-%Y %T GMT'):
		if timeout is None:  # now
			return time_util.instant(tformat)
		# validity time should match lifetime of assertions
		return time_util.in_a_while(minutes=timeout, format=tformat)


@log_exceptions
def run_cherrypy():
	# TODO FIXME Folgenden Configeintrag einbauen, wenn loglevel in (0,1,2)
	# 'server.environment': 'production',
	cherrypy.config.update({
		'server.socket_port': int(ucr.get('umc/http/port', 8090)),
		'server.socket_host': ucr.get('umc/http/interface', '127.0.0.1'),
		'server.request_queue_size': int(ucr.get('umc/http/requestqueuesize', 100)),
		'server.thread_pool': int(ucr.get('umc/http/maxthreads', 35)),
		'response.timeout': _session_timeout,
		'engine.autoreload_on': False,
		'tools.response_headers.on': True,
		'tools.response_headers.headers': [
			('Content-Type', umcp.MIMETYPE_JSON)
		],
		'error_page.default': default_error_page
	})
	cherrypy.tools.proxy(base=None, local='X-Forwarded-Host', remote='X-Forwarded-For', scheme='X-Forwarded-Proto')

	root = CPRoot()
	root.command = CPCommand()
	root.auth = CPAuth()
	root.get = CPGet()
	root.set = CPSet()
	root.upload = CPUpload()
	root.saml = SAML()
	root.get.ipaddress = IPAddresses()

	cherrypy.quickstart(root=root)


class UMC_HTTP_Daemon(DaemonRunner):

	def __init__(self):
		self.parser = OptionParser()
		self.parser.add_option('-n', '--no-daemon', action='store_false',
			dest='daemon_mode', default=True,
			help='if set the process will not fork into the background'
		)
		try:
			default_debug = int(ucr.get('umc/server/debug/level', '1'))
		except:
			default_debug = 1
		self.parser.add_option('-d', '--debug', action='store', type='int', dest='debug', default=default_debug,
			help='if given than debugging is activated and set to the specified level [default: %default]'
		)
		self.parser.add_option('-L', '--log-file', action='store', dest='logfile', default='management-console-web-server',
			help='specifies an alternative log file [default: %default]'
		)
		(self.options, self.arguments) = self.parser.parse_args()

		# cleanup environment
		os.environ.clear()
		os.environ['PATH'] = '/bin:/sbin:/usr/bin:/usr/sbin'

		# init logging
		if not self.options.daemon_mode:
			debug_fd = log_init('/dev/stderr', self.options.debug)
		else:
			debug_fd = log_init(self.options.logfile, self.options.debug)

		# default action: start
		if not self.arguments:
			sys.argv[1:] = ['start']
		elif self.arguments:
			sys.argv[1:] = self.arguments

		# for daemon runner
		if self.options.daemon_mode:
			self.stdin_path = os.path.devnull
			self.stdout_path = os.path.devnull
			self.stderr_path = os.path.devnull
		else:
			self.stdin_path = '/dev/stdin'
			self.stdout_path = '/dev/stdout'
			self.stderr_path = '/dev/stderr'
		self.pidfile_path = '/var/run/umc-web-server.pid'
		self.pidfile_timeout = 10

		# init daemon runner
		DaemonRunner.__init__(self, self)
		self.daemon_context.prevent_core = False
		self.daemon_context.detach_process = self.options.daemon_mode
		self.daemon_context.umask = 0077
		self.daemon_context.files_preserve = [debug_fd]

	def _restart(self):
		"""Handler for the restart action. """
		if self.pidfile.is_locked():
			CORE.process('Stopping UMC web server ...')
			self._stop()

		CORE.process('Starting UMC web server ...')
		self._start()

	def _crestart(self):
		"""Handler for the crestart action. """
		if not self.pidfile.is_locked():
			CORE.process('The UMC web server will not be restarted as it is not running currently')
			return

		CORE.process('Stopping UMC web server ...')
		self._stop()
		CORE.process('Starting UMC web server ...')
		self._start()

	DaemonRunner.action_funcs['restart'] = _restart
	DaemonRunner.action_funcs['crestart'] = _crestart

	def _terminate_daemon_process(self):
		""" Terminate the daemon process specified in the current PID file.
				"""
		pid = self.pidfile.read_pid()
		try:
			os.kill(pid, signal.SIGTERM)
		except OSError as exc:
			raise DaemonRunnerStopFailureError("Failed to terminate %d: %s" % (pid, exc))

		if self.pidfile.is_locked():
			CORE.process('The UMC web server is still running. Will wait for 5 seconds')
			count = 10
			while count:
				time.sleep(0.5)
				if not self.pidfile.is_locked():
					break
				count -= 1
			if self.pidfile.is_locked():
				CORE.process('The UMC web server is still running. Kill it!')
				os.kill(pid, signal.SIGKILL)
				self.pidfile.break_lock()

	def _usage_exit(self, argv):
		self.parser.error('invalid action')
		sys.exit(1)

	def run(self):
		# cherrypy runs in a thread. signals can only be registered in the main thread
		# to prevent race conditions this must be called before the cherrypy thread gets created
		cherrypy.engine.signal_handler.handlers['SIGHUP'] = log_reopen
		cherrypy.engine.signal_handler.subscribe()
		cherrypy.engine.subscribe('exit', lambda: notifier.dispatcher_add(lambda: sys.exit(0)))

		# start webserver as separate thread
		_thread_http = threading.Thread(target=run_cherrypy)
		_thread_http.deamon = True
		_thread_http.start()

		try:
			# start notifier loop
			notifier.init(notifier.GENERIC)
			notifier.dispatcher_add(UMCP_Dispatcher.check_queue)
			notifier.loop()
		except (SystemExit, KeyboardInterrupt) as e:
			# stop the web server
			CORE.info('stopping cherrypy: %s' % str(e))
			cherrypy.engine.exit()
			CORE.info('cherrypy stopped')


if __name__ == '__main__':
	http_daemon = UMC_HTTP_Daemon()
	try:
		http_daemon.do_action()
	except DaemonRunnerStopFailureError as e:
		CORE.process('Failed to shutdown server gracefully (may be its already dead): %s' % str(e))
	except DaemonRunnerStartFailureError as e:
		CORE.process('Failed to start server: %s' % str(e))
