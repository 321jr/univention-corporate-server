#!/usr/bin/python2.6
# -*- coding: utf-8 -*-
#
# Univention Management Console
#
# Copyright 2006-2011 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.

from optparse import OptionParser
from getpass import getpass

import os, readline, socket, sys

import notifier
import notifier.threads as threads

import univention.management.console.protocol as umcp
from univention.management.console.log import CORE, log_init, log_set_level

def _completer( text, state ):
	result = []
	text = text.upper()
	for cmd in umcp.COMMANDS:
		if cmd.name.startswith( text ):
			result.append( cmd.name )

	if len( result ) > state:
		return result[ state ]
	else:
		return None

def _options( text, state ):
	print readline.input_buffer().split( ' ' )

def _readline():
	readline.set_completer( _completer )

	while True:
		command = raw_input( ' > ' )
		if umcp.command_is_known( command ):
			break
		elif command == 'HELP':
			return ( command, None, None, None )
		else:
			CORE.error( 'The entered command is unknown: %s' % command )

	readline.set_completer( None )
	arguments = []
	if umcp.command_has_arguments( command ):
		while True:
			arg = raw_input( ' argument: ' )
			if arg:
				arguments.append( arg )
			else:
				break

	options = []
	if umcp.command_has_options( command ):
		while True:
			opt = raw_input( ' option: ' )
			if opt:
				if len( opt.split( '=' ) ) != 2:
					CORE.error( 'The specified option has an invalid format: <option>=<value>' )
				else:
					options.append( opt )
			else:
				break

	return ( command, arguments, options )

class CLI_Client( umcp.Client ):
	def __init__( self, options = [], arguments = [] ):
		if options.unix_socket and os.path.exists( options.unix_socket ):
			umcp.Client.__init__( self, unix = options.unix_socket,
								  ssl = False, auth = options.authenticate )
		else:
			umcp.Client.__init__( self, servername = options.server,
								  port = options.port,
								  auth = options.authenticate )
		self.__wait = None
		self.__input = ''
		self.__timer = None
		self.__interactive = options.interactive

		try:
			self.connect()
		except umcp.NoSocketError:
			CORE.error( "The UMC server %s could not be contacted." % options.server )
			sys.exit( 1 )
		else:
			CORE.info( "The connection to '%s' is established" % options.server )

		self.signal_connect( 'response', self._response )
		self.signal_connect( 'authenticated', self._authenticated )
		self.signal_connect( 'closed', self._closed )
		if arguments:
			self.__wait = self.create( arguments[ 0 ], arguments[ 1 : ], options )
		if options.authenticate:
			self.authenticate( options.username, options.password )
		else:
			if self.__wait:
				self.request( self.__wait )
				self.__wait = None
			elif self.__interactive:
				readline.parse_and_bind( 'tab: complete' )
				rl = threads.Simple( 'readline', _readline, self._input )
				rl.run()

	def create( self, command, args = [], options = [], flavor = None ):
		msg = umcp.Request( command.upper() )
		msg.arguments = args
		if options.flavor is not None:
			msg.flavor = options.flavor
		if options.list_options:
			msg.options = options.options
		else:
			for opt in options.options:
				key, value = opt.split( '=', 1 )
				if key.find( ':' ) > 0:
					typ, key = key.split( ':', 1 )
					try:
						value = eval( "%s('%s')" % ( typ, value ) )
					except NameError:
						CORE.error( "Invalid type for option: %s" % typ )
				msg.options[ key ] = value
		return msg

	def _closed( self ):
		CORE.error( 'The server closed the connection' )
		if self.__timer:
			notifier.timer_remove( self.__timer )
		sys.exit( 0 )

	def _authenticated( self, success, status, text ):
		if success:
			CORE.info( 'authentication successful' )
			if self.__wait:
				self.request( self.__wait )
				self.__wait = None
				return
			if self.__interactive:
				readline.parse_and_bind( 'tab: complete' )
				rl = threads.Simple( 'readline', _readline, self._input )
				rl.run()
		else:
			raise Exception( 'error: authentication failed' )

	def _waiting_for_response( self ):
		sys.stdout.write( '.' )
		sys.stdout.flush()
		return True

	def _input( self, name, output ):
		req = self.create( *output )
		self.request( req )
		CORE.info( "waiting for response to '%s' " % req.command )
		self.__timer = notifier.timer_add( 1000, self._waiting_for_response )

	def _response( self, msg ):
		notifier.timer_remove( self.__timer )
		self.__timer = None
		if self.__interactive:
			CORE.info( ' found' )
		CORE.info( 'The server replied: %s' % msg.command )
		if msg.arguments:
			CORE.info( '  ARGUMENTS: %s' % ' '.join( msg.arguments ) )
		CORE.info( '  STATUS   : %d' % msg.status )
		if msg.options:
			if isinstance( msg.options, ( list, tuple ) ):
				CORE.info( '  OPTIONS  : %s' % ', '.join( msg.options ) )
			else:
				CORE.info( '  OPTIONS  : %s' % ' '.join( [ '%s=%s' % ( k, v ) for k, v in msg.options.items() ] ) )
		CORE.info( '  MESSAGE  : %s' % msg.message )
		CORE.info( '  RESULT   : %s' % msg.result )
		CORE.info( '  data length   : %4d' % len( str( msg ) ) )
		CORE.info( '  message length: %4d' % msg._length )
		CORE.info( '  complete body : %s' % msg.body )
		if self.__interactive:
			readline.parse_and_bind( 'tab: complete' )
			rl = threads.Simple( 'readline', _readline, self._input )
			rl.run()
		else:
			sys.exit( 0 )

if __name__ == '__main__':
	notifier.init( notifier.GENERIC )

	parser = OptionParser( usage = "usage: %prog [options] command <arguments>" )
	parser.add_option( '-i', '--interactive', action = 'store_true',
					   dest = 'interactive',
					   help = 'provides a shell-like interactive interface' )
	parser.add_option( '-n', '--no-auth', action = 'store_false',
					   dest = 'authenticate', default = True,
					   help = 'if given the client do not try to authenticate first' )
	parser.add_option( '-s', '--server', type = 'string', action = 'store',
					   dest = 'server', default = 'localhost',
					   help = 'defines the host of the UMC daemon to connect to' )
	parser.add_option( '-f', '--flavor', action = 'store',
					   dest = 'flavor', default = None,
					   help = 'set the required flavor' )
	parser.add_option( '-p', '--port', type = 'int', action = 'store',
					   dest = 'port', default = '6670',
					   help = 'defines the port to connect to' )
	parser.add_option( '-u', '--unix-socket', type = 'string', action = 'store',
					   dest = 'unix_socket',
					   help = 'defines the filename of the UNIX socket' )
	parser.add_option( '-U', '--username', type = 'string',
					   action = 'store', dest = 'username',
					   help = 'set username for authentication' )
	parser.add_option( '-P', '--password', type = 'string',
					   action = 'store', dest = 'password',
					   help = 'set password for authentication' )
	parser.add_option( '-o', '--option', type = 'string', default = [],
					   action = 'append', dest = 'options',
					   help = 'append an option to the request' )
	parser.add_option( '-l', '--list-options', action = 'store_true',
					   dest = 'list_options',
					   help = 'if set all specified options will be assembled in a list' )
	parser.add_option( '-d', '--debug', action = 'store', type = 'int',
					   dest = 'debug', default = 4,
					   help = 'if given than debugging is activated and set to the specified level' )

	( options, arguments ) = parser.parse_args()

	log_init( '/dev/stderr', options.debug )

	if not options.interactive and not arguments:
		parser.error( 'command is missing' )
	if options.authenticate:
		if not options.username:
			options.username = raw_input( 'Username:' )
		if not options.password:
			options.password = getpass( 'Password:' )
	try:
		client = CLI_Client( options, arguments )
	except Exception, e:
		CORE.error( 'An fatal error occurred: %s' % str( e ) )
		sys.exit( 1 )

	notifier.loop()
