#!/usr/bin/python2.6
#
#
# Univention Management Console
#  UMC web server
#
# Copyright 2011 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.

import cherrypy
import threading
import notifier
import Queue
import univention.management.console.protocol as umcp
import univention.debug as ud
import simplejson

_thread_http = None
_sessionclients = {}
_queue_send = Queue.Queue()

_sessionidcounter = 1


# Traceback (most recent call last):
#   File "./umc2-webserver.py", line 507, in ?
#     main()
#   File "./umc2-webserver.py", line 503, in main
#     notifier.loop()
#   File "/usr/lib/python2.4/site-packages/notifier/nf_generic.py", line 272, in loop
#     step()
#   File "/usr/lib/python2.4/site-packages/notifier/nf_generic.py", line 264, in step
#     __min_timer = dispatch.dispatcher_run()
#   File "/usr/lib/python2.4/site-packages/notifier/dispatch.py", line 71, in dispatcher_run
#     if not disp():
#   File "./umc2-webserver.py", line 116, in check_queue
#     client.send_request( queuerequest.request, queuerequest.response_queue )
#   File "./umc2-webserver.py", line 61, in send_request
#     self.client.request( request )
#   File "/usr/lib/python2.4/site-packages/univention/management/console/protocol/client.py", line 228, in request
#     if self._resend( sock ):
#   File "/usr/lib/python2.4/site-packages/univention/management/console/protocol/client.py", line 199, in _resend
#     self.__realsocket.shutdown( socket.SHUT_RDWR )
#   File "<string>", line 1, in shutdown
#   File "/usr/lib/python2.4/socket.py", line 136, in _dummy
#     raise error(EBADF, 'Bad file descriptor')
# socket.error: (9, 'Bad file descriptor')


class SessionClient(object):
	def __init__(self):
		ud.debug(ud.ADMIN, ud.INFO, 'SessionClient: creating new session')
		self.client = umcp.Client()
		self.client.signal_connect( 'authenticated', self._authenticated )
		self.client.signal_connect( 'response', self._response )
		self.client.signal_connect( 'closed', self._closed )
		if self.client.connect():
			ud.debug(ud.ADMIN, ud.INFO, 'SessionClient: connected to UMC server')
		else:
			ud.debug(ud.ADMIN, ud.ERROR, 'SessionClient: connection to UMC server failed')
		self._auth_response = None
		self._auth_response_queue = None
		self._requestid2response_queue = {}

	def _authenticated(self, success, status, message):
		ud.debug(ud.ADMIN, ud.ERROR, 'SessionClient: _authenticated: success=%s  status=%s  message=%s' % (success, status, message) )
		self._auth_response.status = status
		self._auth_response_queue.put( self._auth_response )
		# release queue object
		self._auth_response_queue = None

	def authenticate_user(self, request, response_queue):
		ud.debug(ud.ADMIN, ud.INFO, 'SessionClient: authenticate_user: sending authentication request for user %s' % request.body[ 'username' ])
		self._auth_response = umcp.Response( request )
		self._auth_response.body['sessionid'] = request.body.get('sessionid','')
		self._auth_response_queue = response_queue
		self.client.authenticate( request.body[ 'username' ], request.body[ 'password' ] )

	def _closed(self):
		ud.debug(ud.ADMIN, ud.ERROR, 'SessionClient: lost connection to UMC server')

	def _response(self, response):
		if not response.id() in self._requestid2response_queue:
			ud.debug(ud.ADMIN, ud.ERROR, 'SessionClient: could not find request id for response %s, status %d:' % ( str( response.id() ), response.status ) )
		else:
			ud.debug(ud.ADMIN, ud.INFO, 'SessionClient: got response with id=%s and status=%s' % ( response.id(), response.status ) )
			self._requestid2response_queue[ response.id() ].put( response )
			# remove response_queue from internal mapping
			self.cleanup_request( response )

	def send_request(self, request, response_queue):
		ud.debug(ud.ADMIN, ud.INFO, 'SessionClient: sending request with id=%s' % request.id())
		self._requestid2response_queue[request.id()] = response_queue
		self.client.request( request )

	def cleanup_request(self, request):
		del self._requestid2response_queue[request.id()]


class UMCP_Dispatcher(object):
	def __init__(self):
		pass

	def check_queue(self):
		global _sessionclients, _sessionidcounter, _queue_send
		while _queue_send.qsize():
			ud.debug(ud.ADMIN, ud.INFO, 'UMCP_Dispatcher: check_queue: new object in queue')
			try:
				queuerequest = _queue_send.get_nowait()
			except Queue.Empty:
				# Queue is empty - nothing to do
				return

			if not type(queuerequest.sessionid) == str and not queuerequest.sessionid == None:
				ud.debug(ud.ADMIN, ud.ERROR, 'UMCP_Dispatcher: check_queue: got invalid sessionid: %s' % repr(queuerequest.sessionid))
			if not isinstance(queuerequest.request, umcp.Request):
				ud.debug(ud.ADMIN, ud.ERROR, 'UMCP_Dispatcher: check_queue: got invalid UMCP request: %s' % repr(queuerequest.request))
			if not isinstance(queuerequest.response_queue, Queue.Queue):
				ud.debug(ud.ADMIN, ud.ERROR, 'UMCP_Dispatcher: check_queue: got invalid response_queue: %s' % repr(queuerequest.response_queue))

			# stop here if sessionid is missing or unknown and request is no AUTH request
			if ( not queuerequest.sessionid or not queuerequest.sessionid in _sessionclients.keys() ) and not queuerequest.request.command == 'AUTH':
				ud.debug(ud.ADMIN, ud.ERROR, 'UMCP_Dispatcher: check_queue: invalid session: sessionid=%s' % repr(queuerequest.sessionid))
				response = umcp.Response( queuerequest.request )
				response.status = 401 # set status to unauthorized
				queuerequest.response_queue.put( response )
				return True

			if queuerequest.request.command == 'AUTH':
				# AUTH request
				ud.debug(ud.ADMIN, ud.INFO, 'UMCP_Dispatcher: check_queue: AUTH request')
				if not queuerequest.sessionid:
					ud.debug(ud.ADMIN, ud.INFO, 'UMCP_Dispatcher: check_queue: creating new sessionid')
					# FIXME: create nice session id via uuid or something else
					queuerequest.sessionid = '%d' % _sessionidcounter
					_sessionidcounter += 1
				# create new session / umcp client
				_sessionclients[ queuerequest.sessionid ] = SessionClient()
				client = _sessionclients.get(queuerequest.sessionid)

				# save new sessionid in UMCP request so it can be returned after authentication
				queuerequest.request.body['sessionid'] = queuerequest.sessionid
				client.authenticate_user( queuerequest.request, queuerequest.response_queue )
			else:
				# COMMAND / GET / SET request
				ud.debug(ud.ADMIN, ud.INFO, 'UMCP_Dispatcher: check_queue: normal request')
				client = _sessionclients.get(queuerequest.sessionid)
				try:
					client.send_request( queuerequest.request, queuerequest.response_queue )
				except umcp.client.NotAuthenticatedError:
					response = umcp.Response( queuerequest.request )
					response.status = 401 # set status to unauthorized
					queuerequest.response_queue.put( response )
					# remove response_queue from internal mapping
					client.cleanup_request( queuerequest.request )

		return True


class QueueRequest(object):
	def __init__(self, sessionid, request, response_queue):
		self.sessionid = sessionid
		self.request = request
		self.response_queue = response_queue

def update_session_cookie(cookiejar, sessionid):
	cookiejar['UMCSessionId'] = sessionid
	cookiejar['UMCSessionId']['max-age'] = 180
	cookiejar['UMCSessionId']['version'] = 1
	cookiejar['UMCSessionId']['path'] = '/'
	# TODO FIXME set session timeout via UCR variable


class CPgeneric(object):
	name = 'CPgeneric'

	def _log(self, loglevel, msg):
		remote = cherrypy.request.remote
		ud.debug(ud.ADMIN, loglevel, '%s (%s:%s) %s' % (self.name,  remote.ip, remote.port, msg))

	def get_request(self, request, json):
		req = umcp.Request( [ 'generic' ], opts = {} )
		return req

	@cherrypy.expose
	def default(self, *args):
		global _queue_send
		remote = cherrypy.request.remote
		self._log(ud.INFO, 'got new request')

		cookie = cherrypy.request.cookie
		if cookie.get('UMCSessionId'):
			sessionid = cookie['UMCSessionId'].value
			self._log(ud.INFO, 'found sessionid')
			self._log(99, 'sessionid="%s"' % (sessionid))
		else:
			# a sessionid is required to use this command
			self._log(ud.INFO, 'no sessionid found')
			raise cherrypy.HTTPError(401)

		if not cherrypy.request.headers.get(u"Content-Length", u""):
			json = ''
			self._log(ud.WARN, 'missing Content-Length header')
		else:
			# get body and parse json
			body = ''
			if cherrypy.request.body:
				body = cherrypy.request.body.read()

			try:
				json = simplejson.loads(body)
			except ValueError:
				self._log(ud.ERROR, 'cannot parse JSON body')
				raise cherrypy.HTTPError(400, 'Invalid JSON document')

		# create new UMCP request
		req = self.get_request( cherrypy.request, json )

		# create new response queue
		response_queue = Queue.Queue()

		# send request to UMC server
		request = QueueRequest(sessionid, req, response_queue)
		_queue_send.put(request)

		self._log(ud.INFO, 'pushed request %s to queue - waiting for response (sessionid="%s")' % (req.id(), sessionid))
		response = response_queue.get()
		self._log(ud.INFO, 'got response %s with status %s (sessionid="%s")' % (response.id(), response.status, sessionid))

		if response.status == 200:
			update_session_cookie(cherrypy.response.cookie, sessionid)
			return simplejson.dumps(response.body)

		elif response.status in (401,403,404):
			# user is unauthorized
			raise cherrypy.HTTPError(response.status)

		# something bad happened
		self._log(ud.ERROR, 'unhandled response status code: %s' % response.status)
		raise cherrypy.HTTPError(500)


class CPGet(CPgeneric):
	name = 'CPGet'
	requestprefix = '/get'

	def get_request(self, request, json):
		args = request.path_info

		if args.startswith( self.requestprefix ):
			args = args[ len(self.requestprefix)+1 : ]

		if not args:
			self._log(ud.ERROR, 'get_request: args is empty')
			raise cherrypy.HTTPError(404)

		req = umcp.Request( 'GET', args = [ args ] )

		return req


class CPSet(CPgeneric):
	name = 'CPSet'
	requestprefix = '/set'

	def get_request(self, request, json):
		args = request.path_info

		if args.startswith( self.requestprefix ):
			args = args[ len(self.requestprefix)+1 : ]

		if not args:
			self._log(ud.ERROR, 'get_request: args is empty')
			raise cherrypy.HTTPError(404)

		req = umcp.Request( 'SET', args = [ args ] )

		return req


class CPCommand(CPgeneric):
	name = 'CPCommand'
	requestprefix = '/command'

	def get_request(self, request, json):
		args = request.path_info

		if args.startswith( self.requestprefix ):
			args = args[ len(self.requestprefix)+1 : ]

		if not args:
			self._log(ud.ERROR, 'get_request: args is empty')
			raise cherrypy.HTTPError(404)

		req = umcp.Command( [ args ], opts = json )

		return req


# class CPCommand(object):
# 	@cherrypy.expose
# 	def default(self, *args):
# 		global _queue_send
# 		remote = cherrypy.request.remote
# 		ud.debug(ud.ADMIN, ud.INFO, 'CPRoot/command: got new request (%s:%s <=> %s)' % (remote.ip, remote.port, remote.name))

# 		cookie = cherrypy.request.cookie
# 		if cookie.get('UMCSessionId'):
# 			sessionid = cookie['UMCSessionId'].value
# 			ud.debug(ud.ADMIN, ud.INFO, 'CPRoot/command: sessionid="%s"' % (sessionid))
# 		else:
# 			# a sessionid is required to use this command
# 			ud.debug(ud.ADMIN, ud.INFO, 'CPRoot/command: no sessionid found')
# 			raise cherrypy.HTTPError(401)

# 		if not cherrypy.request.headers.get(u"Content-Length", u""):
# 			ud.debug(ud.ADMIN, ud.ERROR, 'CPRoot/command: missing Content-Length header')
# 			raise cherrypy.HTTPError(411)

# 		# get body and parse json
# 		body = ''
# 		if cherrypy.request.body:
# 			body = cherrypy.request.body.read()

# 		try:
# 			json = simplejson.loads(body)
# 		except ValueError:
# 			ud.debug(ud.ADMIN, ud.ERROR, 'CPRoot/auth: cannot parse JSON body')
# 			raise cherrypy.HTTPError(400, 'Invalid JSON document')

# 		command = cherrypy.request.path_info
# 		if command.startswith('/command'):
# 			command = command[9:]
# 		ud.debug(ud.ADMIN, ud.INFO, 'CPRoot/command: request: command=%s' % command )
# 		ud.debug(ud.ADMIN, ud.INFO, 'CPRoot/command: json=%s' % json)

# 		if not command:
# 			ud.debug(ud.ADMIN, ud.ERROR, 'CPRoot/command: request: command is empty')
# 			raise cherrypy.HTTPError(404)

# 		# create new UMCP request
# 		req = umcp.Command( [ command ], opts = json )

# 		# create new response queue
# 		response_queue = Queue.Queue()

# 		# send request to UMC server
# 		request = QueueRequest(sessionid, req, response_queue)
# 		_queue_send.put(request)

# 		ud.debug(ud.ADMIN, ud.INFO, 'CPRoot/command: pushed request %s to queue - waiting for response (sessionid="%s")' % (request.id(), sessionid))
# 		response = response_queue.get()
# 		ud.debug(ud.ADMIN, ud.INFO, 'CPRoot/command: got response %s with status %s (sessionid="%s")' % (response.id(), response.status, sessionid))

# 		if response.status == 200:
# 			update_session_cookie(cherrypy.response.cookie, sessionid)
# 			return "I got my response: %s<br>\n%s" % (response.status, response)

# 		elif response.status == 410:
# 			# user is unauthorized
# 			raise cherrypy.HTTPError(401)

# 		elif response.status == 401:
# 			# unknown command
# 			ud.debug(ud.ADMIN, ud.ERROR, 'CPRoot/command: unknown command: %s (response.status=%s)' % (command, response.status))
# 			raise cherrypy.HTTPError(404)

# 		# something bad happened
# 		ud.debug(ud.ADMIN, ud.ERROR, 'CPRoot/command: unhandled response status: %s' % response.status)
# 		raise cherrypy.HTTPError(500)


class CPAuth(object):
	@cherrypy.expose
	def default(self):
		global _queue_send
		remote = cherrypy.request.remote
		ud.debug(ud.ADMIN, ud.INFO, 'CPRoot/auth: got new auth request (%s:%s <=> %s)' % (remote.ip, remote.port, remote.name))

		if not cherrypy.request.headers.get(u"Content-Length", u""):
			ud.debug(ud.ADMIN, ud.ERROR, 'CPRoot/auth: missing Content-Length header')
			raise cherrypy.HTTPError(411)

		# TODO FIXME check body length and stop here if too much data has been sent by client

		# get body and parse json
		body = ''
		if cherrypy.request.body:
			body = cherrypy.request.body.read()

		try:
			json = simplejson.loads(body)
		except ValueError:
			ud.debug(ud.ADMIN, ud.ERROR, 'CPRoot/auth: cannot parse JSON body')
			raise cherrypy.HTTPError(400, 'Invalid JSON document')

		ud.debug(ud.ADMIN, ud.INFO, 'CPRoot/command: request: command=%s' % cherrypy.request.path_info )
		ud.debug(ud.ADMIN, ud.INFO, 'CPRoot/command: json=%s' % json)

		# create new UMCP request
		req = umcp.Request( 'AUTH' )
		req.body[ 'username' ] = json.get('username','')
		req.body[ 'password' ] = json.get('password','')

		# create new response queue
		response_queue = Queue.Queue()

		# send request to UMC server
		request = QueueRequest(None, req, response_queue)
		_queue_send.put(request)

		ud.debug(ud.ADMIN, ud.INFO, 'CPRoot/auth: pushed request to queue - waiting for response')
		response = response_queue.get()
		ud.debug(ud.ADMIN, ud.INFO, 'CPRoot/auth: got response with status %s' % response.status)

		if response.status == 200 and response.body.get('sessionid'):
			ud.debug(ud.ADMIN, ud.INFO, 'CPRoot/auth: creating cookie with sessionid=%s' % response.body.get('sessionid'))
			update_session_cookie(cherrypy.response.cookie, response.body['sessionid'])
			return ""

		elif response.status in (401,410):
			ud.debug(ud.ADMIN, ud.ERROR, 'CPRoot/auth: authorization for %s failed' % json.get('username'))
			raise cherrypy.HTTPError(401)

		ud.debug(ud.ADMIN, ud.ERROR, 'CPRoot/auth: unhandled status code: %s' % response.status)
		raise cherrypy.HTTPError(500)


# class CPGet(object):
# 	@cherrypy.expose
# 	def default(self, *args):
# 		global _queue_send
# 		remote = cherrypy.request.remote
# 		ud.debug(ud.ADMIN, ud.INFO, 'CPRoot/get: got new request (%s:%s <=> %s)' % (remote.ip, remote.port, remote.name))

# 		cookie = cherrypy.request.cookie
# 		if cookie.get('UMCSessionId'):
# 			sessionid = cookie['UMCSessionId'].value
# 			ud.debug(ud.ADMIN, ud.INFO, 'CPRoot/get: sessionid="%s"' % (sessionid))
# 		else:
# 			# a sessionid is required to use this command
# 			ud.debug(ud.ADMIN, ud.INFO, 'CPRoot/get: no sessionid found')
# 			raise cherrypy.HTTPError(401)

# 		if not cherrypy.request.headers.get(u"Content-Length", u""):
# 			ud.debug(ud.ADMIN, ud.ERROR, 'CPRoot/get: missing Content-Length header')
# 			raise cherrypy.HTTPError(411)

# 		# get body and parse json
# 		body = ''
# 		if cherrypy.request.body:
# 			body = cherrypy.request.body.read()

# 		try:
# 			json = simplejson.loads(body)
# 		except ValueError:
# 			ud.debug(ud.ADMIN, ud.ERROR, 'CPRoot/auth: cannot parse JSON body')
# 			raise cherrypy.HTTPError(400, 'Invalid JSON document')

# 		command = cherrypy.request.path_info
# 		if command.startswith('/get'):
# 			command = command[9:]
# 		ud.debug(ud.ADMIN, ud.INFO, 'CPRoot/get: request: command=%s' % command )
# 		ud.debug(ud.ADMIN, ud.INFO, 'CPRoot/get: json=%s' % json)

# 		if not command:
# 			ud.debug(ud.ADMIN, ud.ERROR, 'CPRoot/get: request: command is empty')
# 			raise cherrypy.HTTPError(404)

# 		# create new UMCP request
# 		req = umcp.Request( 'GET', args = [ command ] )

# 		# create new response queue
# 		response_queue = Queue.Queue()

# 		# send request to UMC server
# 		request = QueueRequest(sessionid, req, response_queue)
# 		_queue_send.put(request)

# 		ud.debug(ud.ADMIN, ud.INFO, 'CPRoot/get: pushed request %s to queue - waiting for response (sessionid="%s")' % (request.id(), sessionid))
# 		response = response_queue.get()
# 		ud.debug(ud.ADMIN, ud.INFO, 'CPRoot/get: got response %s with status %s (sessionid="%s")' % (response.id(), response.status, sessionid))

# 		if response.status == 200:
# 			update_session_cookie(cherrypy.response.cookie, sessionid)
# 			return "I got my response: %s<br>\n%s" % (response.status, response)

# 		elif response.status == 410:
# 			# user is unauthorized
# 			raise cherrypy.HTTPError(401)

# 		elif response.status == 401:
# 			# unknown command
# 			ud.debug(ud.ADMIN, ud.ERROR, 'CPRoot/get: unknown command: %s (response.status=%s)' % (command, response.status))
# 			raise cherrypy.HTTPError(404)

# 		# something bad happened
# 		ud.debug(ud.ADMIN, ud.ERROR, 'CPRoot/get: unhandled response status: %s' % response.status)
# 		raise cherrypy.HTTPError(500)


class CPRoot(object):
	def index(self):
		"""
		http://localhost:8080/
		"""
		raise cherrypy.HTTPError(404)
	index.exposed = True


def run_cherrypy():
	# TODO FIXME Folgenden Configeintrag einbauen, wenn loglevel in (0,1,2)
	# 'server.environment': 'production',
	cherrypy.config.update( { 'server.socket_port': 8080,
							  'server.socket_host': '0.0.0.0',
							  'engine.autoreload_on': False,
							  } )
	cherrypy.tools.proxy(base=None, local='X-Forwarded-Host', remote='X-Forwarded-For', scheme='X-Forwarded-Proto')

	root = CPRoot()
	root.command = CPCommand()
	root.auth = CPAuth()
	root.get = CPGet()
	cherrypy.quickstart(root=root)


def main():
	ud.init('umc2-webserver.log', 1, 1)
	ud.set_level( ud.LDAP, 4 )
	ud.set_level( ud.ADMIN, 4 )
	# start webserver
	_thread_http = threading.Thread( target = run_cherrypy )
	_thread_http.start()
	# start notifier loop
	umcp_dispatcher = UMCP_Dispatcher()
	notifier.init( notifier.GENERIC )
	ud.debug(ud.ADMIN, ud.ERROR, 'FIXME: run check_queue in timer with shorter timeout to get called more often than 10 times per second')
	notifier.dispatcher_add( umcp_dispatcher.check_queue )
	notifier.loop()


if __name__ == '__main__':
	main()
