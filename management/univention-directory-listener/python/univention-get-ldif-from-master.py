#!/usr/bin/python2.7
# -*- coding: utf-8 -*-
#
# Univention Directory Listener
"""Read ldap from the DC master and create ldif file (and update local schema)"""
#
# Copyright 2004-2018 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.

from __future__ import print_function
import univention.uldap as uldap
import univention.config_registry

import ldap
import ldif
import sys
import os
import optparse
import gzip

from ldap.controls import SimplePagedResultsControl

sys.path.append("/usr/lib/univention-directory-listener/system/")
import replication

LDIF = '/var/lib/univention-directory-listener/master.ldif'
SCHEMA = '/var/lib/univention-ldap/schema.conf'


# from replication.py
def _update_schema(attr):
	tmp = SCHEMA + '.new'
	with open(tmp, 'w') as fp:
		fp.write('# This schema was automatically replicated from the master server\n')
		fp.write('# Please do not edit this file\n\n')
		subschema = ldap.schema.SubSchema(attr)
		replication.BUILTIN_OIDS.append('1.3.6.1.4.1.4203.666.11.1.4.2.12.1')
		for oid in replication.subschema_sort(subschema, ldap.schema.AttributeType):
			if oid in replication.BUILTIN_OIDS:
				continue
			obj = subschema.get_obj(ldap.schema.AttributeType, oid)
			fp.write('attributetype %s\n' % (obj,))
		for oid in replication.subschema_sort(subschema, ldap.schema.ObjectClass):
			if oid in replication.BUILTIN_OIDS:
				continue
			obj = subschema.get_obj(ldap.schema.ObjectClass, oid)
			fp.write('objectclass %s\n' % (obj,))
	os.rename(tmp, SCHEMA)


def update_schema(lo):
	"""
	update the ldap schema file
	"""
	res = lo.search(base="cn=Subschema", scope=ldap.SCOPE_BASE, filter='(objectclass=*)', attr=['+', '*'])
	for dn, data in res:
		_update_schema(data)


def create_ldif_from_master(lo, ldif_file, base, page_size):
	"""
	create ldif file from everything from lo
	"""
	if ldif_file == '-':
		output = sys.stdout
		stdout = True
	else:
		stdout = False
		if os.path.isfile(ldif_file):
			os.unlink(ldif_file)
		output = gzip.open(ldif_file, 'wb')

	lc = SimplePagedResultsControl(ldap.LDAP_CONTROL_PAGE_OID, True, (page_size, ''))
	msgid = lo.lo.search_ext(base, ldap.SCOPE_SUBTREE, '(objectclass=*)', ['+', '*'], serverctrls=[lc])

	while True:
		rtype, rdata, rmsgid, serverctrls = lo.lo.result3(msgid)
		ldif_data = ''
		for i in rdata:
			dn, data = i
			for i in replication.EXCLUDE_ATTRIBUTES:
				if data.get(i):
					del data[i]
			if stdout:
				output.write(ldif.CreateLDIF(dn, data, cols=10000))
			else:
				ldif_data = ldif_data + ldif.CreateLDIF(dn, data, cols=10000)
		if not stdout:
			output.write(ldif_data)
		pctrls = [
			c
			for c in serverctrls
			if c.controlType == ldap.LDAP_CONTROL_PAGE_OID
		]
		if pctrls:
			est, cookie = pctrls[0].controlValue
			if cookie:
				lc.controlValue = (page_size, cookie)
				msgid = lo.lo.search_ext(base, ldap.SCOPE_SUBTREE, '(objectclass=*)', ['+', '*'], serverctrls=[lc])
			else:
				break
		else:
			print("Warning:  Server ignores RFC 2696 control.")
			break
	output.close()


def main():
	usage = "usage: %prog [options]"
	parser = optparse.OptionParser(usage=usage, description=__doc__)
	parser.add_option("-l", "--ldif", action="store_true", help="create ldif file")
	parser.add_option("-s", "--schema", action="store_true", help="update ldap schema")
	parser.add_option("-o", "--outfile", default="/var/lib/univention-directory-listener/master.ldif.gz", help="gzip file to store ldif data")
	parser.add_option("-p", "--pagesize", type=int, default=1000, help="page size to use for ldap paged search")
	opts, args = parser.parse_args()

	ucr = univention.config_registry.ConfigRegistry()
	ucr.load()
	base = ucr.get("ldap/base")
	if ucr.get("server/role", "") == "domaincontroller_backup":
		lo = uldap.getAdminConnection()
	else:
		lo = uldap.getMachineConnection(ldap_master=True)

	if opts.schema:
		update_schema(lo)

	if opts.ldif:
		create_ldif_from_master(lo, opts.outfile, base, opts.pagesize)


if __name__ == "__main__":
	main()
