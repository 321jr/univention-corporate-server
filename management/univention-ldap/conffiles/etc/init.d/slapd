#!/bin/sh
@%@UCRWARNING=# @%@
# pidfile: /var/run/slapd/slapd.pid
### BEGIN INIT INFO
# Provides:          slapd
# Required-Start:    $remote_fs $network $syslog
# Required-Stop:     $remote_fs $network $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: OpenLDAP standalone server (Lightweight Directory Access Protocol)
### END INIT INFO

# Specify path variable
PATH=/sbin:/usr/sbin:/bin:/usr/bin

. /lib/lsb/init-functions

# Kill me on all errors
#set -e

# Set the paths to slapd as a variable so that someone who really
# wants to can override the path in /etc/default/slapd.
SLAPD=/usr/sbin/slapd

# Stop processing if slapd is not there
[ -x $SLAPD ] || exit 0

# debconf may have this file descriptor open and it makes things work a bit
# more reliably if we redirect it as a matter of course.  db_stop will take
# care of this, but this won't hurt.
exec 3>/dev/null

# Source the init script configuration
if [ -f "/etc/default/slapd" ]; then
	. /etc/default/slapd
fi

# Load the default location of the slapd config file
if [ -z "$SLAPD_CONF" ]; then
		SLAPD_CONF=/etc/ldap/slapd.conf
	if [ -e /etc/ldap/slapd.d ]; then
		SLAPD_CONF=/etc/ldap/slapd.d
	else
		SLAPD_CONF=/etc/ldap/slapd.conf
	fi
fi

# Stop processing if the config file is not there
if [ ! -r "$SLAPD_CONF" ]; then
  log_warning_msg "No configuration file was found for slapd at $SLAPD_CONF."
  # if there is no config at all, we should assume slapd is not running
  # and exit 0 on stop so that unconfigured packages can be removed.
  [ "x$1" = xstop ] && exit 0 || exit 1
fi

# extend options depending on config type
if [ -f "$SLAPD_CONF" ]; then
	SLAPD_OPTIONS="-f $SLAPD_CONF $SLAPD_OPTIONS"
elif [ -d "$SLAPD_CONF" ] ; then
	SLAPD_OPTIONS="-F $SLAPD_CONF $SLAPD_OPTIONS"
fi

# Find out the name of slapd's pid file
if [ -z "$SLAPD_PIDFILE" ]; then
	# If using old one-file configuration scheme
	if [ -f "$SLAPD_CONF" ] ; then
		SLAPD_PIDFILE=`sed -ne 's/^pidfile[[:space:]]\+\(.\+\)/\1/p' \
			"$SLAPD_CONF"`
	# Else, if using new directory configuration scheme
	elif [ -d "$SLAPD_CONF" ] ; then
		SLAPD_PIDFILE=`sed -ne \
			's/^olcPidFile:[[:space:]]\+\(.\+\)[[:space:]]*/\1/p' \
			"$SLAPD_CONF"/'cn=config.ldif'`
	fi
fi

# XXX: Breaks upgrading if there is no pidfile (invoke-rc.d stop will fail)
# -- Torsten
if [ -z "$SLAPD_PIDFILE" ]; then
	log_failure_msg "The pidfile for slapd has not been specified"
	exit 1
fi

# Pass the user and group to run under to slapd
if [ "$SLAPD_USER" ]; then
	SLAPD_OPTIONS="-u $SLAPD_USER $SLAPD_OPTIONS"
fi

if [ "$SLAPD_GROUP" ]; then
	SLAPD_OPTIONS="-g $SLAPD_GROUP $SLAPD_OPTIONS"
fi

# Check whether we were configured to not start the services.
check_for_no_start() {
	if [ -n "$SLAPD_NO_START" ]; then
		echo 'Not starting slapd: SLAPD_NO_START set in /etc/default/slapd' >&2
		exit 0
	fi
	if [ -n "$SLAPD_SENTINEL_FILE" ] && [ -e "$SLAPD_SENTINEL_FILE" ]; then
		echo "Not starting slapd: $SLAPD_SENTINEL_FILE exists" >&2
		exit 0
	fi
}

# Tell the user that something went wrong and give some hints for
# resolving the problem.
report_failure() {
	log_end_msg 1
	if [ -n "$reason" ]; then
		log_failure_msg "$reason"
	else
		log_failure_msg "The operation failed but no output was produced."

		if [ -n "$SLAPD_OPTIONS" -o \
		     -n "$SLAPD_SERVICES" ]; then
			if [ -z "$SLAPD_SERVICES" ]; then
				if [ -n "$SLAPD_OPTIONS" ]; then
					log_failure_msg "Command line used: slapd $SLAPD_OPTIONS"
				fi
			else
				log_failure_msg "Command line used: slapd -h '$SLAPD_SERVICES' $SLAPD_OPTIONS"
			fi
		fi
	fi
}

# Start the slapd daemon and capture the error message if any to 
# $reason.
start_slapd() {
	# Make sure /var/run/slapd exists with correct permissions
	if [ ! -d /var/run/slapd ]; then
		mkdir -p /var/run/slapd
		[ -z "$SLAPD_USER" ] || chown -R "$SLAPD_USER" /var/run/slapd
		[ -z "$SLAPD_GROUP" ] || chgrp -R "$SLAPD_GROUP" /var/run/slapd
	fi

	# Make sure the pidfile directory exists with correct permissions
	piddir=`dirname "$SLAPD_PIDFILE"`
	if [ ! -d "$piddir" ]; then
		mkdir -p "$piddir"
		[ -z "$SLAPD_USER" ] || chown -R "$SLAPD_USER" "$piddir"
		[ -z "$SLAPD_GROUP" ] || chgrp -R "$SLAPD_GROUP" "$piddir"
	fi

	# check that no slapd is running
	if ! start-stop-daemon --start --quiet --exec $SLAPD --test > /dev/null; then
		log_action_msg "LDAP server already running"
		exit 0
	fi

@!@
if configRegistry['ldap/database/type'] == 'bdb':
	print '\t# check backend database'
	print '\tbdbrecover'
if configRegistry.is_true('ldap/replog'):
	print '\tcheck_replog_file'
@!@

@!@
uris = ['ldapi:///']
for p in configRegistry.get('slapd/port', '7389').split(','):
	uris.append('ldap://:%s/' % p)
for p in configRegistry.get('slapd/port/ldaps', '7636').split(','):
	uris.append('ldaps://:%s/' % p)
print '\tSLAPD_SERVICES="%s"' % ' '.join(uris)
if configRegistry.get('ldap/maxopenfiles'):
	print '\t\tulimit -n %s' % configRegistry['ldap/maxopenfiles']
@!@

	ucs_start () {
	local i
	for i in 0 1 2 3
	do
	if [ -z "$SLAPD_SERVICES" ]; then
		reason="`start-stop-daemon --start --quiet --oknodo \
			--pidfile "$SLAPD_PIDFILE" \
			--exec $SLAPD -- $SLAPD_OPTIONS 2>&1`" && return $?
	else
		reason="`start-stop-daemon --start --quiet --oknodo \
			--pidfile "$SLAPD_PIDFILE" \
			--exec $SLAPD -- -h "$SLAPD_SERVICES" $SLAPD_OPTIONS 2>&1`" && return $?
	fi
	local rvalue=$?
	[ "i686" = "$(uname -m)" ] || return $rvalue
	sleep 1
	done
	reason="slapd start failed, check if ldap/database/mdb/maxsize is supported on this architecture"
	exit_if_start_is_running
	[ -e /usr/sbin/slapschema ] && log_action_msg $(/usr/sbin/slapschema 2>&1)
	return $rvalue
	}
	ucs_start || return $?

	# Backward compatibility with OpenLDAP 2.1 client libraries.
	if [ ! -h /var/run/ldapi ] && [ ! -e /var/run/ldapi ] ; then
		ln -s slapd/ldapi /var/run/ldapi
	fi
}

# Stop the slapd daemon and capture the error message (if any) to
# $reason.
stop_slapd() {
	## first try with pidfile
	reason="`start-stop-daemon --stop --quiet --oknodo --retry TERM/10 \
		--pidfile "$SLAPD_PIDFILE" \
		--exec $SLAPD 2>&1`"
	[ $? -eq 0 ] && return 0
	local pid
	pid=$(pgrep -f "^$SLAPD")
	if [ -n "$pid" ]; then
		log_action_end_msg 1
		## try via executable name
		log_action_begin_msg "Slapd still running ($pid), terminating via executable name"
		reason="`start-stop-daemon --stop --quiet --oknodo --retry TERM/10 \
			--exec $SLAPD 2>&1`"
		rm -f "$SLAPD_PIDFILE"
	fi
}

exit_if_start_is_running () {
	local pid
	pid=$(pgrep -cf "^/bin/sh /etc/init.d/slapd start$")
	if [ -n "$pid" ] && [ "$pid" -gt 1 ]; then
		log_action_msg "WARNING: Another /etc/init.d/slapd start is already in progress."
		exit 1
	fi
}

bdbrecover () {
	local back_bdb_version
	local DBRECOVER
	local DBSTAT
	local dbstat_output
	local dbstat_rc
	local bdb_version
	local stale_locks
	local logger_tag
	local line

	log_action_begin_msg "Check database: "
	# determine libdb version that back-bdb.so was linked against
	back_bdb_version="$(/usr/bin/ldd /usr/lib/ldap/back_bdb.so | sed -n 's|.*/usr/lib/.*/libdb-\([0-9.]*\).so.*|\1|p')"
	DBRECOVER="/usr/bin/db${back_bdb_version}_recover"
	DBSTAT="/usr/bin/db${back_bdb_version}_stat"
	if [ -e "${DBRECOVER}" ]; then
		# check if the db_stat version works on the database environment
		dbstat_output=$("${DBSTAT}" -h /var/lib/univention-ldap/ldap -Ne 2>&1)
		dbstat_rc=$?
		if [ "$dbstat_rc" = 0 ]; then
			bdb_version=$(echo "$dbstat_output" | sed -rn 's/^([^\s]+)\s+Environment version$/\1/p')
			if [ -n "$bdb_version" ]; then
				# check for stale locks or stale futexes
				stale_locks=$("${DBSTAT}" -h /var/lib/univention-ldap/ldap -Nc 2>&1 | sed -rn 's/([0-9]*)\t*Number of current locks/\1/p')
				if [ "$stale_locks" != 0 ]; then
					exit_if_start_is_running
					log_action_msg "WARNING"
					log_action_msg "WARNING: There are $stale_locks stale locks in LDAP backend Berkeley DB (version $bdb_version)"
					log_action_msg "WARNING: If slapd does not respond, manual LDAP dump/restore may be necessary"
					log_action_begin_msg "Continuing BDB database check: "
				fi
				logger_tag="slapd db${back_bdb_version}_recover"
				dbrecover_output=$("${DBRECOVER}" -h /var/lib/univention-ldap/ldap -e 2>&1)
				if [ "$?" != 0 ]; then
					exit_if_start_is_running
				else
					echo "$dbrecover_output" | while read line; do logger -t "$logger_tag" "$line"; done
				fi
				log_action_end_msg 0
			else
				log_action_msg "/var/lib/univention-ldap/ldap BDB Version does not seem to match the one back-bdb uses"
				log_action_msg "Skipping ${DBRECOVER} to avoid damage"

				logger_tag="slapd db${back_bdb_version}_stat"
				logger -t "$logger_tag" "BDB file version detection faild:"
				echo "$dbstat_output" | while read line; do logger -t "$logger_tag" "$line"; done
			fi
		else
			log_action_msg "Could not determine BDB version of /var/lib/univention-ldap/ldap"
			exit_if_start_is_running
			log_action_msg "Skipping ${DBRECOVER} to avoid damage"

			logger_tag="slapd db${back_bdb_version}_stat"
			logger -t "$logger_tag" "command failed ($dbstat_rc):"
			echo "$dbstat_output" | while read line; do logger -t "$logger_tag" "$line"; done
		fi
	else
		log_action_msg "back-bdb was linked against ${back_bdb_version}, but db${back_bdb_version}-util package does not seem to be installed"
		log_action_msg "Skipping ${DBRECOVER}"
	fi
}

check_subschema ()
{
	tmpfile=`mktemp`
	res=1
	count=0
	while [ $res != 0 ] ; do
		ldapsearch -x -H ldapi:/// -s base -b cn=Subschema 'objectClass=subschema' objectClasses attributeTypes matchingRules matchingRuleUse dITStructureRules dITContentRules nameForms ldapSyntaxes >$tmpfile
		res=$?
		if [ $res != 0 ]; then
			count=$((count+1))
			if [ $count -ge 5 ]; then
				echo "Failed to search schema"
				exit 1
			fi
			sleep 2
		fi
	done
@!@
if configRegistry.is_true('ldap/schema/export'):
		print '\tcp $tmpfile /var/www/ldap-schema.txt'
		print '\tchmod a+r /var/www/ldap-schema.txt'
@!@
	md5=`md5sum $tmpfile | awk '{print $1}'`
	rm -f "$tmpfile"

	if [ ! -d /var/lib/univention-ldap/schema ]; then
		mkdir /var/lib/univention-ldap/schema
	fi
	if [ ! -e /var/lib/univention-ldap/schema/md5 ]; then
		touch /var/lib/univention-ldap/schema/md5
	fi
	md5_old=`cat /var/lib/univention-ldap/schema/md5`
	if [ "$md5" != "$md5_old" ]; then
		if [ ! -d /var/lib/univention-ldap/schema/id ]; then
			mkdir /var/lib/univention-ldap/schema/id
		fi
		if [ ! -e /var/lib/univention-ldap/schema/id/id ]; then
			touch /var/lib/univention-ldap/schema/id/id
		fi
		id=`cat /var/lib/univention-ldap/schema/id/id`
		if [ -z "$id" ]; then
			id=0
		fi
		id=$((id+1))
		echo "$md5" >/var/lib/univention-ldap/schema/md5
		echo "$id" >/var/lib/univention-ldap/schema/id/id
		chown listener /var/lib/univention-ldap/schema/id/id
	else
		id=`cat /var/lib/univention-ldap/schema/id/id`
		if [ -z "$id" ]; then
			echo "1" >/var/lib/univention-ldap/schema/id/id
			chown listener /var/lib/univention-ldap/schema/id/id
		fi
	fi
}

check_replog_file ()
{
	test -f /var/lib/univention-ldap/replog/replog ||
		touch /var/lib/univention-ldap/replog/replog
	chmod 0600 /var/lib/univention-ldap/replog/replog
	test -f /var/lib/univention-ldap/replog/replog.lock ||
		touch /var/lib/univention-ldap/replog/replog.lock
}

# Start the OpenLDAP daemons
start_ldap() {
	trap 'report_failure' 0
	log_daemon_msg "Starting OpenLDAP" "slapd"
	start_slapd
	trap "-" 0
	log_end_msg 0

@!@
if configRegistry['ldap/server/type'] == "master":
	print '\tlog_action_begin_msg "Checking Schema ID: "'
	print '\tcheck_subschema 2>&1'
	print '\tlog_action_end_msg $?'
@!@

	if [ -e /var/lib/univention-directory-replication/failed.ldif ]; then
		log_action_begin_msg "Found failed.ldif. Importing "
		if [ -x /usr/sbin/univention-directory-replication-resync ] && /usr/sbin/univention-directory-replication-resync /var/lib/univention-directory-replication/failed.ldif >>/var/log/univention/listener.log 2>&1
		then
			log_action_end_msg 0
		else
			log_action_end_msg 1
			log_action_msg "Please check /var/log/univention/listener.log"
			exit 1
		fi
	fi
}

# Stop the OpenLDAP daemons
stop_ldap() {
	trap 'report_failure' 0
	log_daemon_msg "Stopping OpenLDAP" "slapd"
	stop_slapd
	trap "-" 0
	log_end_msg 0
}

case "$1" in
  start)
	check_for_no_start
	logger "/etc/init.d/slapd $1 (pid: $$, ppid:$(ps -p $PPID -o pid= -o comm=))"
  	start_ldap ;;
  stop)
	logger "/etc/init.d/slapd $1 (pid: $$, ppid:$(ps -p $PPID -o pid= -o comm=))"
  	stop_ldap ;;
  restart|force-reload)
	logger "/etc/init.d/slapd $1 (pid: $$, ppid:$(ps -p $PPID -o pid= -o comm=))"
	check_for_no_start
  	stop_ldap
	start_ldap
	;;
  status)
	status_of_proc -p $SLAPD_PIDFILE $SLAPD slapd
	;;
  crestart)
	logger "/etc/init.d/slapd $1 (pid: $$, ppid:$(ps -p $PPID -o pid= -o comm=))"
	if pidof slapd > /dev/null 2>&1
	then
		"$0" restart
	else
		log_action_msg "No slapd process found, no restart needed"
	fi
	;;
  graceful-restart)
	"$0" restart
	;;
  *)
  	echo "Usage: $0 {start|stop|restart|force-reload|status|crestart|graceful-restart}"
	exit 1
	;;
esac

exit 0
