#!/usr/bin/python2.7
# -*- coding: utf-8 -*-
#
# Univention App Center
#  univention-appcenter-listener-converter
#
# Copyright 2018 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.
#

import os
import os.path
from argparse import ArgumentParser
from glob import glob
import time
import json
import shutil

from univention.listener.handler_logging import get_logger

from univention.appcenter.app_cache import Apps
from univention.appcenter.utils import mkdir, call_process
from univention.appcenter.udm import search_objects, get_machine_connection, get_connection
from univention.appcenter.ucr import ucr_get, ucr_load
from univention.appcenter.packages import reload_package_manager
from univention.appcenter.listener import LISTENER_DUMP_DIR


logger = None


def get_app_connection(app):
	if get_app_connection._connection is None:
		if app.docker:
			machine_account = ucr_get(app.ucr_hostdn_key)
			try:
				from univention.appcenter.docker import Docker
			except ImportError:
				return None, None
			docker = Docker(app, logger)
			if docker.is_running():
				machine_password = open(docker.path('/etc/machine.secret')).read()
			get_app_connection._connection = get_connection(machine_account, machine_password)
			logger.info('Using App account connection')
		else:
			get_app_connection._connection = get_machine_connection()
			logger.info('Using machine connection')
	return get_app_connection._connection
get_app_connection._connection = None


def run_trigger(app):
	logger.info('Running trigger')
	success = True
	cached_script = app.get_cache_file('listener_trigger')
	if not os.path.exists(cached_script):
		logger.info('No trigger defined...')
		return
	if app.docker:
		try:
			from univention.appcenter.docker import Docker
		except ImportError:
			logger.info('Docker App not supported')
			return
		docker = Docker(app, logger)
		script_name = '/tmp/univention-%s.listener_trigger' % app.id
		open(docker.path(script_name), 'wb')
		process = docker.execute('chmod', '0700', script_name)
		shutil.copy(cached_script, docker.path(script_name))
		process = docker.execute(script_name)
		success = process.returncode == 0
	else:
		os.chmod(cached_script, 0o744)
		call_process([cached_script], logger=logger)
	if success:
		logger.info('Success! Removing consumed files')
		dst = os.path.join(app.get_data_dir(), 'listener')
		for fname in sorted(glob(os.path.join(dst, '*.json'))):
			os.unlink(fname)


def convert(app, dumped, filename):
	udm_type = dumped['object_type']
	command = dumped['command']
	entry_uuid = dumped['entry_uuid']
	dn = dumped['dn']
	if command == 'delete':
		attrs = None
	else:
		lo, pos = get_app_connection(app)
		objs = search_objects(udm_type, lo, pos, entryUUID=entry_uuid)
		if objs:
			attrs = objs[0].info
		else:
			logger.info('EntryUUID %s not found' % entry_uuid)
			return False
	dst_dir = os.path.join(app.get_data_dir(), 'listener')
	mkdir(dst_dir)
	base = os.path.basename(filename)
	dst = os.path.join(dst_dir, base)
	with open(dst, 'wb') as fd:
		attrs = {
			'id': entry_uuid,
			'object': attrs,
			'dn': dn,
			'udm_object_type': udm_type,
		}
		json.dump(attrs, fd, sort_keys=True, indent=4)
	logger.info('Successfully created %s for the App to consume' % dst)
	return True


def find_and_convert_files(app):
	filenames = sorted(glob(os.path.join(LISTENER_DUMP_DIR, app.id, '*.json')))
	used_entry_uuids = {}
	dumped_objects = {}
	used_filenames = []
	obsolete_filenames = []
	for filename in filenames:
		logger.info('Converting %s' % filename)
		dumped = json.load(open(filename))
		entry_uuid = dumped['entry_uuid']
		if entry_uuid in used_entry_uuids:
			obsolete_filename = used_entry_uuids.pop(entry_uuid)
			logger.info('%s replaces earlier %s' % (filename, obsolete_filename))
			used_filenames.remove(obsolete_filename)
			obsolete_filenames.append(obsolete_filename)
		used_filenames.append(filename)
		used_entry_uuids[entry_uuid] = filename
		dumped_objects[filename] = dumped
	for filename in obsolete_filenames:
		logger.info('Deleting unused %s' % filename)
		os.unlink(filename)
	for filename in used_filenames:
		dumped = dumped_objects[filename]
		if convert(app, dumped, filename):
			logger.info('Deleting used %s' % filename)
			os.unlink(filename)
	if filenames:
		return True


def main():
	usage = '%(prog)s'
	description = '%(prog)s converts files written by the App Center listener integration to files that can be processed be the App itself. Logs to the corresponding listener log file.'
	parser = ArgumentParser(usage=usage, description=description)
	parser.add_argument('app', help='App whose listener output should be converted.')
	parser.add_argument('--once', action='store_true', help='Only do this once and then quit (otherwise will loop forever).')
	args = parser.parse_args()
	old_app = None
	global logger
	logger = get_logger(args.app)
	while True:
		ucr_load()
		reload_package_manager()
		interval = int(ucr_get('appcenter/converter/sleep', '1'))
		app = Apps().find(args.app)
		if not app:
			logger.info('App not found')
		elif not app.is_installed():
			logger.info('App not installed')
		else:
			try:
				if old_app is None or app != old_app:
					logger.info('Need a new LDAP connection')
					get_connection._connection = None
					old_app = app
				if find_and_convert_files(app):
					run_trigger(app)
			except Exception:
				logger.error('Error in the Listener converter', exc_info=1)
		if args.once:
			break
		time.sleep(interval)


if __name__ == '__main__':
	main()
