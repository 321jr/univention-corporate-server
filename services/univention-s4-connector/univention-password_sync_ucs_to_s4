#!/usr/bin/python2.6
# -*- coding: utf-8 -*-
#
# Univention Samba4 Password sync
#  sync the password from UCS to Samba4
#
# Copyright 2010-2011 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.

from univention.config_registry import ConfigRegistry
import univention.uldap
import univention.admin.uldap
import ldap
import univention.debug2 as ud
from univention.connector.ad import password
from ldap.controls import LDAPControl
from optparse import OptionParser
import sys, binascii


def password_sync_ucs_to_s4( lo_ucs, lo_s4, ucs_object, s4_object ):
	_d=ud.function('password_sync_ucs_to_s4')
	ud.debug(ud.LDAP, ud.WARN, "password_sync_ucs_to_s4 called")
	
	compatible_modstring = univention.connector.ad.compatible_modstring
	try:
		ud.debug(ud.LDAP, ud.INFO, "Object DN=%s" % s4_object['dn'])
	except: # FIXME: which exception is to be caught?
		ud.debug(ud.LDAP, ud.INFO, "Object DN not printable")
		
	try:
		ud.debug(ud.LDAP, ud.INFO, "   UCS DN = %s" % ucs_object['dn'])
	except: # FIXME: which exception is to be caught?
		ud.debug(ud.LDAP, ud.INFO, "   UCS DN not printable")

	try:
		res = lo_ucs.lo.search(base=ucs_object['dn'], scope='base', attr=['sambaLMPassword', 'sambaNTPassword','sambaPwdLastSet','sambaPwdMustChange', 'krb5PrincipalName', 'krb5Key', 'shadowLastChange', 'shadowMax', 'krb5PasswordEnd'])
	except ldap.NO_SUCH_OBJECT:
		ud.debug(ud.LDAP, ud.PROCESS, "password_sync_ucs_to_s4: The UCS object (%s) was not found. The object was removed." % ucs_object['dn'])
		return
	
	sambaPwdLastSet = None
	if res[0][1].has_key('sambaPwdLastSet'):
		sambaPwdLastSet = long(res[0][1]['sambaPwdLastSet'][0])
	ud.debug(ud.LDAP, ud.INFO, "password_sync_ucs_to_s4: sambaPwdLastSet: %s" % sambaPwdLastSet)
	
	sambaPwdMustChange = -1
	if res[0][1].has_key('sambaPwdMustChange'):
		sambaPwdMustChange = long(res[0][1]['sambaPwdMustChange'][0])
	ud.debug(ud.LDAP, ud.INFO, "password_sync_ucs_to_s4: sambaPwdMustChange: %s" % sambaPwdMustChange)

	ucsLMhash = res[0][1].get('sambaLMPassword', [None])[0]
	ucsNThash = res[0][1].get('sambaNTPassword', [None])[0]
	krb5Principal = res[0][1].get('krb5PrincipalName', [None])[0]
	krb5Key = res[0][1].get('krb5Key', [])

	if not ucsNThash:
		ud.debug(ud.LDAP, ud.WARN, "password_sync_ucs_to_s4: Failed to get Password-Hash from UCS")
	# ud.debug(ud.LDAP, ud.WARN, "password_sync_ucs_to_s4: Password-Hash from UCS: %s" % ucsNThash)

	res = lo_s4.lo.search_s(univention.connector.ad.compatible_modstring(s4_object['dn']), ldap.SCOPE_BASE, '(objectClass=*)',['pwdLastSet','objectSid'])
	pwdLastSet = None
	if res[0][1].has_key('pwdLastSet'):
		pwdLastSet = long(res[0][1]['pwdLastSet'][0])
	objectSid = univention.connector.ad.decode_sid(res[0][1]['objectSid'][0])
	ud.debug(ud.LDAP, ud.INFO, "password_sync_ucs_to_s4: pwdLastSet from AD : %s" % pwdLastSet)
	# rid = None
	# if res[0][1].has_key('objectSid'):
	# 	rid = str(univention.connector.ad.decode_sid(res[0][1]['objectSid'][0]).split('-')[-1])

	pwd_set = False
	res = lo_s4.lo.search_s(lo_s4.base, ldap.SCOPE_SUBTREE, compatible_modstring('(objectSid=%s)' % objectSid), ['unicodePwd', 'supplementalCredentials', 'msDS-KeyVersionNumber', 'dBCSPwd'])
	unicodePwd_attr = res[0][1].get('unicodePwd', [None])[0]
	dBCSPwd_attr = res[0][1].get('dBCSPwd', [None])[0]
	supplementalCredentials = res[0][1].get('supplementalCredentials', [None])[0]
	msDS_KeyVersionNumber = res[0][1].get('msDS-KeyVersionNumber', [0])[0]
	# ud.debug(ud.LDAP, ud.INFO, "password_sync_ucs_to_s4: Password-Hash from S4: %s" % unicodePwd_attr)

	s4NThash = None
	if unicodePwd_attr:
		s4NThash = binascii.b2a_hex(unicodePwd_attr).upper()
	else:
		ud.debug(ud.LDAP, ud.WARN, "password_sync_ucs_to_s4: Failed to get NT Password-Hash from S4")

	s4LMhash = None
	if dBCSPwd_attr:
		s4LMhash = binascii.b2a_hex(dBCSPwd_attr).upper()
	else:
		ud.debug(ud.LDAP, ud.WARN, "password_sync_ucs_to_s4: Failed to get LM Password-Hash from S4")

	modlist=[]
	if not ucsNThash == s4NThash:
		ud.debug(ud.LDAP, ud.INFO, "password_sync_ucs_to_s4: NT Hash S4: %s NT Hash UCS: %s" % (s4NThash, ucsNThash))
		pwd_set = True
		# res = set_password_in_s4(connector, object['attributes']['sAMAccountName'][0], ucsNThash+ucsLMhash)
		if unicodePwd_attr:
			modlist.append((ldap.MOD_DELETE, 'unicodePwd', unicodePwd_attr))
		if ucsNThash:
			unicodePwd_new = binascii.a2b_hex(ucsNThash)
			modlist.append((ldap.MOD_ADD, 'unicodePwd', unicodePwd_new))

	if not ucsLMhash == s4LMhash:
		ud.debug(ud.LDAP, ud.INFO, "password_sync_ucs_to_s4: LM Hash S4: %s LM Hash UCS: %s" % (s4LMhash, ucsLMhash))
		pwd_set = True
		if dBCSPwd_attr:
			modlist.append((ldap.MOD_DELETE, 'dBCSPwd', dBCSPwd_attr))
		if ucsLMhash:
			dBCSPwd_new = binascii.a2b_hex(ucsLMhash)
			modlist.append((ldap.MOD_ADD, 'dBCSPwd', dBCSPwd_new))

	if pwd_set:
		if krb5Principal:
			## encoding of Samba4 supplementalCredentials
			if supplementalCredentials:
				modlist.append((ldap.MOD_DELETE, 'supplementalCredentials', supplementalCredentials))
			if krb5Key:
				try:
					supplementalCredentials_new = univention.connector.ad.password.calculate_supplementalCredentials(krb5Key, supplementalCredentials)
				except RuntimeError, err:
					(type, value, tb) = sys.exc_info()
					import traceback
					traceback.print_tb(tb)
					del tb
					if value[1] == 'Character Conversion Error':
						print "\nThis might indicate that the UCS krb5key does not contain a salt"
						
					sys.exit(1)
				modlist.append((ldap.MOD_ADD, 'supplementalCredentials', supplementalCredentials_new))
				#if supplementalCredentials:
				#	modlist.append((ldap.MOD_REPLACE, 'msDS-KeyVersionNumber', krb5KeyVersionNumber))
				#else:
				#	modlist.append((ldap.MOD_ADD, 'msDS-KeyVersionNumber', krb5KeyVersionNumber))

		# TODO: "pwdlastset auf -1 setzen" ?
		if sambaPwdMustChange >= 0 and sambaPwdMustChange < time.time():
			# password expired, must be changed on next login
			ud.debug(ud.LDAP, ud.INFO, "password_sync_ucs_to_s4: samba pwd expired, set newpwdLastSet to 0")
			newpwdlastset = "0"
		else:
			newpwdlastset = str(univention.connector.ad.samba2ad_time(sambaPwdLastSet))
		ud.debug(ud.LDAP, ud.INFO, "password_sync_ucs_to_s4: pwdlastset in modlist: %s" % newpwdlastset)
		modlist.append((ldap.MOD_REPLACE, 'pwdlastset', newpwdlastset))
	else:
		ud.debug(ud.LDAP, ud.INFO, "password_sync_ucs_to_s4: No password change to sync to S4 ")

	## TODO: Password History
	ctrl_bypass_password_hash = LDAPControl('1.3.6.1.4.1.7165.4.3.12',criticality=0)
	ud.debug(ud.LDAP, ud.INFO, "password_sync_ucs_to_s4: modlist: %s" % modlist)
	if modlist:
		lo_s4.lo.modify_ext_s(compatible_modstring(s4_object['dn']), modlist, serverctrls=[ ctrl_bypass_password_hash ])


class S4:
	def __init__(self, ucrbase, ucr=None):
		self.ucrbase = ucrbase
		if ucr:
			self.ucr = ucr
		else:
			self.ucr = ConfigRegistry()
			self.ucr.load()

		self.init_debug()
		self.open_s4()
		self.open_ucs()

	def init_debug(self):
		_d=ud.function('init_debug')
		try:
			function_level=int(self.ucr.get('%s/debug/function' % self.ucrbase, 0))
		except:
			function_level = 0
		ud.init('/var/log/univention/%s-s4.log' % self.ucrbase, 1, function_level)
		debug_level=self.ucr.get('%s/debug/level' % self.ucrbase, 2)
		ud.set_level(ud.LDAP, int(debug_level))

	def open_s4( self ):
		tls_mode = 2
		if self.ucr.get('%s/ad/ldap/ssl' % self.ucrbase) == "no":
			ud.debug(ud.LDAP, ud.INFO,"__init__: LDAPS-connection to S4 switched of by UCR.")
			tls_mode = 0

		protocol = self.ucr.get('%s/ad/ldap/protocol' % self.ucrbase, 'ldap').lower()
		ldap_host_s4 = self.ucr.get('%s/ad/ldap/host' % self.ucrbase)
		ldap_port_s4 = int(self.ucr.get('%s/ad/ldap/port' % self.ucrbase))
		self.ldap_base_s4 = self.ucr.get('%s/ad/ldap/base' % self.ucrbase)
		ldap_binddn_s4 = self.ucr.get('%s/ad/ldap/binddn' % self.ucrbase)
		ldap_bindpw_s4 = open(self.ucr['%s/ad/ldap/bindpw' % self.ucrbase]).read().strip('\n')
		ldap_certificate_s4 = self.ucr.get('%s/ad/ldap/certificate' % self.ucrbase)
		if protocol == 'ldapi':
			import urllib
			socket = urllib.quote(self.ucr.get('%s/ad/ldap/socket' % self.ucrbase, ''), '')
			ldap_uri_s4 = "%s://%s" % (protocol, socket)
		else:
			ldap_uri_s4 = "%s://%s:%d" % (protocol, ldap_host_s4, ldap_port_s4)

		try:
			self.lo_s4=univention.uldap.access(host=ldap_host_s4, port=ldap_port_s4, base=self.ldap_base_s4, binddn=ldap_binddn_s4, bindpw=ldap_bindpw_s4, start_tls=tls_mode, ca_certfile=ldap_certificate_s4, decode_ignorelist=['objectSid', 'objectGUID', 'repsFrom', 'replUpToDateVector', 'ipsecData', 'logonHours', 'userCertificate', 'dNSProperty', 'dnsRecord', 'member', 'unicodePwd'], uri=ldap_uri_s4)
		except ldap.SERVER_DOWN:
			ud.debug(ud.LDAP, ud.PROCESS, "open_ucs: Cannot initialize LDAP-Connections.")

		self.lo_s4.lo.set_option(ldap.OPT_REFERRALS,0)

	def open_ucs( self ):
		bindpw=open('/etc/ldap.secret').read()
		self.ucs_ldap_base = self.ucr.get('ldap/base')
		if bindpw[-1] == '\n':
			bindpw=bindpw[0:-1]

		try:
			self.lo_ucs=univention.admin.uldap.access(host=self.ucr['ldap/master'], base=self.ucr['ldap/base'], binddn='cn=admin,'+self.ucr['ldap/base'], bindpw=bindpw, start_tls=2)
		except ldap.SERVER_DOWN:
			ud.debug(ud.LDAP, ud.PROCESS, "open_ucs: Cannot initialize LDAP-Connections.")

	def sync_password( self, username ):
		try:
			res = self.lo_ucs.lo.search(base=self.ucs_ldap_base, scope='sub', filter='(&(objectClass=sambaSamAccount)(uid=%s))' % username, attr=['dn'])
		except ldap.NO_SUCH_OBJECT:
			ud.debug(ud.LDAP, ud.PROCESS, "password_ucs_to_s4: The UCS user (%s) was not found." % username)
			print "password_ucs_to_s4: The UCS user (%s) was not found." % username
			return
		if not res:
			ud.debug(ud.LDAP, ud.PROCESS, "password_ucs_to_s4: The UCS user (%s) was not found." % username)
			print "\npassword_ucs_to_s4: The UCS user (%s) was not found." % username
			return
		ucs_object = {}
		ucs_object['dn'] = res[0][0]


		try:
			res = self.lo_s4.lo.search_s(self.ldap_base_s4, ldap.SCOPE_SUBTREE, '(&(objectClass=user)(!(objectClass=computer))(cn=%s))' % username,['dn'])
		except ldap.NO_SUCH_OBJECT:
			ud.debug(ud.LDAP, ud.PROCESS, "password_ucs_to_s4: The Samba4 user (%s) was not found." % username)
			print "password_ucs_to_s4: The Samba4 user (%s) was not found." % username
			return
		if not res:
			ud.debug(ud.LDAP, ud.PROCESS, "password_ucs_to_s4: The Samba4 user (%s) was not found." % username)
			print "\npassword_ucs_to_s4: The Samba4 user (%s) was not found." % username
			return

		s4_object = {}
		s4_object['dn'] = res[0][0]
		password_sync_ucs_to_s4( self.lo_ucs, self.lo_s4, ucs_object, s4_object )
	
def main():
	usage = "usage: univention-password_sync_ucs_to_s4 [options] username"
	parser = OptionParser(usage=usage)
	parser.add_option("--ucrbase", dest="ucrbase",
			help="", metavar="ucrbase", default="connector")
	(options, args) = parser.parse_args()
	if not len(args) == 1:
		parser.error("need a username")

	s4 = S4(options.ucrbase)
	s4.sync_password(args[0])

if __name__ == '__main__':
	main()
