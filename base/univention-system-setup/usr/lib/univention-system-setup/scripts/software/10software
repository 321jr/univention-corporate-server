#!/bin/bash
#
# Univention Setup
#  software change script
#
# Copyright 2004-2011 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.

. /usr/lib/univention-system-setup/scripts/setup_utils.sh

info_header "$0" "$(gettext "Configuring software components")"

if [ "$check_ldap_access" = "1" ]; then
	exit 0
fi

packages=`get_profile_var "packages"`
packages_remove=`get_profile_var "packages_remove"`
packages_install=`get_profile_var "packages_install"`

if [ -z "$packages_remove" -a -z "$packages_install" ]; then
	exit 0
fi

eval "$(univention-config-registry shell)"

if [ "$server_role" = "domaincontroller_master" ]; then
	base="univention-server-master+"
elif [ $server_role = "domaincontroller_backup" ]; then
	base="univention-server-backup+"
elif [ $server_role = "domaincontroller_slave" ]; then
	base="univention-server-slave+"
elif [ $server_role = "memberserver" ]; then
	base="univention-server-member+"
elif [ $server_role = "fatclient" ]; then
	base="univention-managed-client+"
elif [ $server_role = "mobileclient" ]; then
	base="univention-mobile-client+"
fi

# create named pipes in order to merge status information and stdout
statFifo=$(mktemp -u /tmp/apt.stat.XXXXXXXX)
stdoutFifo=$(mktemp -u /tmp/apt.stdout.XXXXXXXX)
mkfifo "$stdoutFifo" "$statFifo"

# run the installation in a background process
( 
	# set options
	export DEBIAN_FRONTEND=noninteractive
	export APT_PARAMS="-o APT::Status-FD=4 -o DPkg::Options::=--force-confold -y --force-yes -o APT::Get::AllowUnauthenticated=1"

	# redirection of stdout/stderr and status information
    exec >$stdoutFifo 2>$stdoutFifo 4>$statFifo </dev/null

	# update
	echo "apt-get $APT_PARAMS update"
	apt-get $APT_PARAMS update
	echo "dlstatus:_:100:" >&4

	# install packages
	for p in $packages_remove; do
		echo "apt-get $APT_PARAMS install $p- $base" 
		apt-get $APT_PARAMS install $p- $base
	done

	# remove packages
	for p in $packages_install; do
		echo "apt-get $APT_PARAMS install $p $base"
		apt-get $APT_PARAMS install $p $base
	done
) &

# number of commands = number of installed/removed packages +1 (for the update command)
nCommands=$(( $(echo $packages_install | wc -w) + $(echo $packages_remove | wc -w) + 1 ))
progress_steps $((nCommands * 100))  # each command is in the range [0, 100]

# read from stdout/stderr and status information output via the named pipes
exec 5<$stdoutFifo 6<$statFifo
statResult=0
stdoutResult=0
icommand=0
lastPercentage=0
while [ "$statResult" != 1 -a "$stdoutResult" != 1 ]; do
	# read from apt-get stdout/stderr
    read -u 5 -t 0.1 line
    stdoutResult=$?
    [ $stdoutResult = 0 ] && echo "$line"

	# read from apt-get status information
    read -u 6 -t 0.1 line
    statResult=$?
    if [ $statResult = 0 ]; then
		# status information, parse the string and print out current step
		# as well as a descriptive information of what dpkg is doing
        IFS=$':'
        list=($line)
        IFS=$'\n\t '
		percentage=${list[2]%.*}  # the precentage might be floating point, remove fractions
		msg=${list[3]}

		# check whether we have passed to the next command
		[ "$percentage" -lt "$lastPercentage" ] && icommand=$((icommand+1))
		lastPercentage=$percentage

		# print out status information
        progress_next_step "$((percentage + icommand * 100))"
        [ -n "$msg" ] && progress_msg "$msg"
    fi
done

# remove named pipes
rm -f "$stdoutFifo" "$statFifo"

exit 0

