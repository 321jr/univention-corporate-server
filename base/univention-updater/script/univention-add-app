#!/usr/bin/python2.6
# -*- coding: utf-8 -*-
#
# Univention Updater
#  univention-add-app
#
# Copyright 2012-2013 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.
#

import sys
from optparse import OptionParser

from univention.lib.package_manager import PackageManager
from univention.config_registry import ConfigRegistry
from univention.updater import UniventionUpdater
try:
	from univention.management.console.modules.appcenter.util import ComponentManager
	from univention.management.console.modules.appcenter.app_center import Application, LICENSE
except ImportError:
	sys.stderr.write('univention-management-console-module-appcenter must be installed\n')
	sys.exit(2)

def simple_handler(f):
	def _simple_handler(msg):
		msg = '%s\n\r' % msg.strip()
		f.write(msg)
	return _simple_handler

if __name__ == '__main__':
	usage = '%prog <component> [-a] [-m] [<package> ...]'
	description = '%prog prepares the corresponding repository settings for the specified component and installs the given packages.'
	parser = OptionParser(usage=usage, description=description)
	parser.add_option("-a", "--all", action="store_true", dest="install_all", default=False,
			help="Installs all DefaultPackages of the app. If DC master or backup, also installs DefaultPackagesMaster. Performs dist-upgrade!")
	parser.add_option("-m", "--master", action="store_true", dest="install_master", default=False,
			help="If DC master or backup, installs DefaultPackagesMaster. Performs dist-upgrade! Has no meaning when used together with --all")
	(options, args) = parser.parse_args()
	try:
		component_id = args[0]
	except IndexError:
		parser.print_usage()
		sys.exit(1)
	# for compatibility with 3.1-0. may be removed with 3.2-0
	packages = args[1:]
	ucr = ConfigRegistry()
	ucr.load()
	updater = UniventionUpdater(False)
	component_manager = ComponentManager(ucr, updater)
	package_manager = PackageManager(info_handler=simple_handler(sys.stdout), error_handler=simple_handler(sys.stderr), always_noninteractive=True)
	requested_app = None
	function = 'install'
	for app in Application.all():
		requested_apps = filter(lambda iapp: iapp.component_id == component_id, app.versions)
		if requested_apps:
			requested_app = requested_apps[0]
			for iapp in app.versions:
				if app.is_installed(package_manager):
					function = 'update'
				component_manager.remove_app(iapp)
			break
	if requested_app is None:
		sys.stderr.write('App "%s" not found\n' % component_id)
		sys.exit(1)
	if not LICENSE.allows_using(requested_app.get('notifyvendor')):
		sys.stderr.write('App "%s" may not be installed\n' % requested_app.name)
		sys.exit(1)
	success = True
	component_manager.put_app(requested_app)
	package_manager.update()
	if options.install_all or options.install_master:
		only_master_packages = not options.install_all
		requested_app.candidate = None # delete a possible candidate (newer version)
		requested_app.versions = Application.find(requested_app.id).versions
		if only_master_packages:
			function = '%s-schema' % function
		success = requested_app.install(package_manager, component_manager, add_component=False, send_as=function, only_master_packages=only_master_packages) and success
	else:
		requested_app._send_information(function, 200)
	# for compatibility with 3.1-0. should be removed with 3.2-0
	if packages:
		success = package_manager.install(*packages) and success
	if success:
		sys.exit(0)
	else:
		sys.exit(100) # apt-get error code

