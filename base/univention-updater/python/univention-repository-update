#!/usr/bin/python2.4
#
# Univention Updater
#  repository update
#
# Copyright (C) 2004-2009 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# Binary versions of this file provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

from optparse import OptionParser
import copy
import os
import re
import shutil
import string
import subprocess
import sys
import time

import univention.config_registry as ucr
import univention.updater.repository as urepo
from univention.updater import UniventionMirror, UCS_Version

configRegistry = ucr.ConfigRegistry()
configRegistry.load()

# regular expression matching a UCS version X.Y-Z
_exp_version = re.compile( '(?P<major>[0-9]*)\.(?P<minor>[0-9]*)-(?P<patch>[0-9]*)' )
# base directory for local repository
_mirror_base = configRegistry.get( 'repository/mirror/basepath', '/var/lib/univention-repository' )
# directory of current version's repository
_current_version = '%s-%s' % ( configRegistry.get( 'version/version' ), configRegistry.get( 'version/patchlevel' ) )
_repo_base = os.path.join( _mirror_base, 'mirror', configRegistry.get( 'version/version' ), 'maintained', '%s-0' % configRegistry.get( 'version/version' ) )

def copy_repository( options, source, version ):
	print 'Copying packages. Please be patient ...',
	sys.stdout.flush()

	version = _exp_version.match( version ).groupdict()
	dest_repo = os.path.join( _mirror_base, 'mirror', '%(major)s.%(minor)s/maintained/%(major)s.%(minor)s-%(patch)s' % version )

	# check if repository already exists
	if os.path.isdir( os.path.join( dest_repo ) ):
		print >> options.teefile, 'Warning: repository for UCS version %(major)s.%(minor)s-%(patch)s already exists' % version
	else:
		# create directory structure
		for arch in urepo.ARCHITECTURES:
			os.makedirs( os.path.join( dest_repo, arch ) )

	# copy packages to new directory structure
	urepo.copy_package_files( source, dest_repo )

	# create Packages files
	urepo.update_indexes( dest_repo )

def update_cdrom( options ):
	# try to mount update ISO image or DVD
	if options.iso_file:
		ret = subprocess.call( [ 'mount', '-o', 'loop',  options.iso_file, options.mount_point ], stdout = options.logfile, stderr = options.logfile )
	elif options.device:
		ret = subprocess.call( [ 'mount', options.device, options.mount_point ], stdout = options.logfile, stderr = options.logfile )
	else:
		ret = subprocess.call( [ 'mount', options.mount_point ], stdout = options.logfile, stderr = options.logfile )

	# 0 == success, 32 == already mounted
	if not ret in ( 0, 32 ):
		if options.iso_file:
			print >> options.teefile, 'Error: Failed to mount ISO image %s' % options.iso_file
		else:
			print >> options.teefile, 'Error: Failed to mount CD-ROM device at %s' % options.mount_point
		sys.exit( 1 )

	# check update medium
	if not os.path.exists( os.path.join( options.mount_point, 'ucs-updates' ) ):
		print >> options.teefile, 'Error: This is not a valid UCS update medium'
		ret = subprocess.call( [ 'umount', options.mount_point ], stdout = options.logfile, stderr = options.logfile )
		if ret != 0:
			print >> options.teefile, 'Error: Failed to umount %s' % options.mount_point
			sys.exit( ret )
		sys.exit( 1 )
		if not os.path.exists( os.path.join( options.mount_point, 'ucs-updates', 'ucs_%s-%s.txt' % _current_version ) ):
			print >> options.teefile, 'Error: This is not the correct UCS update medium for version %s' % _current_version
			sys.exit( 1 )

	# find UCS version
	for entry in os.listdir( os.path.join( options.mount_point, 'ucs-updates' ) ):
		directory = os.path.join( options.mount_point, 'ucs-updates', entry )
		if os.path.isdir( directory ) and _exp_version.match( entry ):
			# copy repository
			copy_repository( options, directory, entry )

	ret = subprocess.call( [ 'umount', options.mount_point ], stdout = options.logfile, stderr = options.logfile )
	if ret != 0:
		print >> options.teefile, 'Error: Failed to umount %s' % options.mount_point
		sys.exit( ret )

def update_net( options ):
	mirror = UniventionMirror()
	# update local repository if available
	if not configRegistry.get( 'local/repository', 'no' ).lower() in ( 'yes', 'true' ):
		print >> options.teefile, 'Error: The local repository is not activated. Set the Univention Configuration Registry variable local/repository to yes'
		sys.exit( 1 )

	if options.sync:
		mirror.run()
	elif options.security_only:
		ucr.handler_commit( [ '/etc/apt/mirror.list' ] )
		mirror.run()
	elif options.update_to:
		ucr.handler_set( [ 'repository/mirror/version/end=%s' % options.update_to ] )
		mirror.run()
	else:
		nextupdate = mirror.release_update_available()
		mirror_run = False
		while nextupdate:
			ucr.handler_set( [ 'repository/mirror/version/end=%s' % nextupdate ] )
			mirror.run()
			mirror_run = True
			nextupdate = mirror.release_update_available( nextupdate )
		if not mirror_run:
			# sync only
			mirror.run()

	# create .univention_install file
	if not os.path.isfile( os.path.join( _mirror_base, '.univention_install' ) ):
		exp_version = re.compile( '(?P<major>[0-9]*)\.(?P<minor>[0-9]*)' )
		repo_base = os.path.join( _mirror_base, 'mirror' )
		min_version = None
		new_version = UCS_Version( ( 0, 0, 0 ) )

		for dirname in os.listdir( os.path.join( repo_base ) ):
			if not os.path.isdir( os.path.join( repo_base, dirname ) ):
				continue
			match = exp_version.match( dirname )
			if not match:
				continue
			regdict = match.groupdict()
			new_version.major = int( regdict[ 'major' ] )
			new_version.minor = int( regdict[ 'minor' ] )
			if not min_version or new_version < min_version:
				min_version = copy.copy( new_version )

		inst_fd = open( os.path.join( _mirror_base, '.univention_install' ), 'w' )
		inst_fd.write( 'VERSION=%d.%d\n' % ( min_version.major, min_version.minor ) )
		inst_fd.write( 'PATCHLEVEL=0\n' )
		inst_fd.close()

if __name__ == '__main__':
	# FIXME: no clue why we need this
	os.putenv('PATH', '/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/bin/X11')

	parser = OptionParser( usage = "usage: %prog (net|cdrom) [options] " )
	parser.add_option( '-i', '--iso', action = 'store',
					   dest = 'iso_file',
					   help = 'define filename of an ISO image' )
	parser.add_option( '-d', '--device', action = 'store',
					   dest = 'device',
					   help = 'defines the device name of the CD-ROM drive' )
	parser.add_option( '-c', '--cdrom', action = 'store',
					   dest = 'mount_point', default = '/cdrom',
					   help = 'devices mount point for CD-ROM drive' )
	parser.add_option( '-s', '--sync-only', action = 'store_true',
					   dest = 'sync', default = False,
					   help = 'if given no new release repositories will be added, just the existing will be updated' )
	parser.add_option( '-S', '--security-only', action = 'store_true',
					   dest = 'security_only', default = False,
					   help = 'if given only security repositories will be updated' )
	parser.add_option( '-u', '--updateto', action = 'store',
					   dest = 'update_to', default = '',
					   help = 'if given the repository is updated to the specified version but not higher' )

	( options, arguments ) = parser.parse_args()

	if not arguments or len( arguments ) != 1:
		print >> sys.stderr, 'Error: A command is required'
		parser.print_usage()
		sys.exit( 1 )
	elif not arguments[ 0 ] in ( 'net', 'cdrom' ):
		print >> sys.stderr, "Error: Unknown command '%s' specified" % arguments[ 0 ]
		parser.print_usage()
		sys.exit( 1 )

	command = arguments[ 0 ]
	# redirect output to logfile
	options.logfile = open('/var/log/univention/repository.log', 'a+')
	options.stdout = sys.stdout
	options.teefile = urepo.TeeFile( ( options.stdout, options.logfile ) )

	print '***** Starting univention-repository-update at %s\n' % time.ctime()

	if not configRegistry.get( 'local/repository', 'yes' ).lower() in ( 'yes','true' ):
		print >>options.teefile, 'Error: The local repository is disabled. To create a local repository use univention-repository-create.'
		sys.exit( 1 )

	# if there is no _new_ repository server -> exit
	if configRegistry.has_key( 'repository/local/old' ):
		print >> options.teefile, 'The repository server directory structure has been changed with UCS 2.2-0. The local repository still has the old strucuture and can not be used for updates anymore. Please migrate the repository to the new directory structure or disable the local reposito by setting the UCR variables local/repository to no. Information on how to migrate the repository can be found in the release notes for UCS 2.2-0'
		sys.exit( 1 )

	print 'Mirror Source: %s' % configRegistry['repository/mirror/server']

	if command == 'net':
		local_server='%s.%s' % (configRegistry['hostname'], configRegistry['domainname'])

		if configRegistry['repository/mirror/server'] == local_server:
			print >> options.teefile, 'Error: The local server is configured as mirror source server (repository/mirror/server)'
			sys.exit(1)

		update_net( options )
	elif command == 'cdrom':
		update_cdrom( options )
	else:
		if command == 'local':
			print >> options.teefile, 'Error: This mode is not supported anymore'
		else:
			print >> options.teefile, 'Error: Unknown mode %s' % command
		parser.print_usage()
		sys.exit( 1 )
