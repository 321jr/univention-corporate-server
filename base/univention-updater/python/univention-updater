#!/usr/bin/python2.4
#
# Univention Updater
#  A tool for installing UCS release updates
#
# Copyright (C) 2004-2010 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# Binary versions of this file provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

# The following commands are supported:
#  * local
#  * cdrom
#  * net

import os, sys, time, re
import string
import getopt
import tempfile
import shutil
import subprocess
import traceback
import socket
import datetime

import univention_baseconfig

from univention.updater import UniventionUpdater, UCS_Version
from univention.updater.tools import LocalUpdater

# TODO:
#   * check the local repository path /var/lib/univention-reposiotry
#   * changed variable update/server to repository/online/server

failure = '/var/lib/univention-updater/update-failed'
reboot_required = '/var/lib/univention-updater/reboot-required'
TMPSOURCE = '/etc/apt/sources.list.d/00_ucs_temporary_installation.list'

LOGNAME = '/var/log/univention/updater.log'
fd_log = sys.stderr

class UpdateError(Exception):
	""" Exception to signal errors on update """
	def __init__(self, msg=None):
		Exception.__init__(self, msg)

class UpToDateNoError(Exception):
	""" Exception to signal when no update needs to be done """
	def __init__(self, value=None):
		Exception.__init__(self, value)
		self.reboot = value

def log(str):
	""" Log message to LOGNAME. """
	print >>fd_log, str
	fd_log.flush()

def dprint(str):
	""" Print message to stdout and LOGNAME. """
	for fd in (sys.stdout, fd_log):
		print >>fd, str
		fd.flush()

def usage(fd=sys.stdout):
	""" Print usage message. """
	print >>fd, 'univention-updater: tool for updating local system'
	print >>fd, 'Copyright (c) 2005-2010 Univention GmbH, Germany'
	print >>fd, ''
	print >>fd, 'Syntax:'
	print >>fd, '  univention-updater <local,net,cdrom> [--device <cdrom device>] [--cdrom <cdrom mount point>] [--iso <iso-image>] [--updateto <UCS-Release>] [--reboot <timespec>] [--no-clean] [--check] '
	print >>fd, '  univention-updater [--help] '
	print >>fd, ''
	print >>fd, 'Known-Bugs:'
	print >>fd, '  -None-'
	print >>fd, ''

def deactivateSourcesListMethods( methods = [ 'cdrom' ] ):
	""" Rewrite sources.list deactivating all stanzas using any of the specified methods. """
	cnt = 0
	lines = []
	deactivated_lines = []
	f = open('/etc/apt/sources.list', 'r')
	for line in f.readlines():
		line=line.strip(' \n\t')
		for method in methods:
			if line.startswith( 'deb %s:' % method ) or line.startswith( 'deb-src %s:' % method ):
				line = '#%s' % line
				deactivated_lines.append(line)
				cnt += 1
		lines.append(line)
	f.close()
	if cnt:
		f = open('/etc/apt/sources.list', 'w')
		f.write( '\n'.join( lines ) )
		f.write( '\n' )
		f.close()
		log('Hint: deactivated %d lines in /etc/apt/sources.list:\n' % cnt)
		log( '   %s\n' % '\n   '.join(deactivated_lines) )

def add_temporary_sources_list ( debline ):
	""" Add line to a temporary sources.list. """
	fp = open(TMPSOURCE, 'a+')
	fp.write(debline+'\n')
	fp.close()

def remove_temporary_sources_list ():
	""" Add the temporary sources.list. """
	if os.path.exists(TMPSOURCE):
		os.remove(TMPSOURCE)

def copy_sh_files(tempdir,path):
	""" Copy pre- and postup.sh from tempdir to path. """
	for sh in ['preup.sh', 'postup.sh']:
		if os.path.exists(os.path.join(tempdir,sh)):
			os.remove(os.path.join(tempdir,sh))
		if os.path.exists(os.path.join(path,sh)):
			shutil.copy(os.path.join(path,sh), os.path.join(tempdir,sh))
			os.chmod(os.path.join(tempdir, sh), 0744)

def download_sh_files(updater, server_path, tempdir):
	""" Retrieve pre- und postup.sh from remote repository into tempdir. """
	for sh in ['preup.sh', 'postup.sh']:
		if os.path.exists(os.path.join(tempdir,sh)):
			os.remove(os.path.join(tempdir,sh))

		proxy_headers = updater.open_connection()
		path="%s/%s" % ( server_path, sh )
		site = '%s/%s/%s' % (updater.proxy_prefix, updater.repository_prefix, path)
		replace_slash = re.compile ('[/]{2,}')
		site = replace_slash.sub ('/', site)
		if not site.startswith ('http://') and proxy_headers != None:
			site = 'http://%s' % site
		if proxy_headers != None:
			updater.connection.putrequest('GET', site, skip_accept_encoding=1)
		else:
			updater.connection.putrequest('GET', site)

		if proxy_headers != None:
			for k, v in proxy_headers.items ():
				updater.connection.putheader (k, v)
		try:
			updater.connection.endheaders ()
			response = updater.connection.getresponse()
			response_data = response.read()

			if response.status != 200:
				log('failed to download %s' % path)
				log(' %s: %s' % (response.status,response.reason))
				continue
		except:
			log( traceback.format_exc ())

		f=open(os.path.join(tempdir, sh), 'w+' )
		f.write(response_data)
		f.close()
		os.chmod(os.path.join(tempdir, sh), 0744)

		updater.close_connection()


def update_available(mode, baseConfig, cdrom_mount_point, iso=None, updater=None):
	""" Checks if there is an update available.
	Returns the next version, or None if up-to-date, or throws an UpdateError if the next version can not be identified."""

	log('--->DBG:update_available(mode=%s, cdrom_mount_point=%s, iso=%s)' %(mode, cdrom_mount_point, str(iso)))

	nextversion = None

	vv=baseConfig['version/version']
	vp=baseConfig['version/patchlevel']
	(version_major, version_minor) = vv.split('.')[0:2]

	if mode == 'local':
		dprint('Checking local repository')

		updater = LocalUpdater()
		if updater.net_path_exists(''):
			nextversion = updater.release_update_available()
		else:
			raise UpdateError('A local repository was not found.\n' +
					'       Please check the UCR variable repository/mirror/basepath\n' +
					'       or try to install via "univention-updater net"')

	elif mode == 'cdrom':
		if iso:
			device_name="ISO image"

			dprint('Mounting the ISO image %s' % iso)

			resultCode=os.system('mount -o loop %s %s' % ( iso, cdrom_mount_point))
			if resultCode not in (0,32):
				res=os.system('mount -l 2>>%s | grep -q " %s "' % (LOGNAME, cdrom_mount_point))
				if res != 0:
					raise UpdateError('Failed to mount %s' % iso)
		else:
			device_name="cdrom"

			dprint('Mounting cdrom %s' % cdrom_mount_point)

			resultCode=os.system('mount %s' % ( cdrom_mount_point))
			if resultCode not in (0,32):
				res=os.system('mount -l 2>>%s | grep -q " %s "' % (LOGNAME, cdrom_mount_point))
				if res != 0:
					raise UpdateError('Failed to mount cdrom')
		try:
			# Let's check if this Update could be installed, as on the dvd is a textfile for which UCS release this update is
			if os.path.exists('%s/ucs-updates/' % cdrom_mount_point):
				if os.path.exists('%s/ucs-updates/ucs_%s-%s.txt' % (cdrom_mount_point,vv,vp)):
					f=open('%s/ucs-updates/ucs_%s-%s.txt' % (cdrom_mount_point,vv,vp))
					nextversion=string.lower(f.readline().strip('\n').replace('nextupdate=',''))
					f.close()
				else:
					raise UpdateError("%s does not contain an update for version %s-%s."%(device_name,vv,vp))
			else:
				raise UpdateError("%s is not a valid UCS update medium" % device_name)
		finally:
			resultCode=subprocess.call(['umount', cdrom_mount_point])
			if resultCode != 0:
				res=os.system('mount -l 2>>%s | grep -q " %s "' % (LOGNAME, cdrom_mount_point))
				if res == 0:
					dprint('Warning: Failed to unmount %s' % device_name)
			if nextversion:
				ver = UCS_Version(nextversion)
				mm_version = UCS_Version.FORMAT % ver
				updater = LocalUpdater()
				components = filter(lambda c: 'current' in baseConfig.get('repository/online/component/%s/version' % c, '').split(','), updater.get_components())
				for component in components:
					if not updater.get_component_repositories(component, [mm_version], False):
						raise UpdateError('The required component %s is missing for version %s.' % (component, mm_version))

	elif mode == 'net':
		try:
			dprint('Checking network repository')
			updater = UniventionUpdater()
			nextversion = updater.release_update_available()
		except socket.gaierror, msg:
			log(traceback.format_exc ())

			code, message = msg

			if code == socket.EAI_NONAME:
				raise UpdateError('The name %s is not known.\n       Please check your network settings or set the UCR variable repository/online/server to a different value.' % (updater.repository_server))
			else:
				raise UpdateError('An error occured during the connection to %s.\n       Please check your network settings.' % updater.repository_server)

	if nextversion in (None,'none'):
		return None
	else:
		return nextversion


def main():
	os.putenv('PATH', '/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/bin/X11')

	cdrom_mount_point='/cdrom'
	iso=None

	log('**** Starting univention-updater with parameter=%s' % sys.argv)

	if len(sys.argv) < 2:
		usage(sys.stderr)
		sys.exit(2)

	if sys.argv[1] == 'net':
		command='net'
	elif sys.argv[1] == 'cdrom':
		command='cdrom'
	elif sys.argv[1] == 'local':
		command='local'
	else:
		usage(sys.stderr)
		sys.exit(2)

	updateto=None
	updateto_args = []
	reboot = None
	clean  = True

	longopts=['src=','device=', 'cdrom=', 'iso=', 'updateto=', 'reboot=', 'no-clean', 'check']
	try:
		opts, args=getopt.getopt(sys.argv[2:], '', longopts)
	except getopt.error, msg:
		dprint(msg)
		sys.exit(2)

	baseConfig=univention_baseconfig.baseConfig()
	baseConfig.load()
	for opt, val in opts:
		if opt == '--src':
			dprint('Warning: --src is deprecated; value is ignored.')
		elif opt == "--device":
			dprint('Warning: --device is deprecated; value is ignored.')
		elif opt == "--cdrom":
			cdrom_mount_point=val
		elif opt == "--iso":
			iso=val
		elif opt == "--updateto":
			updateto=val
		elif opt == '--reboot':
			if val:
				reboot = val
			else:
				reboot = 'now'
		elif opt == "--no-clean":
			clean = False
			dprint("Running updater without apt-get clean")
		elif opt == '--check':
			try:
				nextversion = update_available(command, baseConfig, cdrom_mount_point, iso=iso)
				if nextversion:
					dprint('Next version is %s' % nextversion)
					sys.exit(1)
			except UpdateError, msg:
				dprint("Error: %s" % msg)
				print >>sys.stderr, 'Error: Please check "%s" for details.' % LOGNAME
				# Errors are handles as "update currently no available"
			else:
				dprint('System is up to date') # Sync with /etc/cron.d/univention-maintenance
			sys.exit(0)
		else:
			dprint('Unknown parameter: "%s"'%opt)
			sys.exit(2)

	deactivateSourcesListMethods( methods = [ 'cdrom' ] )

	# save the path for the pre- and postup scripts,
	# this path will be different for the different modes
	scriptPath = None

	if clean:
		os.system('apt-get clean')

	vv=baseConfig['version/version']
	vp=baseConfig['version/patchlevel']

	lastversion='%s-%s' % (vv,vp)
	nextversion=None

	if updateto:
		if UCS_Version(updateto) <= UCS_Version(lastversion):
			dprint('System is up to date (UCS %s)' % lastversion)
			raise UpToDateNoError(reboot)
		updateto_args = [ '--updateto', updateto ]

	log('Version=%s' % vv)
	log('Patchlevel=%s' % vp)

	tempdir=tempfile.mktemp()
	os.mkdir(tempdir)

	log('using tempdir = %s' % tempdir)

	architecture=os.popen('dpkg-architecture -qDEB_BUILD_ARCH 2>/dev/null').readline()[:-1]

	# if there is no _new_ repository server -> exit
	if baseConfig.get( 'local/repository', '' ).lower() in ( 'yes', 'true' ) and baseConfig.has_key( 'repository/local/old' ):
		dprint( 'The repository server directory structure has been changed with UCS 2.2-0. The local repository still has the old structure and can not be used for updates anymore. Please migrate the repository to the new directory structure or disable the local repository by setting the UCR variable local/repository to "no". Information on how to migrate the repository can be found in the release notes for UCS 2.2-0')
		sys.exit( 1 )


	if command == 'local':
		log('starting local mode')

		nextversion = update_available('local', baseConfig, cdrom_mount_point, iso=iso)
		if not nextversion:
			dprint('System is up to date (UCS %s)' % lastversion)
			raise UpToDateNoError(reboot)

		dprint('Update to = %s' % nextversion)

		updater = LocalUpdater()
		temporary_sources_list = updater.release_update_temporary_sources_list(nextversion)
		remove_temporary_sources_list()
		add_temporary_sources_list('\n'.join(temporary_sources_list))

		repository_path = baseConfig.get('repository/mirror/basepath', '/var/lib/univention-repository')
		new_version = UCS_Version(nextversion)
		scriptPath = '%s/mirror/%d.%d/maintained/%s/all/' % ( repository_path, new_version.major, new_version.minor, nextversion )

	elif command == 'cdrom':
		log('starting cdrom mode')
		if iso:
			device_name="ISO image"
		else:
			device_name="cdrom"

		nextversion = update_available('cdrom', baseConfig, cdrom_mount_point, iso=iso)

		if not nextversion:
			dprint('System is up to date (UCS %s)' % lastversion)
			raise UpToDateNoError(reboot)

		dprint('Update to = %s' % nextversion)

		if baseConfig.get('local/repository', 'no').lower() in ('true', 'yes', '1'):
			log('local/reposity active, copy %s and start local mode' % device_name)
			if iso:
				resultCode = subprocess.call( [ '/usr/sbin/univention-repository-update', 'cdrom', '--cdrom', cdrom_mount_point, '--iso', iso ] + updateto_args )
			else:
				resultCode = subprocess.call( [ '/usr/sbin/univention-repository-update', 'cdrom', '--cdrom', cdrom_mount_point ] + updateto_args )

			if resultCode != 0:
				raise UpdateError('Failed to execute "univention-repository-update cdrom"')

			calllocal = [sys.argv[0], 'local']
			if updateto:
				calllocal += ['--updateto', updateto]
			if not clean:
				calllocal.append('--no-clean')
			os.execv(sys.argv[0], calllocal)
		else:
			dprint('Error: You are trying to install from a cdrom/dvd image')
			dprint('       but a local repository was not found. If you want to')
			dprint('       update via an ISO image you need to create a local')
			dprint('       repository (/usr/sbin/univention-repository-create)')
			dprint('       or try to install via "univention-updater net"')
			sys.exit( 1 )
	elif command == 'net':
		log('starting net mode')
		list=[]
		if baseConfig.get('local/repository', 'no').lower() in ('true', 'yes', '1'):
			log('local/repository active, copy from net and start local mode')
			resultCode = subprocess.call( [ '/usr/sbin/univention-repository-update', 'net' ] + updateto_args )
			if resultCode != 0:
				raise UpdateError('Failed to execute "univention-repository-update net"')

			calllocal = [sys.argv[0], 'local']
			if updateto:
				calllocal += ['--updateto', updateto]
			if not clean:
				calllocal.append('--no-clean')
			os.execv(sys.argv[0], calllocal)

		updater = UniventionUpdater()

		nextversion = update_available('net', baseConfig, cdrom_mount_point, iso=iso, updater=updater)
		if not nextversion:
			dprint('System is up to date (UCS %s)' % lastversion)
			raise UpToDateNoError(reboot)

		dprint('Update to = %s' % nextversion)

		(next_vv, next_vp) = nextversion.split('-')[0:2]

		remove_temporary_sources_list()
		temporary_sources_list = updater.release_update_temporary_sources_list(nextversion)
		add_temporary_sources_list('\n'.join(temporary_sources_list))

		# Download the pre and postup scripts
		scriptPath = tempdir
		download_sh_files(updater, '%s/maintained/%s-%s/all' % (next_vv, next_vv, next_vp), tempdir)

	log('**** Starting actual update at %s' % datetime.datetime.now ().ctime ())

	# Call the preup.sh
	if scriptPath:
		log('Call the preup.sh file with the path: %s' % scriptPath)
		if os.path.exists(os.path.join(scriptPath, 'preup.sh')):
			log('Execute %s' % os.path.join(scriptPath, 'preup.sh'))
			os.chmod(os.path.join(scriptPath, 'preup.sh'), 0744)
			preup = subprocess.Popen((os.path.join(scriptPath, 'preup.sh'), lastversion, nextversion), stdout=subprocess.PIPE, stderr=subprocess.STDOUT )
			tee = subprocess.Popen(('tee', '-a', LOGNAME), stdin=preup.stdout)
			# Order is important! See bug #16454
			tee.wait()
			preup.wait()
			if preup.returncode != 0:
				raise UpdateError('Failed to execute "preup.sh"')

	count=0
	while os.path.exists('/var/run/apt-get.lock') and count < 300:
		time.sleep(1)
		count=count+1

	# TODO: should we really exit if the 'apt-get update' process failed?
	cmd_update = baseConfig.get( 'update/commands/update', 'apt-get update' )
	resultCode=os.system('touch /var/run/apt-get.lock && %s >>%s 2>&1' % (cmd_update, LOGNAME))
	if os.path.exists('/var/run/apt-get.lock'):
		os.unlink('/var/run/apt-get.lock')
	if resultCode != 0:
		raise UpdateError('Failed to execute "%s"' % cmd_update)

	# Execute the dist-upgrade!
	count=0
	while os.path.exists('/var/run/apt-get.lock') and count < 300:
		time.sleep(1)
		count=count+1

	cmd_dist_upgrade = baseConfig.get( 'update/commands/distupgrade', 'apt-get -o DPkg::Options::=--force-confold -o DPkg::Options::=--force-overwrite -o DPkg::Options::=--force-overwrite-dir -y --force-yes -u dist-upgrade' )
	resultCode=os.system('touch /var/run/apt-get.lock && DEBIAN_FRONTEND=noninteractive %s >>%s 2>&1' % (cmd_dist_upgrade, LOGNAME))
	if os.path.exists('/var/run/apt-get.lock'):
		os.unlink('/var/run/apt-get.lock')
	if resultCode != 0:
		raise UpdateError('Failed to execute "%s"' % cmd_dist_upgrade)

	# Call the postup.sh
	if scriptPath:
		log('Call the postup.sh file with the path: %s' % scriptPath)
		if os.path.exists(os.path.join(scriptPath, 'postup.sh')):
			log('Execute %s' % os.path.join(scriptPath, 'postup.sh'))
			os.chmod(os.path.join(scriptPath, 'postup.sh'), 0744)
			postup = subprocess.Popen((os.path.join(scriptPath, 'postup.sh'), lastversion, nextversion), stdout=subprocess.PIPE, stderr=subprocess.STDOUT )
			tee = subprocess.Popen(('tee', '-a', LOGNAME), stdin=postup.stdout)
			# Order is important! See bug #16454
			tee.wait()
			postup.wait()
			if postup.returncode != 0:
				raise UpdateError('Failed to execute "postup.sh"')

	(nvv,nvp)=nextversion.split('-')[0:2]

	out=univention_baseconfig.handler_set(['version/version=%s' % nvv, 'version/patchlevel=%s' % nvp])
	remove_temporary_sources_list()

	if os.path.exists('/usr/sbin/univention-pkgdb-scan'):
		os.system('/usr/sbin/univention-pkgdb-scan >>%s 2>&1' % LOGNAME)

	if os.path.exists(failure):
		os.unlink(failure)
	subprocess.call(['touch', reboot_required])
	os.execv(sys.argv[0], sys.argv)

if __name__ == '__main__':
	if '-h' in sys.argv or '-?' in sys.argv or '--help' in sys.argv:
		usage()
		sys.exit(0)

	fd_log = open(LOGNAME, 'a+')
	try:
		try:
			main()
		except UpdateError, msg:
			dprint("Error: %s" % msg)
			print >>sys.stderr, 'Error: Please check "%s" for details.' % LOGNAME
			subprocess.call(['touch', failure])
			# set executable flags for apache and UMC
			devnull = open( '/dev/null', 'w' )
			for prog in ( 'apache2', 'univention-management-console-server' ):
				filename = os.path.join( '/usr/sbin/', prog )
				if os.path.isfile( filename ):
					os.chmod( filename, 0755 )
					subprocess.call( ( 'dpkg-statoverride', '--remove', filename ), stdout = devnull, stderr = devnull )
			remove_temporary_sources_list()
			devnull.close()
			sys.exit(1)
		except UpToDateNoError, error:
			if os.path.exists(failure):
				os.unlink(failure)
			if os.path.exists(reboot_required):
				os.unlink(reboot_required)
				if error.reboot is not None:
					os.system('at -f /var/lib/univention-updater/reboot.at -- %s' % error.reboot)
			sys.exit(0)
	finally:
		fd_log.close()
