#!/usr/bin/python2.4
#
# Univention Updater
#  A tool for installing UCS release updates
#
# Copyright (C) 2004-2009 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# Binary versions of this file provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

# The following commands are supported:
#  * local
#  * cdrom
#  * net

import os, sys, time, re
import string
import getopt
import tempfile
import shutil
import subprocess
import traceback
import socket
import datetime

import univention_baseconfig

from univention.updater import UniventionUpdater, UCS_Version

# TODO:
#   * check the local repository path /var/lib/univention-reposiotry
#   * changed variable update/server to repository/online/server

failure = '/var/lib/univention-updater/update-failed'
reboot_required = '/var/lib/univention-updater/reboot-required'

class UpdateError(Exception):
	pass

class UpToDateNoError(Exception):
	def __init__(self, value=None):
		Exception.__init__(self, value)
		self.reboot = value

def dprint(str, fd=[]):
	if len(fd) < 1:
		print str
		sys.stdout.flush()
	for i in range(0,len(fd)):
		print >>fd[i], str
		fd[i].flush()

def usage(fd=sys.stdout):
	print >>fd, 'univention-updater: tool for updating local system'
	print >>fd, 'copyright (c) 2005-2009 Univention GmbH, Germany'
	print >>fd, ''
	print >>fd, 'Syntax:'
	print >>fd, '  univention-updater <local,net,cdrom> [--device <cdrom device>] [--cdrom <cdrom mount point>] [--iso <iso-image>] [--updateto <UCS-Release>] [--reboot <timespec>] [--no-clean] [--check] '
	print >>fd, '  univention-updater [--help] '
	print >>fd, ''
	print >>fd, 'Known-Bugs:'
	print >>fd, '  -None-'
	print >>fd, ''

def deactivateSourcesListMethods( methods = [ 'cdrom' ] ):
	cnt = 0
	lines = []
	deactivated_lines = []
	f = open('/etc/apt/sources.list', 'r')
	for line in f.readlines():
		line=line.strip(' \n\t')
		for method in methods:
			if line.startswith( 'deb %s:' % method ) or line.startswith( 'deb-src %s:' % method ):
				line = '#%s' % line
				deactivated_lines.append(line)
				cnt += 1
		lines.append(line)
	f.close()
	if cnt:
		f = open('/etc/apt/sources.list', 'w')
		f.write( '\n'.join( lines ) )
		f.write( '\n' )
		f.close()
		dprint('Hint: deactivated %d lines in /etc/apt/sources.list:\n' % cnt)
		dprint( '   %s\n' % '\n   '.join(deactivated_lines) )

def add_temporary_sources_list ( debline ):
	filename = '/etc/apt/sources.list.d/00_ucs_temporary_installation.list'
	fp = open(filename, 'a+')
	fp.write(debline+'\n')
	fp.close()

def remove_temporary_sources_list ():
	filename = '/etc/apt/sources.list.d/00_ucs_temporary_installation.list'
	if os.path.exists(filename):
		os.remove(filename)


def copy_sh_files(tempdir,path):
	for sh in ['preup.sh', 'postup.sh']:
		if os.path.exists(os.path.join(tempdir,sh)):
			os.remove(os.path.join(tempdir,sh))
		if os.path.exists(os.path.join(path,sh)):
			shutil.copy(os.path.join(path,sh), os.path.join(tempdir,sh))
			os.chmod(os.path.join(tempdir, sh), 0744)

def download_sh_files(updater, server_path, tempdir):
	for sh in ['preup.sh', 'postup.sh']:
		if os.path.exists(os.path.join(tempdir,sh)):
			os.remove(os.path.join(tempdir,sh))

		proxy_headers = updater.open_connection()
		path="%s/%s" % ( server_path, sh )
		site = '%s/%s/%s' % (updater.proxy_prefix, updater.repository_prefix, path)
		replace_slash = re.compile ('[/]{2,}')
		site = replace_slash.sub ('/', site)
		if not site.startswith ('http://') and proxy_headers:
			site = 'http://%s' % site
		if proxy_headers:
			updater.connection.putrequest('GET', site, skip_host=1, skip_accept_encoding=1)
		else:
			updater.connection.putrequest('GET', site)

		if proxy_headers:
			for k, v in proxy_headers.items ():
				updater.connection.putheader (k, v)
		try:
			updater.connection.endheaders ()
			response = updater.connection.getresponse()
			response_data = response.read()

			if response.status != 200:
				dprint('failed to download %s' % path)
				dprint(' %s: %s' % (response.status,response.reason))
				continue
		except:
			dprint( traceback.format_exc ())

		f=open(os.path.join(tempdir, sh), 'w+' )
		f.write(response_data)
		f.close()
		os.chmod(os.path.join(tempdir, sh), 0744)

		updater.close_connection()


def update_available(mode, baseConfig, cdrom_mount_point, sourcedir, stdout, sys_stdout, reboot, internal=1, iso=None, updater=None):
	# Checks if there is an update available

	dprint('--->DBG:update_available(mode=%s, cdrom_mount_point=%s, reboot=%s, internal=%s, iso=%s)' %(mode, cdrom_mount_point, str(reboot), str(internal), str(iso)))

	update=0
	nextversion = None

	vv=baseConfig['version/version']
	vp=baseConfig['version/patchlevel']
	version_major = vv.split('.')[0]
	version_minor = vv.split('.')[-1]

	if mode == 'local':

		print 'Checking local repository'

		repository_path = baseConfig.get( 'repository/mirror/basepath', '/var/lib/univention-repository')

		if os.path.exists( repository_path ):
			repo_base = '%s/mirror/' % repository_path
			if os.path.exists( os.path.join( repo_base, vv, 'maintained', '%s-%d' % ( vv, int( vp ) + 1 ) ) ): #check for x.y-(z+1)
				nextversion = '%s-%d' % (vv, int(vp)+1)
			elif os.path.exists( os.path.join( repo_base, '%s.%d' % ( version_major, int( version_minor ) + 1 ), 'maintained', '%s.%d-0' % ( version_major, int( version_minor ) + 1 ) ) ): #check for x.(y+1)-0
				nextversion = '%s.%d-0' % (version_major, int(version_minor)+1)
			elif os.path.exists(os.path.join( repo_base, '%d.0' % ( int( version_major ) + 1 ), 'maintained', '%d.0-0' % ( int( version_major ) + 1 ) ) ): #check for (x+1).0-0
				nextversion = '%d.0-0' % (int(version_major)+1)

			if not nextversion:
				update=0
				dprint('System is up to date (UCS %s-%s)' % (vv,vp), [stdout,sys_stdout])
				if internal:
					sys_stdout.close()
					raise UpToDateNoError(reboot)
			else:
				dprint('Next version is %s' % nextversion, [stdout,sys_stdout])
				update=1

		else:
			dprint('Error: A local repository was not found.', [stdout,sys_stdout])
			dprint('       Please check the UCR variable repository/mirror/basepath', [stdout,sys_stdout])
			dprint('       or try to install via "univention-updater net"', [stdout,sys_stdout])
			update=0
			if internal:
				sys_stdout.close()
				raise UpToDateNoError(reboot)

	elif mode == 'cdrom':
		if iso:
			device_name="ISO image"

			dprint('Mounting the ISO image %s' % iso, [stdout,sys_stdout])

			resultCode=os.system('mount -o loop %s %s' % ( iso, cdrom_mount_point))
			if resultCode != 0:
				res=os.system('mount -l | grep " %s " >>/var/log/univention/updater.log 2>&1' % (cdrom_mount_point))
				if res != 0:
					dprint('Failed to mount %s' % iso, [stdout,sys_stdout])
					update=0
					if internal:
						sys_stdout.close()
						raise UpdateError
		else:
			device_name="cdrom"

			dprint('Mounting cdrom %s' % cdrom_mount_point, [stdout,sys_stdout])

			resultCode=os.system('mount %s' % ( cdrom_mount_point))
			if resultCode != 0:
				res=os.system('mount -l | grep " %s " >>/var/log/univention/updater.log 2>&1' % (cdrom_mount_point))
				if res != 0:
					dprint('Failed to mount cdrom', [stdout,sys_stdout])
					update=0
					if internal:
						sys_stdout.close()
						raise UpdateError

		# Let's check if this Update could be installed, as on the dvd is a textfile for which UCS release this update is
		if os.path.exists('%s/ucs-updates/' % cdrom_mount_point):
			if os.path.exists('%s/ucs-updates/ucs_%s-%s.txt' % (cdrom_mount_point,vv,vp)):
				f=open('%s/ucs-updates/ucs_%s-%s.txt' % (cdrom_mount_point,vv,vp))
				nextversion=string.lower(f.readline().strip('\n').replace('nextupdate=',''))
				f.close()
				if nextversion == 'none':
					update=0
					dprint('System is up to date (UCS %s-%s)' % (vv,vp), [stdout,sys_stdout])
					# No raise because we need to return none
				else:
					dprint('Next version is %s' % nextversion, [stdout,sys_stdout])
					update=1
			else:
				update=0
				dprint("%s does not contain an update for version %s-%s."%(device_name,vv,vp), [stdout,sys_stdout])
				if internal:
					sys_stdout.close()
					raise UpdateError
		else:
			update=0
			dprint("%s is not a valid UCS update medium" % device_name, [stdout,sys_stdout])
			if internal:
				sys_stdout.close()
				raise UpdateError

		resultCode=os.system('umount %s' % ( cdrom_mount_point))
		if resultCode != 0:
			res=os.system('umount -l | grep " %s " >>/var/log/univention/updater.log 2>&1' % (cdrom_mount_point))
			if res != 0:
				dprint('Failed to unmount %s' % device_name, [stdout,sys_stdout])


	elif mode == 'net':
		try:
			updater = UniventionUpdater()
			nextversion = updater.release_update_available()
		except socket.gaierror, msg:
			dprint(traceback.format_exc ())

			code, message = msg

			if code == socket.EAI_NONAME:
				dprint('Error: The name %s is not known.\n       Please check your network settings or set the UCR variable repository/online/server to a diffrent value.' % (updater.repository_server), [ sys.stdout, stdout ])
			else:
				dprint('Error: An error occurs during the connection to %s.\n       Please check your network settings and check the logfile /var/log/univention/updater.log' % (updater.repository_server), [ sys.stdout, stdout ])

			sys.exit( 1 )

		dprint('Nextupdate: [%s]' % nextversion)

		if not nextversion:
			dprint('System is up to date (UCS %s-%s)' % (vv,vp), [stdout,sys_stdout])
			sys_stdout.close()
			raise UpToDateNoError(reboot)

	return nextversion



def main():
	os.putenv('PATH', '/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/bin/X11')

	cdrom_device='/dev/cdrom'
	cdrom_mount_point='/cdrom'
	iso=None

	fp_debug=open('/var/log/univention/updater.log', 'a+')
	stdout=sys.stdout
	sys.stdout=fp_debug

	dprint('**** Starting univention-updater with parameter=%s' % sys.argv)

	if len(sys.argv) < 2:
		usage(stdout)
		fp_debug.close()
		sys.exit(2)

	if sys.argv[1] in ['-h', '-?', '--help']:
		usage(stdout)
		fp_debug.close()
		sys.exit(0)

	if sys.argv[1] == 'net':
		command='net'
	elif sys.argv[1] == 'cdrom':
		command='cdrom'
	elif sys.argv[1] == 'local':
		command='local'
	else:
		usage(stdout)
		fp_debug.close()
		sys.exit(2)

	updateto=None
	updateto_args = []
	reboot = None
	clean  = True

	longopts=['src=','device=', 'cdrom=', 'iso=', 'updateto=', 'reboot=', 'no-clean', 'check']
	try:
		opts, args=getopt.getopt(sys.argv[2:], '', longopts)
	except getopt.error, msg:
		dprint(msg, [stdout,sys.stdout])
		fp_debug.close()
		sys.exit(2)

	baseConfig=univention_baseconfig.baseConfig()
	baseConfig.load()
	sourcedir=None
	for opt, val in opts:
		if opt == '--src':
			sourcedir=val
		elif opt == "--device":
			cdrom_device=val
		elif opt == "--cdrom":
			cdrom_mount_point=val
		elif opt == "--iso":
			iso=val
		elif opt == "--updateto":
			updateto=val
		elif opt == '--reboot':
			if val:
				reboot = val
			else:
				reboot = 'now'
		elif opt == "--no-clean":
			clean = False
			dprint("Running updater without apt-get clean", [stdout,sys.stdout])
		elif opt == '--check':
			if update_available(command, baseConfig, cdrom_mount_point,sourcedir, stdout, sys.stdout, reboot, 0, iso=iso):
				sys.exit(1)
			else:
				sys.exit(0)
		else:
			dprint('Unknown Parameter: "%s"'%opt, [stdout,sys.stdout])
			fp_debug.close()
			sys.exit(2)

	deactivateSourcesListMethods( methods = [ 'cdrom' ] )

	# save the path for the pre- and postup scripts,
	# this path will be diffrent for the diffrent modes
	scriptPath = None

	if clean:
		os.system('apt-get clean')

	vv=baseConfig['version/version']
	vp=baseConfig['version/patchlevel']

	lastversion='%s-%s' % (vv,vp)
	nextversion=None

	if updateto:
		if UCS_Version(updateto) <= UCS_Version(lastversion):
			dprint('System is up to date (UCS %s)' % lastversion, [stdout,sys.stdout])
			fp_debug.close()
			raise UpToDateNoError(reboot)
		updateto_args = [ '--updateto', updateto ]

	dprint('Version=%s' % vv)
	dprint('Patchlevel=%s' % vp)

	tempdir=tempfile.mktemp()
	os.mkdir(tempdir)

	dprint('using tempdir = %s' % tempdir)

	architecture=os.popen('dpkg-architecture -qDEB_BUILD_ARCH 2>/dev/null').readline()[:-1]

	# if there is no _new_ repository server -> exit
	if baseConfig.get( 'local/repository', '' ).lower() in ( 'yes', 'true' ) and baseConfig.has_key( 'repository/local/old' ):
		dprint( 'The repository server directory structure has been changed with UCS 2.2-0. The local repository still has the old structure and can not be used for updates anymore. Please migrate the repository to the new directory structure or disable the local repository by setting the UCR variable local/repository to "no". Information on how to migrate the repository can be found in the release notes for UCS 2.2-0',  [ stdout, sys.stdout ] )
		sys.exit( 1 )


	if command == 'local':
		dprint('starting local mode')

		nextversion=update_available('local', baseConfig, cdrom_mount_point,sourcedir, stdout, sys.stdout, reboot, iso=iso)

		dprint('Update to = %s' % nextversion, [stdout, sys.stdout])

		repository_path = baseConfig.get( 'repository/mirror/basepath', '/var/lib/univention-repository')

		remove_temporary_sources_list()
		new_version = UCS_Version( nextversion )

		maintained_state_list = [ 'maintained' ]
		if baseConfig.get( 'repository/online/unmaintained', 'no').lower() in ('yes', 'true', '1'):
			maintained_state_list.append('unmaintained')

		for maintained in maintained_state_list:
			for arch in ['all', architecture, 'extern']:
				if os.path.exists('%s/mirror/%d.%d/%s/%s/%s' % ( repository_path, new_version.major, new_version.minor, maintained, nextversion, arch ) ):
					add_temporary_sources_list ( 'deb file:%s/mirror/%d.%d/%s/ %s/%s/' % ( repository_path, new_version.major, new_version.minor, maintained, nextversion, arch ) )
		scriptPath = '%s/mirror/%d.%d/maintained/%s/all/' % ( repository_path, new_version.major, new_version.minor, nextversion )

	elif command == 'cdrom':
		dprint('starting cdrom mode')
		if iso:
			device_name="ISO image"
		else:
			device_name="cdrom"

		nextversion=update_available('cdrom', baseConfig, cdrom_mount_point,sourcedir, stdout, sys.stdout, reboot, iso=iso)

		if not nextversion or nextversion == 'none':
			dprint('System is up to date (UCS %s-%s)' % (vv,vp), [stdout,sys.stdout])
			fp_debug.close()
			raise UpToDateNoError(reboot)

		dprint('Update to = %s' % nextversion, [stdout,sys.stdout])

		if baseConfig.has_key('local/repository') and ( baseConfig['local/repository'] == 'true' or baseConfig['local/repository'] == 'yes'):
			dprint('local/reposity active, copy %s and start local mode' % device_name)
			if iso:
				resultCode = subprocess.call( [ '/usr/sbin/univention-repository-update', 'cdrom', '--cdrom', cdrom_mount_point, '--iso', iso ] + updateto_args )
			else:
				resultCode = subprocess.call( [ '/usr/sbin/univention-repository-update', 'cdrom', '--cdrom', cdrom_mount_point ] + updateto_args )

			if resultCode != 0:
				dprint('Failed to execute univention-repository-update cdrom', [sys.stdout,stdout])
				raise UpdateError

			calllocal = [sys.argv[0], 'local']
			if updateto:
				calllocal += ['--updateto', updateto]
			if not clean:
				calllocal.append('--no-clean')
			os.execv(sys.argv[0], calllocal)
		else:
			dprint('Error: You are trying to install from a cdrom/dvd image', [stdout,sys.stdout])
			dprint('       but a local repository was not found. If you want to', [stdout,sys.stdout])
			dprint('       update via an ISO image you need to create a local', [stdout,sys.stdout])
			dprint('       repository (/usr/sbin/univention-repository-create)', [stdout,sys.stdout])
			dprint('       or try to install via "univention-updater net"', [stdout,sys.stdout])
			sys.exit( 1 )
	elif command == 'net':
		dprint('starting net mode')
		list=[]
		if baseConfig.has_key('local/repository') and ( baseConfig['local/repository'] == 'true' or baseConfig['local/repository'] == 'yes'):
			dprint('local/repository active, copy from net and start local mode')
			resultCode = subprocess.call( [ '/usr/sbin/univention-repository-update', 'net' ] + updateto_args )
			if resultCode != 0:
				dprint('Failed to execute univention-repository-update net', [sys.stdout,stdout])
				raise UpdateError

			calllocal = [sys.argv[0], 'local']
			if updateto:
				calllocal += ['--updateto', updateto]
			if not clean:
				calllocal.append('--no-clean')
			os.execv(sys.argv[0], calllocal)

		updater = UniventionUpdater()

		nextversion=update_available('net', baseConfig, cdrom_mount_point,sourcedir, stdout, sys.stdout, reboot, iso=iso, updater=updater)

		dprint('Update to = %s' % nextversion, [stdout, sys.stdout])


		next_vv = nextversion.split('-')[0]
		next_vp = nextversion.split('-')[-1]

		remove_temporary_sources_list()

		maintained_state_list = [ 'maintained' ]
		if baseConfig.get( 'repository/online/unmaintained', 'no').lower() in ('yes', 'true', '1'):
			maintained_state_list.append('unmaintained')

		for maintained in maintained_state_list:
			for arch in ['all', architecture, 'extern' ]:
				if updater.net_path_exists('%s/%s/%s-%s/%s/' % (next_vv, maintained, next_vv, next_vp, arch)):
					if updater.repository_prefix:
						add_temporary_sources_list ('deb http://%s/%s/%s/%s/ %s/%s/' % ( updater.repository_server, updater.repository_prefix, next_vv, maintained, nextversion, arch))
					else:
						add_temporary_sources_list ('deb http://%s/%s/%s/ %s/%s/' % ( updater.repository_server, next_vv, maintained, nextversion, arch))

		# Download the pre and postup scripts
		scriptPath = tempdir
		download_sh_files(updater, '%s/%s/maintained/%s-%s/all' % (updater.repository_prefix, next_vv, next_vv, next_vp), tempdir)

	dprint('**** Starting actual update at %s' % datetime.datetime.now ().ctime ())

	# Call the preup.sh
	if scriptPath:
		dprint('Call the preup.sh file with the path: %s' % scriptPath)
		if os.path.exists(os.path.join(scriptPath, 'preup.sh')):
			dprint('Execute %s' % os.path.join(scriptPath, 'preup.sh'))
			os.chmod(os.path.join(scriptPath, 'preup.sh'), 0744)
			postup = subprocess.Popen((os.path.join(scriptPath, 'preup.sh'), lastversion, nextversion), stdout=subprocess.PIPE, stderr=subprocess.STDOUT )
			tee = subprocess.Popen(('tee', '-a', '/var/log/univention/updater.log'), stdin=postup.stdout)
			tee.communicate()
			if postup.returncode != 0:
				dprint('Failed to execute preup.sh', [sys.stdout,stdout])
				raise UpdateError

	count=0
	while os.path.exists('/var/run/apt-get.lock') and count < 300:
		time.sleep(1)
		count=count+1

	# TODO: should we really exit if the 'apt-get update' process failed?
	cmd_update = baseConfig.get( 'update/commands/update', 'apt-get update' )
	resultCode=os.system('touch /var/run/apt-get.lock && %s >>/var/log/univention/updater.log 2>&1' % cmd_update)
	if os.path.exists('/var/run/apt-get.lock'):
		os.unlink('/var/run/apt-get.lock')
	if resultCode != 0:
		dprint('Failed to execute %s' % cmd_update, [sys.stdout,stdout])
		raise UpdateError

	# Execute the dist-upgrade!
	count=0
	while os.path.exists('/var/run/apt-get.lock') and count < 300:
		time.sleep(1)
		count=count+1

	cmd_dist_upgrade = baseConfig.get( 'update/commands/distupgrade', 'apt-get -o DPkg::Options::=--force-confold -o DPkg::Options::=--force-overwrite -o DPkg::Options::=--force-overwrite-dir -y --force-yes -u dist-upgrade' )
	resultCode=os.system('touch /var/run/apt-get.lock && DEBIAN_FRONTEND=noninteractive %s >>/var/log/univention/updater.log 2>&1' % cmd_dist_upgrade)
	if os.path.exists('/var/run/apt-get.lock'):
		os.unlink('/var/run/apt-get.lock')
	if resultCode != 0:
		dprint('Failed to execute %s' % cmd_dist_upgrade, [sys.stdout,stdout])
		raise UpdateError

	# Call the postup.sh
	if scriptPath:
		dprint('Call the postup.sh file with the path: %s' % scriptPath)
		if os.path.exists(os.path.join(scriptPath, 'postup.sh')):
			dprint('Execute %s' % os.path.join(scriptPath, 'postup.sh'))
			os.chmod(os.path.join(scriptPath, 'postup.sh'), 0744)
			postup = subprocess.Popen((os.path.join(scriptPath, 'postup.sh'), lastversion, nextversion), stdout=subprocess.PIPE, stderr=subprocess.STDOUT )
			tee = subprocess.Popen(('tee', '-a', '/var/log/univention/updater.log'), stdin=postup.stdout)
			tee.communicate()
			if postup.returncode != 0:
				dprint('Failed to execute postup.sh', [sys.stdout,stdout])
				raise UpdateError

	(nvv,nvp)=nextversion.split('-')[0:2]

	out=univention_baseconfig.handler_set(['version/version=%s' % nvv, 'version/patchlevel=%s' % nvp])
	remove_temporary_sources_list()

	if os.path.exists('/usr/sbin/univention-pkgdb-scan'):
		os.system('/usr/sbin/univention-pkgdb-scan >>/var/log/univention/updater.log 2>&1')

	fp_debug.close()
	if os.path.exists(failure):
		os.unlink(failure)
	os.system('touch %s' % reboot_required)
	os.execv(sys.argv[0], sys.argv)

if __name__ == '__main__':
	try:
		main()
	except UpdateError:
		os.system('touch %s' % failure)
		# set executable flags for apache and UMC
		devnull = open( '/dev/null', 'w' )
		for prog in ( 'apache2', 'univention-management-console-server' ):
			filename = os.path.join( '/usr/sbin/', prog )
			if os.path.isfile( filename ):
				os.chmod( filename, 0755 )
				subprocess.call( ( 'dpkg-statoverride', '--remove', filename ), stdout = devnull, stderr = devnull )
		remove_temporary_sources_list()
		devnull.close()
		sys.exit(1)
	except UpToDateNoError, error:
		if os.path.exists(failure):
			os.unlink(failure)
		if os.path.exists(reboot_required):
			os.unlink(reboot_required)
			if error.reboot is not None:
				os.system('at -f /var/lib/univention-updater/reboot.at -- %s' % error.reboot)
		sys.exit(0)
