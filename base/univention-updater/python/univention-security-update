#!/usr/bin/python2.4
#
# Univention Updater
#  security update
#
# Copyright (C) 2004-2009 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# Binary versions of this file provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

import os
import re
import sys
import getopt
import univention.config_registry as ucr
import time
import subprocess

import univention.management.console.handlers.update.tools

updater = univention.management.console.handlers.update.tools.UniventionUpdater()

def dprint(str, fd=[], toStdout=False):
	if len(fd) < 1:
		print str
	for i in range(0,len(fd)):
		print >>fd[i], str
		print str
	if toStdout and not extra_silent:
		print >>real_stdout, str

def add_temporary_sources_list ( debline ):
	filename = '/etc/apt/sources.list.d/00_ucs_temporary_security_update.list'
	fp = open(filename, 'a+')
	fp.write(debline+'\n')
	fp.close()

def remove_temporary_sources_list ():
	filename = '/etc/apt/sources.list.d/00_ucs_temporary_security_update.list'
	if os.path.exists(filename):
		os.remove(filename)

def usage(fd=sys.stdout):
	print >> fd, 'univention-security-update: tool for include security updates into local repository'
	print >> fd, 'copyright (c) 2004-@%@copyright_lastyear@%@ Univention GmbH, Germany'
	print >> fd, ''
	print >> fd, 'Syntax:'
	print >> fd, '  univention-security-update <net,local> [--file <update.tar.gz>] [--silent] [--noupdate]'
	print >> fd, '  univention-security-update [--help] '
	print >> fd, ''
	print >> fd, 'Known-Bugs:'
	print >> fd, '  -None-'
	print >> fd, ''


if __name__ == '__main__':
	# parse options

	fp_debug=open('/var/log/univention/security-updates.log', 'a+')
	stdout=sys.stdout
	real_stdout = sys.stdout
	sys.stdout=fp_debug
	call_upgrade=True

	file=''

	dprint('***** Starting univention-security-update at %s\n' % time.ctime())

	if len(sys.argv) < 2:
		usage(stdout)
		fp_debug.close()
		sys.exit(1)

	if sys.argv[1] in ['-h', '-?', '--help']:
		usage(stdout)
		fp_debug.close()
		sys.exit(0)

	if sys.argv[1] == 'net':
		command = 'net'
	elif sys.argv[1] == 'local':
		command = 'local'
	else:
		usage(stdout)
		fp_debug.close()
		sys.exit(1)

	longopts=['file=', 'silent', 'noupdate' ]
	try:
		opts, args=getopt.getopt(sys.argv[2:], '', longopts)
	except getopt.error, msg:
		usage(stdout)
		fp_debug.close()
		sys.exit(1)
	for opt, val in opts:
		if opt == '--file':
			file=val
			if command=='net':
				dprint("Parameter \"--file\" only valid when running locally.")
				fp_debug.close()
				sys.exit(1)
			if not val:
				dprint("Parameter \"--file\" needs an argument.")
				fp_debug.close()
				sys.exit(1)
			file = os.path.abspath( file )
		if opt == '--silent':
			extra_silent=True
		if opt == '--noupdate':
			call_upgrade=False

	configRegistry = ucr.ConfigRegistry()
	configRegistry.load()

	local_repository = False
	# update local repository
	if configRegistry.get( 'local/repository', 'no' ) in ( 'true', 'yes'):
		local_repository = True
		# ... via mirror synchronsiation
		if command == 'net':
			dprint( 'Update local repository server ...', [ sys.stdout, stdout ] )
			ret = subprocess.call( [ 'univention-repository-update', 'net', '--security-only' ] )
			if ret:
				dprint( 'Error: Update of local repository server failed', [ sys.stdout, stdout ] )
				sys.exit( 1 )
		# ... via tar archive
		elif command == 'local':
			regexp_archive_name = re.compile( '.*ucs-security-(?P<version>[0-9]*.[0-9]*)-(?P<patch>[0-9]*)[-.](?P<security>[0-9]*)-(?P<arch>[a-z0-9]*).tgz' )
			archive = regexp_archive_name.match( file )
			if not archive:
				dprint( 'Error: The file %s does not look like a security update archive' % file, [ sys.stdout, stdout ] )
				sys.exit( 1 )
			infos = archive.groupdict()
			repo_path = '%s/mirror/%s/maintained/' % ( configRegistry.get( 'repository/mirror/basepath', '/var/lib/univention-repository' ), infos[ 'version' ] )
			if not os.path.exists( repo_path ):
				dprint( 'Error: There is no repository for the UCS version %s. Therefore no security update can be added.' % infos[ 'version' ], [ sys.stdout, stdout ] )
				sys.exit( 1 )
			sec_path = '%s/sec%s/' % ( repo_path, infos[ 'security' ] )
			if os.path.exists( sec_path ):
				dprint( 'Error: The repository for the security update %s of UCS version %s already exists.' % ( infos[ 'security' ], infos[ 'version' ] ), [ sys.stdout, stdout ] )
				sys.exit( 1 )
			ret = subprocess.call( [ 'tar','xzf', file ], cwd = repo_path )
			if ret:
				dprint( 'Error: Failed to extract security update repository.' )
				sys.exit( 1 )

	# without a local repository the local mode is not supported
	elif command == 'local':
		dprint( 'Error: The local mode can just be used on repository servers', [ sys.stdout, stdout ] )
		sys.exit( 1 )

	# install security updates
	cmd_dist_upgrade = configRegistry.get( 'update/commands/distupgrade', 'apt-get -o DPkg::Options::=--force-confold -y --force-yes -u dist-upgrade' )
	cmd_update = configRegistry.get( 'update/commands/update', 'apt-get update' )

	upgraded = False
	while True:
		nextupdate = updater.security_update_available()

		# we don't want an endless loop
		if nextupdate == upgraded:
			break

		if nextupdate:
			dprint('Update to Security Update %s-%s' % (updater.ucs_version, nextupdate), [sys.stdout,stdout])

			remove_temporary_sources_list()
			sources_list_entries = updater.security_update_temporary_sources_list()
			upgraded = nextupdate
			if sources_list_entries:
				for line in sources_list_entries:
					add_temporary_sources_list(line)

				# Execute the dist-upgrade!
				if call_upgrade:
					count=0
					while os.path.exists('/var/run/apt-get.lock') and count < 300:
						time.sleep(1)
						count=count+1
					logfile = open( '/var/log/univention/security-updates.log', 'a' )
					# create lock file
					try:
						fd = open( '/var/run/apt-get.lock', 'w' )
					except:
						pass
					fd.close()
					# update indices
					ret = subprocess.call( cmd_update.split( ' ' ), stdout = logfile, stderr = logfile )
					if ret:
						dprint( 'Error: Failed to update APT indices', [ sys.stdout, stdout ] )
					else:
						ret = subprocess.call( cmd_distupgrade.split( ' ' ), stdout = logfile, stderr = logfile, env = { 'DEBIAN_FRONTEND' : 'noninteractive' } )
						if ret:
							dprint( 'Error: Failed to update APT indices', [ sys.stdout, stdout ] )

					remove_temporary_sources_list()
					if os.path.exists('/var/run/apt-get.lock'):
						os.unlink('/var/run/apt-get.lock')
					sys.exit( ret )
		else:
			if not upgraded:
				dprint('No Security Update available!', [sys.stdout,stdout])
			break
