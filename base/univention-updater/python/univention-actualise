#!/usr/bin/python2.4
#
# Univention Updater
#  actualise script
#
# Copyright (C) 2004, 2005, 2006, 2007, 2008, 2009 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# Binary versions of this file provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

# TODO: use UCR variables for update, upgrade, install and remove commands

import os, sys, string, time, tempfile, univention_baseconfig, commands
import subprocess

class TeeFile( object ):
	'''Writes the given string to serveral files at once. Could by used
	with the print statement'''
	def __init__( self, fds = [] ):
		if not fds:
			self.fds = [ sys.stdout ]
		else:
			self._fds = fds

	def write( self, str ):
		for fd in self._fds:
			print >> fd, str
			fd.flush()

def usage():
	print "univention-actualise: Perform a (dist-)upgrade and (un-)install packages as set"
	print "                      through policies"
	print ""
	print "usage: univention-actualise [-? || --help] [--dist-upgrade] [--silent] [--check]"
	print ""
	print "-?, --help	Show this message"
	print "--dist-upgrade	Perform a dist-upgrade instead of a regular update"
	print "--silent	Don't show normal output, but error messages only"
	print "--check	Don't do anything, yust check if there is an update"

def waitForLock():
	# Wait for /var/run/apt-get.lock to vanish
	count=0
	while os.path.exists('/var/run/apt-get.lock') and count < 300:
		print("Waiting for /var/run/apt-get.lock to vanish...")
		time.sleep(1)
		count=count+1

def createLock():
	try:
		fd = open( '/var/run/apt-get.lock' )
	except:
		pass
	fd.close()

def getUpdate( baseConfig ):
	# Small function waiting for apt lockfile to vanish then starts apt-get update
	cmd_update = baseConfig.get( 'update/commands/update', 'apt-get update' )

	print "Running apt-get update"
	waitForLock()
	createLock()
	logfile = open( '/var/log/univention/actualise.log', 'a' )
	res = subprocess.call( cmd_update.split( ' ' ), stdout = logfile, stderr = logfile )
	logfile.close()
	if os.path.exists('/var/run/apt-get.lock'):
		os.unlink('/var/run/apt-get.lock')
	if res != 0:
		print >>sys.stderr, "E: failed to update"
		sys.exit(res)

def deactivateSourcesListMethods( methods = [ 'cdrom' ] ):
	cnt = 0
	lines = []
	deactivated_lines = []
	f = open('/etc/apt/sources.list', 'r')
	for line in f.readlines():
		line=line.strip(' \n\t')
		for method in methods:
			if line.startswith( 'deb %s:' % method ) or line.startswith( 'deb-src %s:' % method ):
				line = '#%s' % line
				deactivated_lines.append(line)
				cnt += 1
		lines.append(line)
	f.close()
	if cnt:
		f = open('/etc/apt/sources.list', 'w')
		f.write( '\n'.join( lines ) )
		f.write( '\n' )
		f.close()
		debug_file=open('/var/log/univention/actualise.log', 'a+')
		debug_file.write('Hint: deactivated %d lines in /etc/apt/sources.list:\n' % cnt)
		debug_file.write( '   %s\n' % '\n   '.join(deactivated_lines) )
		debug_file.close()

def check( baseConfig, dist_upgrade = False):
	# Just probe if there are packages to add or remove
	cmd_dist_upgrade = baseConfig.get( 'update/commands/distupgrade/simulate', 'apt-get -o DPkg::Options::=--force-confold -y --force-yes -us dist-upgrade' )
	cmd_upgrade = baseConfig.get( 'update/commands/upgrade/simulate', 'apt-get -o DPkg::Options::=--force-confold -y --force-yes -us upgrade' )

	actualise = False
	getUpdate( baseConfig )

	# Probe for packages to actualise
	if dist_upgrade:
		cmd = cmd_dist_upgrade
	else:
		cmd = cmd_upgrade

	waitForLock()
	createLock()
	res=commands.getoutput( '%s | egrep ".*[0-9] upgraded, [0-9].*"' % ( cmd ) )
	if os.path.exists('/var/run/apt-get.lock'):
		os.unlink('/var/run/apt-get.lock')
	sres=res.split()

	# These ones are nicer to read
	upgraded = int(sres[0])
	newlyinstalled = int(sres[2])
	remove = int(sres[5])
	notupgraded = int(sres[9])

	# If there are any pakages to upgrade, install or remove
	if upgraded != 0 or newlyinstalled != 0 or remove != 0:
		actualise = True

	# Probe for policies
	rem_packages=getPackageList(baseConfig, 'remove')
	add_packages=getPackageList(baseConfig, 'add')

	if rem_packages or add_packages or actualise:
		return 1
	else:
		return 0

def getPackageList(baseConfig, job):
	# Get a list of packages to remove or add, depending on the value of job
	# getPackageList(baseConfigObject, pkgdb, job={add,remove})

	packageList=[]
	packages_name=""

	if job == 'remove':
		if baseConfig['server/role'] == 'fatclient':
			packages_name='univentionClientPackagesRemove='
		elif baseConfig['server/role'] == 'mobileclient':
			packages_name='univentionMobileClientPackagesRemove='
		elif baseConfig['server/role'] == 'memberserver':
			packages_name='univentionMemberPackagesRemove='
		elif baseConfig['server/role'] == 'domaincontroller_slave':
			packages_name='univentionSlavePackagesRemove='
		elif baseConfig['server/role'] == 'domaincontroller_master' or baseConfig['server/role'] == 'domaincontroller_backup':
			packages_name='univentionMasterPackagesRemove='
	elif job == 'add':
		if baseConfig['server/role'] == 'fatclient':
			packages_name='univentionClientPackages='
		elif baseConfig['server/role'] == 'mobileclient':
			packages_name='univentionMobileClientPackages='
		elif baseConfig['server/role'] == 'memberserver':
			packages_name='univentionMemberPackages='
		elif baseConfig['server/role'] == 'domaincontroller_slave':
			packages_name='univentionSlavePackages='
		elif baseConfig['server/role'] == 'domaincontroller_master' or baseConfig['server/role'] == 'domaincontroller_backup':
			packages_name='univentionMasterPackages='
	else:
		print >>sys.stderr, "E: no valid job defined"
		sys.exit(1)

	tmpfile=tempfile.mktemp()
	res=os.system('univention_policy_result -s "%s" >>%s' %  (baseConfig['ldap/hostdn'], tmpfile))
	if res != 0:
		print >>sys.stderr, 'failed to execute univention_policy_result'
		sys.exit(res)

	tfile=open(tmpfile, 'r')

	for line in tfile.readlines():
		line=line.strip(' ').replace('"','')
		if line.startswith(packages_name):
			package=line.strip('\n').replace('%s' % packages_name, '').split('/')[-1]
			packageList.append(package)
	tfile.close()
	os.remove(tmpfile)
	return packageList

def main():
	os.putenv('PATH', '/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/bin/X11')
	os.environ['LC_ALL'] = 'C'

	baseConfig=univention_baseconfig.baseConfig()
	baseConfig.load()

	pkgdb = None
	silent = False
	print_usage = False
	dist_upgrade = False
	check_only = False

	try:
		if baseConfig.has_key('ldap/hostdn') and baseConfig['ldap/hostdn']:

			# parse arguments
			for arg in sys.argv[1:]:
				if arg == "--silent":
					silent = True
				elif arg == "-?" or arg=="--help":
					print_usage = True
				elif arg == "--dist-upgrade":
					dist_upgrade = True
				elif arg == '--check':
					check_only = True
				else:
					# unknown parameter
					print_usage=True

			if print_usage:
				usage()
				sys.exit(0)

			if silent:
				# redirect stdout to /dev/null
				sys.stdout = open("/dev/null", "w")

			if check_only:
				# Only probe for packages to add/remove
				res=check(baseConfig, dist_upgrade)
				sys.exit(res)


			logfile = open( '/var/log/univention/actualise.log', 'a' )
			logfile.write('***** Starting univention-actualise at %s\n' % time.ctime())

			deactivateSourcesListMethods( methods = [ 'cdrom' ] )
			cmd_show = baseConfig.get( 'update/commands/show', 'apt-get show' )
			cmd_config = baseConfig.get( 'update/commands/configure', 'dpkg --configure -a' )
			cmd_remove = baseConfig.get( 'update/commands/remove', 'apt-get --yes remove' )
			cmd_install = baseConfig.get( 'update/commands/install', 'apt-get -o DPkg::Options::=--force-confold -y --force-yes install' )

			getUpdate( baseConfig )

			if baseConfig.has_key('pkgdb/scan') and baseConfig['pkgdb/scan']:
				pkgdb=baseConfig['pkgdb/scan']

			if pkgdb:
				univention_baseconfig.handler_set(['pkgdb/scan=no'])

			rem_packages=getPackageList(baseConfig, 'remove')
			for package in rem_packages:
				waitForLock()

				# check if the package exists
				res = subprocess.call( cmd_show.split( ' ' ) + [ package ], stdout = logfile, stderr = logfile )
				if res == 0:
					print "Removing packages: %s" % package
					createLock()
					res = subprocess.call( cmd_config.split( ' ' ), env = { 'DEBIAN_FRONTEND' : 'noninteractive' }, stdout = logfile, stderr = logfile )
					if not res:
						res = subprocess.call( cmd_remove.split( ' ' ) + [ package ], env = { 'DEBIAN_FRONTEND' : 'noninteractive' }, stdout = logfile, stderr = logfile )
				else:
					print("The package %s doesn't exists." % package)
					res=0
				if os.path.exists('/var/run/apt-get.lock'):
					os.unlink('/var/run/apt-get.lock')
				if res != 0:
					print >>sys.stderr, "E: failed to remove %s" % package
					if pkgdb:
						univention_baseconfig.handler_set(['pkgdb/scan=%s' % pkgdb])
					sys.exit(res)


			add_packages=getPackageList(baseConfig, 'add')
			for package in add_packages:
				waitForLock()
				res = subprocess.call( cmd_show.split( ' ' ) + [ package ] )
				if res == 0:
					print "Installing packages: %s" % package
					createLock()
					res = subprocess.call( cmd_config.split( ' ' ), env = { 'DEBIAN_FRONTEND' : 'noninteractive' }, stdout = logfile, stderr = logfile )
					if not res:
						res = subprocess.call( cmd_install.split( ' ' ) + [ package ], env = { 'DEBIAN_FRONTEND' : 'noninteractive' }, stdout = logfile, stderr = logfile )
				else:
					print("The package %s doesn't exists." % package)
					res=0

				if os.path.exists('/var/run/apt-get.lock'):
					os.unlink('/var/run/apt-get.lock')
				if res != 0:
					print >>sys.stderr, "E: failed to install %s" % package
					if pkgdb:
						univention_baseconfig.handler_set(['pkgdb/scan=%s' % pkgdb])
					sys.exit(res)

			waitForLock()

		else:
			# ldap/hostdn is not set
			if baseConfig['server/role'] != 'basesystem':
				print >>sys.stderr, "W: ldap/hostdn is not set - please run univention-join"

		if dist_upgrade:
			msg = "Dist-upgrading system"
			cmd = cmd_distupgrade
		else:
			msg = "Upgrading system"
			cmd = cmd_upgrade

		print(msg)
		# TODO: use mkstemp and close directly the file descriptor
		tmpfd, tmpfile = tempfile.mkstemp()
		teefile = TeeFile( [ logfile, tmpfd ] )

		createLock()
		res = subprocess.call( cmd_configure.split( ' ' ), env = { 'DEBIAN_FRONTEND' : 'noninteractive' }, stdout = logfile, stderr = logfile )
		if res == 0:
			res = subprocess.call( cmd.split( ' ' ), env = { 'DEBIAN_FRONTEND' : 'noninteractive' }, stdout = teefile, stderr = teefile )

		if not silent:
			#TODO: support for more languages
			subprocess.call( [ 'egrep', '(^Get|^Unpacking|^Preparing|^Setting up|packages upgraded)', tmpfile ] )
		os.unlink( tmpfile )
		if os.path.exists('/var/run/apt-get.lock'):
			os.unlink('/var/run/apt-get.lock')

		if baseConfig.has_key('ldap/hostdn') and baseConfig['ldap/hostdn']:
			if res != 0:
				print >>sys.stderr, "E: failed to upgrade"
				if pkgdb:
					univention_baseconfig.handler_set(['pkgdb/scan=%s' % pkgdb])
				sys.exit(res)

	finally:
		if pkgdb:
			univention_baseconfig.handler_set(['pkgdb/scan=%s' % pkgdb])
			if not silent:
				os.system('/usr/sbin/univention-pkgdb-scan')
			else:
				os.system('/usr/sbin/univention-pkgdb-scan > /dev/null')

if __name__ == '__main__':
	failure = '/var/lib/univention-updater/update-failed'
	if os.path.exists(failure):
		print 'univention-actualise: univention-updater failed, stopping...'
		print '    remove `%s\' to proceed' % failure
		sys.exit(2)
	main()
	sys.exit(0)
