#!/usr/bin/python2.4
#
# Univention Updater
#  actualise script
#
# Copyright (C) 2004-2010 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# Binary versions of this file provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

# TODO: use UCR variables for update, upgrade, install and remove commands

import os, sys, string, time, tempfile, commands
import subprocess

import univention.config_registry as ucr

LOGNAME = '/var/log/univention/actualise.log'

configRegistry = ucr.ConfigRegistry()
configRegistry.load()

cmd_dist_upgrade_sim = configRegistry.get( 'update/commands/distupgrade/simulate', 'apt-get -o DPkg::Options::=--force-confold -o DPkg::Options::=--force-overwrite -o DPkg::Options::=--force-overwrite-dir -y --force-yes -us dist-upgrade' )
cmd_upgrade_sim = configRegistry.get( 'update/commands/upgrade/simulate', 'apt-get -o DPkg::Options::=--force-confold -o DPkg::Options::=--force-overwrite -o DPkg::Options::=--force-overwrite-dir -y --force-yes -us upgrade' )
cmd_dist_upgrade = configRegistry.get( 'update/commands/distupgrade', 'apt-get -o DPkg::Options::=--force-confold -o DPkg::Options::=--force-overwrite -o DPkg::Options::=--force-overwrite-dir -y --force-yes -u dist-upgrade' )
cmd_upgrade = configRegistry.get( 'update/commands/upgrade', 'apt-get -o DPkg::Options::=--force-confold -o DPkg::Options::=--force-overwrite -o DPkg::Options::=--force-overwrite-dir -y --force-yes -u upgrade' )
cmd_update = configRegistry.get( 'update/commands/update', 'apt-get update' )
cmd_show = configRegistry.get( 'update/commands/show', 'apt-cache show' )
cmd_config = configRegistry.get( 'update/commands/configure', 'dpkg --configure -a' )
cmd_remove = configRegistry.get( 'update/commands/remove', 'apt-get --yes remove' )
cmd_install = configRegistry.get( 'update/commands/install', 'apt-get -o DPkg::Options::=--force-confold -o DPkg::Options::=--force-overwrite -o DPkg::Options::=--force-overwrite-dir -y --force-yes install' )

class Tee( object ):
	'''Writes the given string to serveral files at once. Could by used
	with the print statement'''
	def __init__( self, files = [], stdout = True, filter = None ):
		self.stdout = stdout
		self.files = files
		self.filter = filter

	def call( self, command, **kwargs ):
		devnull = None
		p = subprocess.Popen( command, stdout = subprocess.PIPE, stderr = subprocess.STDOUT, **kwargs )
		tee_command = [ 'tee', '-a' ] + self.files
		if self.stdout:
			if self.filter:
				tee = subprocess.Popen( tee_command, stdin = p.stdout, stdout = subprocess.PIPE, stderr = subprocess.STDOUT )
				egrep = subprocess.Popen( [ 'egrep', self.filter ], stdin = tee.stdout )
				ret = egrep.wait()
			else:
				tee = subprocess.Popen( tee_command, stdin = p.stdout )
		else:
			devnull = open( os.path.devnull, 'a' )
			tee = subprocess.Popen( tee_command, stdin = p.stdout, stdout = devnull )
			devnull.close()

		# Must wait for exit from back to front, only the exit status of p is relevant
		ret = tee.wait()
		ret = p.wait()
		if devnull:
			devnull.close()

		return ret

def usage():
	print "univention-actualise: Perform a (dist-)upgrade and (un-)install packages as set"
	print "                      through policies"
	print ""
	print "usage: univention-actualise [-? || --help] [--dist-upgrade] [--silent] [--check]"
	print ""
	print "-?, --help	Show this message"
	print "--dist-upgrade	Perform a dist-upgrade instead of a regular update"
	print "--silent	Don't show normal output, but error messages only"
	print "--check	Don't do anything, just check if there is an update"

def waitForLock():
	# Wait for /var/run/apt-get.lock to vanish
	count=0
	while os.path.exists('/var/run/apt-get.lock') and count < 300:
		print("Waiting for /var/run/apt-get.lock to vanish...")
		time.sleep(1)
		count=count+1

def createLock():
	try:
		fd = open( '/var/run/apt-get.lock', 'w' )
		fd.close()
	except:
		pass

def getUpdate( configRegistry ):
	# Small function waiting for apt lockfile to vanish then starts apt-get update

	print "Running apt-get update"
	waitForLock()
	createLock()
	logfile = open( LOGNAME, 'a' )
	res = subprocess.call( cmd_update.split( ' ' ), stdout = logfile, stderr = logfile )
	logfile.close()
	if os.path.exists('/var/run/apt-get.lock'):
		os.unlink('/var/run/apt-get.lock')
	if res != 0:
		print >>sys.stderr, "E: failed to update"
		sys.exit(res)

def deactivateSourcesListMethods( methods = [ 'cdrom' ] ):
	cnt = 0
	lines = []
	deactivated_lines = []
	f = open('/etc/apt/sources.list', 'r')
	for line in f.readlines():
		line=line.strip(' \n\t')
		for method in methods:
			if line.startswith( 'deb %s:' % method ) or line.startswith( 'deb-src %s:' % method ):
				line = '#%s' % line
				deactivated_lines.append(line)
				cnt += 1
		lines.append(line)
	f.close()
	if cnt:
		f = open('/etc/apt/sources.list', 'w')
		f.write( '\n'.join( lines ) )
		f.write( '\n' )
		f.close()
		debug_file=open(LOGNAME, 'a+')
		debug_file.write('Hint: deactivated %d lines in /etc/apt/sources.list:\n' % cnt)
		debug_file.write( '   %s\n' % '\n   '.join(deactivated_lines) )
		debug_file.close()

def check( configRegistry, dist_upgrade = False):
	# Just probe if there are packages to add or remove

	actualise = False
	getUpdate( configRegistry )

	# Probe for packages to actualise
	if dist_upgrade:
		cmd = cmd_dist_upgrade_sim
	else:
		cmd = cmd_upgrade_sim

	waitForLock()
	createLock()
	res=commands.getoutput( '%s | egrep ".*[0-9] upgraded, [0-9].*"' % ( cmd ) )
	if os.path.exists('/var/run/apt-get.lock'):
		os.unlink('/var/run/apt-get.lock')
	sres=res.split()

	# These ones are nicer to read
	upgraded = int(sres[0])
	newlyinstalled = int(sres[2])
	remove = int(sres[5])
	notupgraded = int(sres[9])

	# If there are any pakages to upgrade, install or remove
	if upgraded != 0 or newlyinstalled != 0 or remove != 0:
		actualise = True

	# Probe for policies
	rem_packages=getPackageList(configRegistry, 'remove')
	add_packages=getPackageList(configRegistry, 'add')

	if rem_packages or add_packages or actualise:
		return 1
	else:
		return 0

def getPackageList(configRegistry, job):
	# Get a list of packages to remove or add, depending on the value of job
	# getPackageList(configRegistryObject, pkgdb, job={add,remove})

	packageList=[]
	packages_name=""

	if job == 'remove':
		if configRegistry['server/role'] == 'fatclient':
			packages_name='univentionClientPackagesRemove='
		elif configRegistry['server/role'] == 'mobileclient':
			packages_name='univentionMobileClientPackagesRemove='
		elif configRegistry['server/role'] == 'memberserver':
			packages_name='univentionMemberPackagesRemove='
		elif configRegistry['server/role'] == 'domaincontroller_slave':
			packages_name='univentionSlavePackagesRemove='
		elif configRegistry['server/role'] == 'domaincontroller_master' or configRegistry['server/role'] == 'domaincontroller_backup':
			packages_name='univentionMasterPackagesRemove='
	elif job == 'add':
		if configRegistry['server/role'] == 'fatclient':
			packages_name='univentionClientPackages='
		elif configRegistry['server/role'] == 'mobileclient':
			packages_name='univentionMobileClientPackages='
		elif configRegistry['server/role'] == 'memberserver':
			packages_name='univentionMemberPackages='
		elif configRegistry['server/role'] == 'domaincontroller_slave':
			packages_name='univentionSlavePackages='
		elif configRegistry['server/role'] == 'domaincontroller_master' or configRegistry['server/role'] == 'domaincontroller_backup':
			packages_name='univentionMasterPackages='
	else:
		print >>sys.stderr, "E: no valid job defined"
		sys.exit(1)

	tmpfile=tempfile.mktemp()
	res=os.system('univention_policy_result -s "%s" >>%s' %  (configRegistry['ldap/hostdn'], tmpfile))
	if res != 0:
		print >>sys.stderr, 'failed to execute univention_policy_result'
		sys.exit(res)

	tfile=open(tmpfile, 'r')

	for line in tfile.readlines():
		line=line.strip(' ').replace('"','')
		if line.startswith(packages_name):
			package=line.strip('\n').replace('%s' % packages_name, '').split('/')[-1]
			packageList.append(package)
	tfile.close()
	os.remove(tmpfile)
	return packageList

def main():
	os.putenv('PATH', '/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/bin/X11')
	os.environ['LC_ALL'] = 'C'

	pkgdb = None
	silent = False
	print_usage = False
	dist_upgrade = False
	check_only = False

	# parse arguments
	for arg in sys.argv[1:]:
		if arg == "--silent":
			silent = True
		elif arg == "-?" or arg=="--help":
			print_usage = True
		elif arg == "--dist-upgrade":
			dist_upgrade = True
		elif arg == '--check':
			check_only = True
		else:
			# unknown parameter
			print_usage=True

	if print_usage:
		usage()
		sys.exit(0)

	if silent:
		# redirect stdout to /dev/null
		sys.stdout = open("/dev/null", "w")

	try:
		if check_only:
			# Only probe for packages to add/remove
			res=check(configRegistry, dist_upgrade)
			sys.exit(res)

		if configRegistry.has_key('ldap/hostdn') and configRegistry['ldap/hostdn']:
			logfile = open( LOGNAME, 'a' )
			logfile.write('***** Starting univention-actualise at %s\n' % time.ctime())

			deactivateSourcesListMethods( methods = [ 'cdrom' ] )

			getUpdate( configRegistry )

			# temporarily disable pkgdb
			if configRegistry.has_key('pkgdb/scan') and configRegistry['pkgdb/scan']:
				pkgdb=configRegistry['pkgdb/scan']
				if pkgdb:
					ucr.handler_set(['pkgdb/scan=no'])

			rem_packages=getPackageList(configRegistry, 'remove')
			for package in rem_packages:
				waitForLock()

				# check if the package exists
				res = subprocess.call( cmd_show.split( ' ' ) + [ package ], stdout = logfile, stderr = logfile )
				if res == 0:
					print "Removing packages: %s" % package
					createLock()
					os.environ[ 'DEBIAN_FRONTEND' ] = 'noninteractive'
					res = subprocess.call( cmd_config.split( ' ' ), stdout = logfile, stderr = logfile )
					if not res:
						res = subprocess.call( cmd_remove.split( ' ' ) + [ package ], stdout = logfile, stderr = logfile )
				else:
					print("The package %s doesn't exist." % package)
					res=0
				if os.path.exists('/var/run/apt-get.lock'):
					os.unlink('/var/run/apt-get.lock')
				if res != 0:
					print >>sys.stderr, "E: failed to remove %s" % package
					sys.exit(res)


			add_packages=getPackageList(configRegistry, 'add')
			for package in add_packages:
				waitForLock()
				res = subprocess.call( cmd_show.split( ' ' ) + [ package ], stdout = logfile, stderr = logfile )
				if res == 0:
					print "Installing packages: %s" % package
					createLock()
					os.environ[ 'DEBIAN_FRONTEND' ] = 'noninteractive'
					res = subprocess.call( cmd_config.split( ' ' ), stdout = logfile, stderr = logfile )
					if not res:
						res = subprocess.call( cmd_install.split( ' ' ) + [ package ], stdout = logfile, stderr = logfile )
				else:
					print("The package %s doesn't exist." % package)
					res=0

				if os.path.exists('/var/run/apt-get.lock'):
					os.unlink('/var/run/apt-get.lock')
				if res != 0:
					print >>sys.stderr, "E: failed to install %s" % package
					sys.exit(res)

			waitForLock()

		else:
			# ldap/hostdn is not set
			if configRegistry['server/role'] != 'basesystem':
				print >>sys.stderr, "W: ldap/hostdn is not set - please run univention-join"

		if dist_upgrade:
			msg = "Dist-upgrading system"
			cmd = cmd_dist_upgrade
		else:
			msg = "Upgrading system"
			cmd = cmd_upgrade

		print msg
		# TODO: use mkstemp and close directly the file descriptor

		createLock()
		os.environ[ 'DEBIAN_FRONTEND' ] = 'noninteractive'
		tee = Tee( [ LOGNAME ], stdout = not silent  )
		res = tee.call( cmd_config.split( ' ' ) )
		if res != 0:
			print >>sys.stderr, "E: failed to configure packets, see %s for details." % LOGNAME
		else:
			tee = Tee( [ LOGNAME ], stdout = not silent, filter = '(^Get|^Unpacking|^Preparing|^Setting up|packages upgraded)' )
			res = tee.call( cmd.split( ' ' ) )
			if res != 0:
				print >>sys.stderr, "E: failed to upgrade, see %s for details." % LOGNAME

		if os.path.exists('/var/run/apt-get.lock'):
			os.unlink('/var/run/apt-get.lock')

		sys.exit(res)

	finally:
		if pkgdb:
			ucr.handler_set(['pkgdb/scan=%s' % pkgdb])
			if str(pkgdb).lower() in ("yes","enable","enabled","true","1"):
				if not silent:
					os.system('/usr/sbin/univention-pkgdb-scan')
				else:
					os.system('/usr/sbin/univention-pkgdb-scan > /dev/null')

if __name__ == '__main__':
	failure = '/var/lib/univention-updater/update-failed'
	if os.path.exists(failure):
		print 'univention-actualise: univention-updater failed, stopping...'
		print '    remove `%s\' to proceed' % failure
		sys.exit(2)

	try:
		for root, dirs, files in os.walk('/etc/apt/sources.list.d'):
			for file in [file for file in files if file.startswith('00_ucs_temporary_')]:
				filename = os.path.join(root, file)
				print 'Warning: Deleting `%s` from incomplete update.' % filename
				os.remove(filename)
			del dirs[:]
	except:
		print 'Failed, aborting.'
		sys.exit(2)

	main()
	sys.exit(0)
