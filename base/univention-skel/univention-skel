#!/usr/bin/python2.4
# -*- coding: utf-8 -*-
#
# Univention Skel
#  skel script
#
# Copyright (C) 2004, 2005, 2006, 2008 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# Binary versions of this file provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

import os, sys, md5, string
# for file locking
import fcntl
import time

# for restoring permissions
import stat

import univention.config_registry

home = os.getenv( 'HOME', '' )
if not os.path.isdir( home ):
	print >>sys.stderr, 'Invalid home directory'
	sys.exit( 1 )

cfgRegistry = univention.config_registry.ConfigRegistry()
cfgRegistry.load()

user_skel_dir = '.univention-skel'
userconfig_templates='/etc/univention/skel'
userconfig_base=os.path.join(home, user_skel_dir )
lockfile = os.path.join( home, '.univention-skel.lock' )
lock_fd = None

class Stamps:
	base=''
	files={}
	dirs=[]
	def read(self, base):
		self.base=base
		self.files={}
		self.dirs=[]
		if os.path.exists(os.path.join(base, 'dirs')):
			fp=open(os.path.join(base, 'dirs'))
			for line in fp.readlines():
				dir=line[0:-1]
				self.dirs.append(dir)
			fp.close()
		if os.path.exists(os.path.join(base, 'files')):
			fp=open(os.path.join(base, 'files'))
			for line in fp.readlines():
				(file,md5sum)=line[0:-1].split('@%@')
				self.files[file]=md5sum
			fp.close()
	def write(self):
		if not os.path.exists(self.base):
			os.mkdir(self.base)
		fp=open(os.path.join(self.base, 'dirs'), 'w')
		for dir in self.dirs:
			fp.write(dir+'\n')
		fp.close()
		fp=open(os.path.join(self.base, 'files'), 'w')
		for file in self.files.items():
			fp.write(string.join(file, '@%@')+'\n')
		fp.close()

def md5sum(file):
	# module md5 will be replace with hashlib in python 2.5
	return md5.md5(open(file).read()).hexdigest()

def i2h_file(file):
	return file.replace(userconfig_templates, home)

def h2i_file(file):
	return file.replace(home, userconfig_templates)

def install_files(stamps, dir, files):
	hstamps, istamps = stamps
	hdir = i2h_file(dir)
	istamps.dirs.append(dir)

	# create directories if necessary
	print hdir
	if not os.path.exists(hdir):
		if not hdir in hstamps.dirs:
			hstamps.dirs.append(hdir)
			print 'mkdir', hdir
			# inherit permissions from skel dir
# 			perms = os.stat( dir )[ stat.ST_MODE ]
# 			os.mkdir( hdir, perms & 0777 )

	# check files
	for file in files:
		ifile = os.path.join(dir, file)
		hfile = os.path.join(hdir, file)
		if not os.path.isfile(ifile):
			if os.path.islink(ifile):
				if not os.path.exists(hfile):
					print 'create_link %s' % hfile
					os.symlink(os.readlink(ifile), hfile)
				if (os.path.exists(hfile) and os.readlink(hfile) != os.readlink(ifile)):
					print 'create_link %s' % hfile
					os.unlink(hfile)
					os.symlink(os.readlink(ifile), hfile)
				hstamps.files[hfile] = 'symlink'
				istamps.files[ifile] = 'symlink'
			continue
		istamps.files[ifile] = md5sum(ifile)
		# copy file if:
		## file does not exist
		## there is no MD5 sum
		## unmodified version of file exists and MD5 sums of skel and user version do not match
		if ( not os.path.exists(hfile) ) or \
			   ( not hstamps.files.has_key(hfile) ) or \
			   ( os.path.exists(hfile) and md5sum(hfile) == hstamps.files.get(hfile, '') and \
				 hstamps.files[hfile] != istamps.files[ifile] ):
			print 'create', hfile
			# inherit permissions from skel dir
			perms = os.stat( ifile )[ stat.ST_MODE ]
			rfp=open(ifile)
			wfp = os.open( hfile, os.O_WRONLY | os.O_TRUNC | os.O_CREAT ) #, perms & 0777 )
			os.write( wfp, rfp.read() )
			os.close( wfp )
			rfp.close()
			hstamps.files[hfile] = md5sum(hfile)

def _lock():
	'''try to lock skel operations. If lock could not be acquired will
	retry it for skel/retries times'''
	global lock_fd

	count = int( cfgRegistry.get( 'skel/lock/retries', '5' ) )
	lock_fd = open( lockfile, 'w' )
	while count:
		try:
			fcntl.lockf( lock_fd, fcntl.LOCK_EX | fcntl.LOCK_NB )
			return True
		except Exception ,e:
			print str(e )
			count -= 1
			time.sleep( 0.05 ) # 50 milliseconds

	return False

def _unlock():
	'''free lock for skel operations'''
	global lock_fd

	if not lock_fd: return False
	fcntl.lockf( lock_fd, fcntl.LOCK_UN )
	lock_fd.close()
	lock_fd = None

	return True

if not _lock():
	print >>sys.stderr, 'Unable to lock skel operations'
	sys.exit( 1 )

sys.stdout = open( '/tmp/log', 'w' )
hstamps = Stamps()
hstamps.read(userconfig_base)
istamps = Stamps()

print userconfig_templates
os.path.walk(userconfig_templates, install_files, (hstamps, istamps))

# delete old skel files
delete_files=[]
for hfile in hstamps.files.keys():
	ifile = h2i_file(hfile)
	if os.path.islink(hfile) and not istamps.files.has_key(ifile) and os.path.exists(hfile):
		print 'delete_link', hfile
		delete_files.append(hfile)
		os.unlink(hfile)
	if not os.path.islink(ifile) and not istamps.files.has_key(ifile) and os.path.exists(hfile) and \
			hstamps.files[hfile] == md5sum(hfile):
		print 'delete', hfile
		delete_files.append(hfile)
		os.unlink(hfile)
for file in delete_files:
	del hstamps.files[file]

# delete old skel directories
hstamps.dirs.sort()
hstamps.dirs.reverse()
delete_dirs=[]
for hdir in hstamps.dirs:
	idir = h2i_file(hdir)
	if not idir in istamps.dirs and os.path.exists(hdir):
		print 'delete', hdir
		delete_dirs.append(hdir)
		try:
			os.rmdir(hdir)
		except OSError:
			print 'directory not empty'
for dir in delete_dirs:
	hstamps.dirs.remove(dir)

hstamps.write()

if not _unlock():
	print >>sys.stderr, 'Unable to free lock of skel operations'
	sys.exit( 1 )
