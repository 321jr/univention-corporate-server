#!/usr/bin/env python
# coding: utf-8

"""
This programmme compares ldap host entries with a local comparative ldif file. 
All differences will be displayed at the console.

"""

from optparse import OptionParser
import sys
import subprocess
import tempfile
import os
import difflib

USAGE = '''%prog [TARGET] TARGET
Compares the LDAP directory contents of the TARGETs
TARGET can be:
 a local LDIF file
 a hostname whose directory will be read using slapcat over ssh.
 If the first TARGET is omitted, the local hosts directory is used instead.'''
tmpfiles = []

def main():
	"""A main()-method with options..."""
	parser = OptionParser(usage=USAGE,
                          version="%prog 1.0")
                      
	(_, args) = parser.parse_args()
	
	try: 
		if not args or len(args) > 2:
			parser.error("Wrong number of TARGETS")
		arguments = [ ('local', 'local ldap', ), ] 
		for argument in args:
			if os.access(argument, os.F_OK): # check it argument is a file
											# then append it as a file
				arguments.append( ('file', argument) )
			else:
				arguments.append( ('host', argument) ) # check it argument is a host
														# append it as host
		(_, right_first, ) = arguments[-2] # only for the original name 
		(_, right_second, ) = arguments[-1] # only for the original name
	except OSError, error:
		print >> sys.stderr, "An error accurred with: %s" % (error, )
		
	try:
		compare_tmp_files(cleanup(fetch(arguments[-2])), cleanup(fetch(arguments[-1])), right_first, right_second)
	except OSError, error:
		print >> sys.stderr, "An error accurred with: %s" % (error, )
		
def fetch(input_value):
	"""This method provides a tmp file for each type of argument"""
	(fetch_type, argument, ) = input_value
	if fetch_type == 'local':
		return create_tmp_file_from_localhost()
	if fetch_type == 'file':
		return create_local_tmp_file(argument)
	if fetch_type == 'host':
		return create_stdout_tmp_file(argument)
		
def line_validation(ldifline):
	"""Check if a ldifline is a valid line
		returns "False" if ldifline is invalid """
	
	attributes_to_ignore = ["entryCSN:", "modifiersName:", "modifyTimestamp:", "creatorsName", "entryUUID",
							"createTimestamp"]
	
	if (':' in ldifline and ldifline[0] != '#' or ldifline[0] == ' '):
		if(attributes_to_ignore[0] not in ldifline
			and attributes_to_ignore[1] not in ldifline
			and attributes_to_ignore[2] not in ldifline
			and attributes_to_ignore[3] not in ldifline
			and attributes_to_ignore[4] not in ldifline
			and attributes_to_ignore[5] not in ldifline): 
			return True
		else:
			return False
	else:
		return False

def cleanup(tmp_file):
	""" The method converts the tmp_file with an algorithm 
		that make the "diff"-comparison possible into another tmp file"""
	if tmp_file == None:
		delete_tmp_file()
	attrlist = [] # list of ldap attributes of an ldap object
	attrtype = None # types of the ldap entries
	attrname = None # name of the ldap entries
	do_one_time = True 
	
	#print attributes_to_ignore[5]
	# auxiliary variable for one use only. 
	# skips first empty entry of the atttlist[]
	no_further_value_line = True # auxiliary variable for identification of a continued attribut term
	comments_continue = None # auxiliary variable for identification 
							# of a continued attribut term (see the algorithm below)
	try:
		ldif_file_to_read = open(tmp_file, 'r') # read the given local ldif file
		for ldifline in ldif_file_to_read: # reads liny by line
			if line_validation(ldifline):
			#if (':' in ldifline and ldifline[0] != '#' or ldifline[0] == ' '):
				# if a line (without '\n') is not empty it's a valid line if a line 
				# has an ': ' char sequenze and the first char of a line
				# is not a '#' it's a valid line			
				if ldifline[0] != ' ':
					splitted_line = ldifline.replace('\n','').split(':', 1)
					if not no_further_value_line:
						attrlist.append((attrtype+':', attrname))
						attrtype = splitted_line[0] # muss be assigned after append()
						if len(splitted_line) > 1:
							attrname = splitted_line[1]
						else:
							attrname = ''
						no_further_value_line = True 
					else: # it has to be because of the algorithm
						
						if do_one_time:
							attrtype = splitted_line[0] # muss be assigned after append()
							if len(splitted_line) > 1:
								attrname = splitted_line[1]
							else:
								attrname = ''
							do_one_time = False
						else:
							attrlist.append((attrtype+':', attrname))
							attrtype = splitted_line[0] # muss be assigned after append()
							if len(splitted_line) > 1:
								attrname = splitted_line[1]
							else:
								attrname = ''
				else:
					comments_continue = ldifline[1:].rstrip()
					attrname = attrname + comments_continue
					no_further_value_line = False
			elif ldifline in ['\n', '\r\n']: 
				# new LDAP-object
				attrlist.append((attrtype+':', attrname))
				attrtype = ''
				attrname = ''
							
		attrlist.append((attrtype+':', attrname))
		ldif_file_to_read.close()
		my_test_list = clean_objects(attrlist)

	except IOError:
		print >> sys.stderr, 'An error occurred with ', ldif_file_to_read, \
		
	fileheader, abs_path = tempfile.mkstemp() # tempfile co comparee
	tmp_local_ldif_file = open(abs_path,'w')
	local_tmp_filepath = tmp_local_ldif_file.name
		
	for i in xrange(0, len(my_test_list)):
		line_attrvalue = my_test_list[i]
		#print line_attrvalue
		#print "--------------------"
		for j in xrange(0, 1):
			#line_attrvalue2 = line_attrvalue[j]
			dn_attribute = line_attrvalue[0][0], line_attrvalue[0][1]
			#print line_attrvalue[0][0], line_attrvalue[0][1] # dn: attribut
			tmp_local_ldif_file.write("".join(dn_attribute))
			tmp_local_ldif_file.write('\n')
			for z in xrange(0, len(line_attrvalue[1])):
				line_attrvalue3 = line_attrvalue[1][z]
				other_attributes = line_attrvalue3[0], line_attrvalue3[1]
				#print line_attrvalue3[0], line_attrvalue3[1] # other attributes
				tmp_local_ldif_file.write("".join(other_attributes))
				tmp_local_ldif_file.write('\n')
		
	
	"""for i in xrange(0, len(attrlist)):
		line_attrvalue = attrlist[i]
		if line_attrvalue[0].startswith( ':' ):
			tmp_local_ldif_file.write('')
		else:
			tmp_local_ldif_file.write(line_attrvalue[0])
		tmp_local_ldif_file.write(line_attrvalue[1])
			tmp_local_ldif_file.write('\n')"""
	
	tmp_local_ldif_file.close()
	os.remove(tmp_file) # removes original (unconverted) tmp_file
	tmp_file_to_delete(local_tmp_filepath) 
	# adds a new tmp file to an delete queue in case that it would be no host to compare
	return local_tmp_filepath
	
def clean_objects(attrlist):
	attr_list_object = []
	new_sorted_attr_list = []
	for i in xrange(0, len(attrlist)):
		line_attrvalue_obj = attrlist[i]
		if line_attrvalue_obj[0] != ':':
			attr_list_object.append((line_attrvalue_obj[0], line_attrvalue_obj[1]))
			#print line_attrvalue_obj[0], line_attrvalue_obj[1]	
		else:
			#print "-----------------------"
			new_sorted_attr_list.append(sort_objects(attr_list_object))
			#sort_objects(attr_list_object)
			attr_list_object = []
	return new_sorted_attr_list
			
		
def sort_objects(attrlist):
	dn_attr = ['Null','Null']
	not_dn_attr = []
	drawn_together = []
	drawn_together_list = []
	for i in xrange(0, len(attrlist)):
		line_attrvalue_obj = attrlist[i]
		#if "dn:" in line_attrvalue_obj[0]:
		if "dn:" in line_attrvalue_obj[0][:3]:
			dn_attr[0] = line_attrvalue_obj[0];
			dn_attr[1] = line_attrvalue_obj[1];
		else:
			not_dn_attr.append((line_attrvalue_obj[0], line_attrvalue_obj[1]))
			
	#not_dn_attr.sort()
	drawn_together.append((dn_attr[0], dn_attr[1]))
	not_dn_attr.append(("", ""))
	drawn_together.append(not_dn_attr)
	
	#for val in drawn_together[1]:
		#print val
	return drawn_together

def create_tmp_file_from_localhost():
	"""This method creates a tmp file from localhost line by line
		such as stdout comes (without validation)"""
	sshprocess = subprocess.Popen(['slapcat', '-d0', ],
	stdout=subprocess.PIPE)
	
	linelist_stdout = []
	while True:
		line = sshprocess.stdout.readline() # reads an stdout line by line
		if line != '':
			linelist_stdout.append(line)
		else:
			break
	stout_temp_filepath = create_tmp_file(linelist_stdout)
	return stout_temp_filepath
	
def create_local_tmp_file(ldif_file_name):
	"""This method creates a tmp file line by line 
		from file (without validation)"""
	line_list = []
	try:
		ldif_file_to_read = open(ldif_file_name, 'r') # read the given local ldif file
		for ldifline in ldif_file_to_read: # reads liny by line
			line_list.append(ldifline)
	except IOError:
		print >> sys.stderr, 'An error occurred with ', ldif_file_to_read, \
		
	temp_filepath = create_tmp_file(line_list)
	return temp_filepath
	
def create_stdout_tmp_file(ldap_host_name):
	"""This method creates a tmp file line by line 
		such as stdout comes (without validation)"""
	print "Please enter your password to connect to ", ldap_host_name
	sshprocess = subprocess.Popen(['ssh', 'root@'+ldap_host_name, 'slapcat', '-d0', ], 
	stdout=subprocess.PIPE)
	
	line_list_stdout = []
	while True:
		line = sshprocess.stdout.readline() # reads an stdout line by line
		if line != '':

			line_list_stdout.append(line)
		else:
			break
	
	if not line_list_stdout: # in case the file does not exists
		return None
	else:
		stout_temp_filepath = create_tmp_file(line_list_stdout)
		return stout_temp_filepath

	
def create_tmp_file(entries_list):
	""" This method creates an tmp file of a given list as parameter"""
	fileheader, abs_path = tempfile.mkstemp()
	new_file = open(abs_path,'w')
	temp_filepath = new_file.name
	new_file.write("".join(entries_list))
	#for i in xrange(0, len(entries_list)):
	#	line_value = entries_list[i]
	#		new_file.write(line_value)
		
	new_file.close()
	return temp_filepath
	
def tmp_file_to_delete(file_to_delete):
	"""This method collects all tmp files. In case to delete them all."""
	tmpfiles.append(file_to_delete)
	
def delete_tmp_file():
	"""Deletes all the file in the list "tmpfiles" """
	for i in xrange(0, len(tmpfiles)):
		os.remove(tmpfiles[i])
	
def compare_tmp_files(stout_temp_filepath, local_tmp_filepath, original_stdout, original_ldif_file_name):
	"""Compares two files with a command line order "diff"
		stdout shows a return value if two 
		comparative files are equal or not"""

	line_list = []
	try:
		ldif_stout_tmp_file_to_read = open(stout_temp_filepath, 'r') # read the given tmp local ldif file from stdou
		for ldifline in ldif_stout_tmp_file_to_read: # reads liny by line
			if "dn:" in ldifline[:3]:
				#print ldifline
				line_list.append(ldifline)
			elif ldifline in ['\n', '\r\n']: 
				#print "new object"
				#print len(line_list)
				search_equal_object(line_list, local_tmp_filepath, original_stdout, original_ldif_file_name, "+")
				line_list = []
			else:
				#print ldifline
				line_list.append(ldifline)
			
	except IOError:
		print >> sys.stderr, 'An error occurred with ', ldif_stout_tmp_file_to_read, \
		
	
	
	"""obj_line_list = []
	try:
		ldif_local_tmp_file_to_read = open(local_tmp_filepath, 'r') # read the given tmp local ldif file from stdou
		for ldifline in ldif_local_tmp_file_to_read: # reads liny by line
			if "dn:" in ldifline[:3]:
				#print ldifline
				obj_line_list.append(ldifline)
			elif ldifline in ['\n', '\r\n']:
				#print "new object"
				#print len(line_list)
				search_equal_object(obj_line_list, stout_temp_filepath, original_ldif_file_name, original_stdout, "-")
				obj_line_list = []
			else:
				#print ldifline
				obj_line_list.append(ldifline)
			
	except IOError:
		print >> sys.stderr, 'An error occurred with ', ldif_local_tmp_file_to_read, \
	"""

	"""diffcommand = ['diff', '-u', stout_temp_filepath, '--label', original_stdout, 
								local_tmp_filepath, '--label', original_ldif_file_name]
	
	ssh_processdiff = subprocess.Popen(diffcommand)
	ssh_processdiff.communicate() # waits for a process to end

	# A subprocess by way of comparison with diff. tmp file of 
	# stdout LDAP and tmp file of local ldif file will be compared
	os.remove(stout_temp_filepath)
	# removes tmp file created from stdout lDAP
	os.remove(local_tmp_filepath)
	# removes tmp file created of local ldif input file
	sys.exit(ssh_processdiff.returncode) # exitcode either 1 or 0	"""
	
def search_equal_object(obj_line_list, tmp_filepath, original_stdout, original_ldif_file_name, sign):
	obj_line_list_file = []
	object_match = False
	try:
		ldif_local_tmp_file_to_read = open(tmp_filepath, 'r') # read the given tmp local ldif file from stdou
		for ldifline in ldif_local_tmp_file_to_read: # reads liny by line
			if "dn:" in ldifline[:3]:
				obj_line_list_file.append(ldifline)
				if obj_line_list[0] == ldifline:
					#print "find match:" 
					object_match = True
					# "find dn:", ldifline
			elif ldifline in ['\n', '\r\n']: 
				if object_match:
					compare_two_objects(obj_line_list, obj_line_list_file, original_stdout, original_ldif_file_name, sign) # reason: dn: are equals
					break;
				# "new object"
				obj_line_list_file = []
				
			else:
				# print ldifline
				obj_line_list_file.append(ldifline)
		if not object_match:
			print ""
			sign = change_sign(sign)
			
			for line in obj_line_list:
				sys.stdout.write(sign)
				sys.stdout.write(line)
			
			
	except IOError:
		print >> sys.stderr, 'An error occurred with ', ldif_local_tmp_file_to_read, \
			
def compare_two_objects(list_with_attributes_object1, list_with_attributes_object2, original_stdout, original_ldif_file_name, sign):
	
	not_found_attributes1 = []
	not_found_attributes2 = []
	
	for attribute in list_with_attributes_object1:
		if attribute not in list_with_attributes_object2:
			not_found_attributes1.append(attribute)
			
	for attribute in list_with_attributes_object2:
		if attribute not in list_with_attributes_object1:
			not_found_attributes2.append(attribute)
	
	if not_found_attributes1 or not_found_attributes2:

		sign = change_sign(sign)
		sys.stdout.write(" ")
		sys.stdout.write(list_with_attributes_object1[0])

		for attribute in not_found_attributes1:
			sys.stdout.write(sign)
			sys.stdout.write(attribute)

		sign = change_sign(sign)
		for attribute2 in not_found_attributes2:
			sys.stdout.write(sign)
			sys.stdout.write(attribute2)

		
def change_sign(sign):
	if (sign == "+"):
		sign = "-"
	else:
		sign = "+"
	return sign
	
if __name__ == '__main__':
	main()