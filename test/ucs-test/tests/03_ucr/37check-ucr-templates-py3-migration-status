#!/usr/share/ucs-test/runner bash
## desc: Checking for modified UCR templates
## tags:
##  - basic
##  - apptest
## exposure: careful

# Install dependencies: We decided to do this within this script, because we
# can than simply delete it after the python3 migration has finished.  Note:
# The debian python-coverage and python3-coverage binary packages install files
# with that name under /usr/bin/ - whereas pip simply calls these binaries
# coverage2 and coverage3
if test -x /usr/bin/python2-coverage && test -x /usr/bin/python3-coverage; then
    export PY2_COV=python2-coverage
    export PY3_COV=python3-coverage
else
    pip install coverage
    pip3 install coverage

    export PY2_COV=coverage2
    export PY3_COV=coverage3
fi

# safe the following awk script to disk:
cat <<"AWK" > /tmp/check-between.awk 
#!/usr/bin/env -S awk -f between.awk test.conf
BEGIN {
    # in order to behave as univention/config_registry/handler.py we have to
    # prepend each code section with a header, initialized as a string
    # variable:
    preamble = "# -*- coding: utf-8 -*-"                                    \
        "\n" "import univention.config_registry"                            \
        "\n" "configRegistry = univention.config_registry.ConfigRegistry()" \
        "\n" "configRegistry.load()"                                        \
        "\n" "# for compatibility"                                          \
        "\n" "baseConfig = configRegistry"
    exit_code = 0
}
END { exit exit_code }
# if start is 0 and we found a @!@-line: set start
!start && /@!@/ { start = 1 ; next }
# if start is set (and we still are within a code section) and there comes a @!@
start && /@!@/ {
    section++
    # filename
    print "|" section
    print "|" ARGV[1]
    # number of lines contained
    print "|" lines
    # write header and code into a file
    system("rm -f /tmp/cover.py")
    print preamble "\n" code > "/tmp/cover.py" ; close("/tmp/cover.py")
    # execute code coverage for python2. NOTE: debian has symlinked sh->dash,
    # awk uses sh to call any script, but we want bash
    cmd = "bash -c \"rm -f .coverage ;" \
          "$PY2_COV run --timid --include /tmp/cover.py /tmp/cover.py" \
	  "  &>/tmp/py2.out && echo \|✅ || echo \|❎" \
          "; echo -n \| ; $PY2_COV report | egrep -o [0-9]+%\$ || echo ❓ \""
    print code | cmd ; close(cmd)
    # same thing (coverage) for python3. NOTE: egrep finds within the
    # coverage report the only line ending with a percent value
    cmd = "bash -c \"rm -f .coverage ;" \
          "$PY3_COV run --timid --include /tmp/cover.py /tmp/cover.py" \
	  "  &>/tmp/py3.out && echo \|✅ || echo \|❎" \
          "; echo -n \| ; $PY3_COV report | egrep -o [0-9]+%\$ || echo ❓ \""
    print code | cmd ; close(cmd)
    # compare what output both runs produced and if diff returns with an exit
    # code unequal to zero it means that there were differences in both files
    if (system("diff -q /tmp/py[23].out 2>&1 >/dev/null") == 0) {
        print "|✅"
    } else {
        print "|❎"
        exit_code=127
    }
    # separate table columns by a blank line
    print ""
    # reinit for next run...
    code = ""
    lines = 0
    start = 0
    fflush("/dev/stdout")
    next
}
# if start is set and we have not yet found its end: append line to the code
# variable and increment the code line counter
start { code = code "\n" $0 ; lines++ }
AWK

# find all templates and create a markdown table. first prints the markdown
# table header. NOTE: the markdown dialect is asciidoctor, because that allows
# table column definitions to span multiple lines
(
  echo "|==="
  echo "|section|filename|code lines|python2|coverage|python3|coverage|output identical"
  let total=0
  let success=0
  for F in $(find /etc/univention/templates/ -type f); do
     let total=$(expr $total + 1)
     awk -f /tmp/check-between.awk "$F" && let success=$(expr $success + 1)
  done
  echo "|==="
  echo $success/$total successful
) |& tee $0.md

# vim:set ft=sh:awk:
