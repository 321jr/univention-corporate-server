#!/usr/share/ucs-test/runner python
## desc: Check whether several parallel smbclient authentifications are possible
## roles:
##  - domaincontroller_master
##  - domaincontroller_backup
##  - domaincontroller_slave
## packages:
##  - univention-samba
##  - python-pexpect
## exposure: safe

import os
import pexpect
import string
import sys
import atexit
import univention.config_registry
import random
import subprocess
import time
from univention.testing.ldap import wait_for_replication
ucr = univention.config_registry.ConfigRegistry()
ucr.load()

def initValues():
	
	try:
		totalRounds=int(os.getenv('smbauth_totalRounds'))
	except Exception, e:
		totalRounds=3
	try:
		amountPerRound=int(os.getenv('smbauth_amountPerRound'))
	except Exception, e:
		amountPerRound=8
	try:
		roundTime=int(os.getenv('smbauth_roundTime'))
	except Exception, e:
		roundTime=5
	try:
		delay=int(os.getenv('smbauth_delay'))
	except Exception, e:
		delay=5


	parameter=(totalRounds,amountPerRound,roundTime,delay)
	return parameter

def get_unique_username():
	"""returns a random username that is not used."""
	while True:
		randomname = "T%x" % (random.getrandbits(44),)
		# this equivalent to
		# univention-directory-manager users/user list | sed -rne "s_^\s+username:\s+(.*)$_\1_p"
		udm = subprocess.Popen(["/usr/sbin/udm-test", "users/user", "list"], stdout=subprocess.PIPE)
		sed = subprocess.Popen(["sed", "-rne", "s_^\s+username:\s+(.*)$_\1_p"], stdin=udm.stdout, stdout=subprocess.PIPE)
		stdout, stderr = sed.communicate()
		for username in stdout:
			if randomname == username.strip(): # collision
				break # continue while
		else: # "for" did not "break"
			return randomname # randomname is unique

def create_user(username, password):
	mailaddress = "%s@%s" % (username, ucr["domainname"])
	udm = subprocess.Popen(["udm-test",
				"users/user", "create",
				"--set", "password=%s" % password,
				"--set", "username=%s" % username,
				"--set", "firstname=%s" % username,
				"--set", "lastname=%s" % username,
				"--set", "groups=cn=Administrators,cn=groups,%(ldap/base)s" % ucr,
				"--position", "cn=users,%(ldap/base)s" % ucr,])
	return udm.wait() == 0

def cleanup(username,homedir_mount):
	if homedir_mount == "None":
                univention.config_registry.handler_unset(['homedir/mount'])
	else:
                univention.config_registry.handler_set(['homedir/mount=%s' % homedir_mount])

	udm = subprocess.Popen(["udm-test",
				"users/user", "remove",
				"--dn", "uid=%s,cn=users,%s" % (username, ucr["ldap/base"],)])

		
	return udm.wait() == 0


def smbclient(username,password,number,innerDelay):
	for i in range(number):
#		print '/usr/bin/smbclient -U%s%%%s //localhost/sysvol' % (username,password)
		subprocess.Popen(["/usr/bin/smbclient", "-U%s%%%s" % (username,password), "//localhost/netlogon"],stdin=subprocess.PIPE)
		time.sleep(innerDelay[i])

def calculateInnerDelay(roundTime,amountPerRound):
	delayArray=[]
	sum1=0
	sum2=0

#create a random number for every authentification at startup
	for i in range(amountPerRound):
		randomNumber=random.randrange(1,1000,1)
		delayArray.append(randomNumber)
		sum1=sum1+randomNumber

#adjust numbers so that the sum of them equals $startTime,
#hence authentifications start in this time interval 
	for i in range(amountPerRound):
		delayArray[i]=float(delayArray[i])/sum1*roundTime
		sum2=sum2+delayArray[i]
	return delayArray

def checkResult(expectedResult):
	for i in range(20):

		output = pexpect.run('/bin/bash -c "smbstatus 2>&1 | grep -c netlogon"')
		try:
			output_int=int(output)
		except Exception, e:
			print "Result was not an integer!"
			sys.exit(1)
		if output_int == expectedResult:
			return output_int
		time.sleep(1)
		
	return output_int


if __name__ == "__main__":
	username = get_unique_username()
	print 'Using username "%s"' % username
	password="univention"
	if not create_user(username, password):
		print 'Could not create user "%s" with password "%s"' % (username, password,)
		sys.exit(120) # Transient error

	homedir_mount = "%s" % (ucr["homedir/mount"])
	univention.config_registry.handler_set(['homedir/mount=false'])

	atexit.register(cleanup, username, homedir_mount)

	wait_for_replication()

	(totalRounds,amountPerRound,roundTime,delay)=initValues()
	innerDelay=calculateInnerDelay(roundTime,amountPerRound)

	for index in range(totalRounds):
		smbclient(username,password,amountPerRound,innerDelay)    
#	time.sleep(20)
	expectedResult=amountPerRound*totalRounds
	result=checkResult(expectedResult)
	print "%s of %s have been successfull." % (result,expectedResult)
	if result == expectedResult:
		sys.exit(0)
	else:
		sys.exit(1)


