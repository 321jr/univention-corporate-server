#!/usr/share/ucs-test/runner python2.6
## desc: Test slapd for a correct stop and start
## tags: [basic]
## roles:
##  - domaincontroller_master
##  - domaincontroller_backup
##  - domaincontroller_slave
## packages:
##  - slapd
## exposure: dangerous

import sys
import subprocess
from os.path import basename
from univention.config_registry import ConfigRegistry

RETURN_PASS_CODE = 100
RETURN_FAIL_CODE = 110

def main():
	"""A main method stores almost completely code."""
	return_code = None # return code for
	exit_code = RETURN_PASS_CODE # use for exitcode of the entire test, in further code it will be set only to RETURN_PASS_CODE
	# List of services to be stopped and started
	service_path = "/etc/init.d/slapd"
	service_binarys = "/usr/sbin/slapd"
	server_roles = [ 'domaincontroller_master', 'domaincontroller_backup', 'domaincontroller_slave', ]
	print "Check if services can be correctly stopped."

	ucr = ConfigRegistry()
	ucr.load() # load whole dict
	ldap_schema_export_server_role = ucr.get("server/role")
	base_name = basename(service_path) # basename of service_path

	try:
		print "Check if we can test the service", ldap_schema_export_server_role, "on server role", base_name

		found = False
		for server_role in server_roles: # checks if an server role matches any role in the server_roles list
			if ldap_schema_export_server_role == server_role:
				found = True # if at least the is one match

		if found:
			# stop the process
			if not control_process(base_name, service_path, "stop"):
				exit_code = RETURN_FAIL_CODE
			print "Done."

			print "Check if the process has been stopped."
			if not check_process(service_binarys, "stop"):
				exit_code = RETURN_FAIL_CODE

			# start the prcocess
			if not control_process(base_name, service_path, "start"):
				exit_code = RETURN_FAIL_CODE

			print "Check if the process has been started."
			if not check_process(service_binarys, "start"):
				exit_code = RETURN_FAIL_CODE
		else:
			print "No server role matched. Skipping test."
			sys.exit(RETURN_FAIL_CODE) # test failed
	except OSError, error:
		print >> sys.stderr, "An error occured with: %s" % (error, )
		sys.exit(RETURN_FAIL_CODE)

	sys.exit(exit_code) # exit with appropriate returncode

def check_process(process_name, status):
	"""The method Check whether or not the given service/process-name is running."""
	try:
		process_one = subprocess.Popen(["ps", "axu", ], stdout=subprocess.PIPE) # command for first PIPE
		process_to_pipe_grep_one = subprocess.Popen(["grep", process_name, ], stdin=process_one.stdout, stdout=subprocess.PIPE) # command for secon PIPE
		process_one.stdout.close()  # Allow process_one to receive a SIGPIPE if process2 exits.
		process_to_pipe_grep_two = subprocess.Popen(["grep", "-v", "grep", ], stdin=process_to_pipe_grep_one.stdout, stdout=subprocess.PIPE)
		process_to_pipe_grep_one.stdout.close()  # Allow process2 to receive a SIGPIPE if process3 exits
		output_check = process_to_pipe_grep_two.communicate()[0] # output with process
		process_to_pipe_grep_two.stdout.close()

		if status == "stop":
			if process_name not in output_check[:]:
				print "OK. The process is not active."
				return True
			else:
				print >> sys.stderr, "ERROR. The process is active. (The process could not be started)"
				return False
		else:
			if process_name in output_check[:]:
				print "OK. The process is active."
				return True
			else:
				print >> sys.stderr, "ERROR. The process is not active. (The process could not be started)"
				return False
	except subprocess.CalledProcessError, error:
		print >> sys.stderr, "An error occured with: %s" % (error, )
		return False

def control_process(process_name, service_path, command):
	"""This method tries wheather to stop or to start the given process. Depends on the 3rd given parameter."""
	try:
		print "Trying to " + command + " service ", process_name
		subprocess_command_service = subprocess.Popen([service_path, command, ], stdout=subprocess.PIPE) # subprocess (command line input)
		subprocess_command_service.wait() # waits for child process to terminate before goes on
	except subprocess.CalledProcessError, error:
		print >> sys.stderr, "An error occured with: %s" % (error, )
		return False
	return True

if __name__ == '__main__':
	main()
