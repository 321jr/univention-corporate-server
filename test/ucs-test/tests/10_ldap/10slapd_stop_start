#!/usr/share/ucs-test/runner python2.6
## desc: Test slapd for a correct stop and start
## tags: [basic]
## roles:
##  - domaincontroller_master
##  - domaincontroller_backup
##  - domaincontroller_slave
## packages:
##  - slapd
## exposure: safe

import sys
import os
import subprocess
from os.path import basename
from univention.config_registry import ConfigRegistry
#import univention.config_registry

def main():
    """A main method stores almost completely code."""
    return_code = 0

    # List of services to be stopped and started
    service_path = "/etc/init.d/slapd"
    service_binarys = "/usr/sbin/slapd"
    server_roles = [ 'domaincontroller_master', 'domaincontroller_backup', 'domaincontroller_slave', ]

    print "Check if services can be correctly stopped."

    try:
        
        ucr = ConfigRegistry()
        ucr.load() # load whole dict
        ldap_schema_export_server_role = ucr.get("server/role") # get specific key from ucr
        print ldap_schema_export_server_role
        base_name = basename(service_path) # basename of service_path
        print base_name
    
        print "Check if we can test the service", ldap_schema_export_server_role, "on server role", base_name
       
        found = False
        for server_role in server_roles: # checks if an server role matches any role in the server_roles list
            if ldap_schema_export_server_role == server_role:
                found = True # if at least the is one match  
            
        if found:
            # stop the process
            control_process(base_name, service_path, "stop")
            
            print "Done."
            print "Check if the process has been stopped."
            #sys.exit(110)

            # check if the process has been truly stopped
            return_code = check_process(service_binarys, "stop")

            # start the process 
            control_process(base_name, service_path, "start")

            # check if the process has been truly started
            return_code = check_process(service_binarys, "start")
        else:
            print "No - skipping test."
            sys.exit(110) # test failed
        sys.exit(return_code) # exit with appropriate returncode
    except OSError, error:
        print >> sys.stderr, "An error occured with: %s" % (error, )
        sys.exit(110) # exitcode if something went wrong
        
def check_process(process_name, status):
    """The method Check whether or not the given service/process-name is running."""
    popen_string = "ps axu | grep " + process_name + "| grep -v grep"
    subprocess_check = "subprocess" + process_name
    subprocess_check = os.popen(popen_string).read()
    
    if status == "stop":
        if process_name not in subprocess_check[:]:
            print "OK. The process is not active."
            return 100
        else:
            print >> sys.stderr, "ERROR. The process is active. (The process could not be started)"
            return 110
    else:
        if process_name in subprocess_check[:]:
            print "OK. The process is active."
            return 100
        else:
            print >> sys.stderr, "ERROR. The process is not active. (The process could not be started)"
            return 110

def control_process(process_name, service_path, command):
    """This method tries wheather to stop or to start the given process. Depends on the 2nd given parameter."""
    print "Trying to " + command + " service ", process_name
    subprocess_command_service = subprocess.Popen([service_path, command, ],
    stdout=subprocess.PIPE) # subprocess (command line input)
    subprocess_command_service.wait() # waits for child process to terminate before goes on
    return subprocess_command_service.returncode
 
if __name__ == '__main__':
   main()
