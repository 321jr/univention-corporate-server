#!/usr/share/ucs-test/runner bash
## desc: univention-admingrp-user-passwordreset (grp in grp) (Bug #25408)
## bugs: [25408]
## roles:
##  - domaincontroller_master
##  - domaincontroller_backup
## packages:
##  - univention-admingrp-user-passwordreset
## exposure: dangerous

. "$TESTLIBPATH/base.sh" || exit 1
. "$TESTLIBPATH/user.sh" || exit 1
. "$TESTLIBPATH/group.sh" || exit 1
. "$TESTLIBPATH/random.sh" || exit 1

eval "$(ucr shell)"

cleanup_mail_domain () {

  if [[ "$setdomain" -ne 0 ]]; then
	  if ! udm mail/domain remove --dn "cn=$domainname,$ldap_base" ; then
		  echo "Could not remove main/domain cn=$domainname,$ldap_base. Continue testing..."
	  fi
  fi
}

# create domain part in configured mail domains list
setdomain=1
if ! udm mail/domain create --set name=$domainname ; then
	echo "Mail/domain object already exists or could not be created. Continue testing..."
	setdomain=0
fi

trap cleanup_mail_domain EXIT

# create helpdesk group
G_HELPDESK=$(group_randomnameme)
if ! group_create $G_HELPDESK ; then
    echo "cannot create G_HELPDESK group $G_HELPDESK"
	fail_test 140
    exit "$RETVAL"
fi
# create new user
U_HELPDESK=$(user_randomname)
if ! user_create $U_HELPDESK ; then
    echo "cannot create U_HELPDESK user $U_HELPDESK"
    fail_test 140
    exit "$RETVAL"
fi

# add user to corresponding group
udm groups/group modify --dn "$(group_dn $G_HELPDESK)" --append users="$(user_dn $U_HELPDESK)"

# create second helpdesk group
G_HELPDESK_B=$(group_randomnameme)
if ! group_create $G_HELPDESK_B ; then
    echo "cannot create G_HELPDESK_B group $G_HELPDESK_B"
	fail_test 140
    exit "$RETVAL"
fi
# create new user
U_HELPDESK_B=$(user_randomname)
if ! user_create $U_HELPDESK_B ; then
    echo "cannot create U_HELPDESK_B user $U_HELPDESK_B"
    fail_test 140
    exit "$RETVAL"
fi

# add user to corresponding group
udm groups/group modify --dn "$(group_dn $G_HELPDESK_B)" --append users="$(user_dn $U_HELPDESK_B)"
# create nested group
udm groups/group modify --dn "$(group_dn $G_HELPDESK)" --append nestedGroup="$(group_dn $G_HELPDESK_B)"

# create new protected test user
U_PROT=$(user_randomname)
if ! user_create $U_PROT ; then
    echo "cannot create U_PROT user $U_PROT"
	fail_test 140
    exit "$RETVAL"
fi

# create new unprotected test user
U_UNPROT=$(user_randomname)
if ! user_create $U_UNPROT ; then
    echo "cannot create U_UNPROT user $U_UNPROT"
	fail_test 140
    exit "$RETVAL"
fi

# do some cleanup when exiting
cleanup() {
	echo "==> performing cleanup"
	ucr set ldap/acl/user/password/change=no \
		ldap/acl/user/passwordreset/protected/uid="$old_ldap_acl_user_passwordreset_protected_uid" \
		ldap/acl/user/passwordreset/attributes="$old_ldap_acl_user_passwordreset_attributes"
	if [ -n "$old_ldap_acl_user_passwordreset_accesslist_groups_dn" ] ; then
		ucr set ldap/acl/user/passwordreset/accesslist/groups/dn="$old_ldap_acl_user_passwordreset_accesslist_groups_dn"
	fi

	/etc/init.d/slapd crestart

	for user in $U_HELPDESK $U_HELPDESK_B $U_PROT $U_UNPROT ; do
		user_remove $user
	done

	for grp in $G_HELPDESK $G_HELPDESK_B ; do
		group_remove $grp
	done

	resetPwd "Administrator"

	cleanup_mail_domain

	exit "$RETVAL"
}

# has user $1 access to reset password of user $2 ?
hasPwdAccess () {
	local adminuser="$1"
	local targetuser="$2"
	local testpwd="$(random_chars 12 "${_lowerletters}")"
	local pwd="${3:-$testpwd}"
	# udm call has to be last command of function
	udm users/user modify --binddn "uid=${adminuser},cn=users,$ldap_base" --bindpwd univention --dn "uid=${targetuser},cn=users,$ldap_base" --set password="$pwd" --set overridePWHistory=1 --set overridePWLength=1
}

# reset password to univention for user $1
resetPwd() {
	local targetuser="$1"
	# udm call has to be last command of function
	udm users/user modify --dn "uid=${targetuser},cn=users,$ldap_base" --set password="univention" --set overridePWHistory=1 --set overridePWLength=1
}

# backup
old_ldap_acl_user_passwordreset_accesslist_groups_dn="$ldap_acl_user_passwordreset_accesslist_groups_dn"
old_ldap_acl_user_passwordreset_protected_uid="$ldap_acl_user_passwordreset_protected_uid"
old_ldap_acl_user_passwordreset_attributes="$ldap_acl_user_passwordreset_attributes"

# prepare test
ucr set ldap/acl/user/passwordreset/accesslist/groups/dn="$(group_dn $G_HELPDESK)" \
	ldap/acl/user/passwordreset/protected/uid="Administrator,$U_PROT" \
	ldap/acl/nestedgroups=no

/etc/init.d/slapd restart

trap cleanup EXIT

echo "==> test if helpdesk can reset password of unprotected user"
if ! hasPwdAccess "$U_HELPDESK" "$U_UNPROT" ; then
	echo "helpdesk $U_HELPDESK cannot set user password"
	fail_test 1
	exit "$RETVAL"
fi

echo "==> test if nested group helpdesk can reset password of unprotected user"
if hasPwdAccess "$U_HELPDESK_B" "$U_UNPROT" ; then
	echo "nested group helpdesk $U_HELPDESK_B can set user password - should not"
	fail_test 1
	exit "$RETVAL"
fi

# enable nested groups checks
ucr set	ldap/acl/nestedgroups=yes
/etc/init.d/slapd restart

echo "==> test if helpdesk can reset password of unprotected user"
if ! hasPwdAccess "$U_HELPDESK" "$U_UNPROT" ; then
	echo "helpdesk $U_HELPDESK cannot set user password"
	fail_test 1
	exit "$RETVAL"
fi

echo "==> test if nested group helpdesk can reset password of unprotected user"
if ! hasPwdAccess "$U_HELPDESK_B" "$U_UNPROT" ; then
	echo "nested group helpdesk $U_HELPDESK_B cannot set user password"
	fail_test 1
	exit "$RETVAL"
fi

exit "$RETVAL"
