#!/usr/share/ucs-test/runner bash
## desc: Check whether several parallel smbclient authentifications are possible
## exposure: safe
## packages:
##  - univention-samba4
## roles:
## - domaincontroller_master
## - domaincontroller_backup
## - domaincontroller_slave
## - memberserver

. "$TESTLIBPATH/master.sh" || exit 137
. "$TESTLIBPATH/base.sh" || exit 137
. "$TESTLIBPATH/shares.sh" || exit 137
. "$TESTLIBPATH/user.sh" || exit 137

SAMBA="true"
MAIL="false"
KERBEROS="true"
PERSON="false"
POSIX="true"

#Parameters for configuration:
#	smbauth_totalRounds: amount of rounds (default=3)
#	
#	smbauth_amountPerRound: amount of authentifications per round (default=10)
#	
#	smbauth_roundTime: defines the time in which all authentifications in one
#		round are triggered (default=1)
#
#	$smbauth_delay: delay between each round (default=1)

trap cleanup INT TERM EXIT

#amount of rounds
if [ ! -z $smbauth_totalRounds  ] && [ $smbauth_totalRounds -gt 0  ] && [ $smbauth_totalRounds -lt 100 ]
then 
    totalRounds=$smbauth_totalRounds
else
    totalRounds=3 
fi


#defines how many authentifications are triggered for one round
#amountPerRound=8
if [ ! -z $smbauth_amountPerRound ] && [ $smbauth_amountPerRound -gt 0 ] && [ $smbauth_amountPerRound -lt 100 ];then
    amountPerRound=$smbauth_amountPerRound
else
    amountPerRound=8
fi  

#the total number of authentifications
let amount=$totalRounds*$amountPerRound

#defines the time in which all authentifications in one round are triggered
if [ ! -z $smbauth_roundTime ] && [ $smbauth_roundTime -gt 0 ] && [ $smbauth_roundTime -lt 100 ];then
    roundTime=$smbauth_roundTime
else
    roundTime=5
fi

#delay between each round
if [ ! -z $smbauth_delay ] && [ $smbauth_delay -gt 0 ] && [ $smbauth_delay -lt 100 ];then
    delay=$smbauth_delay
else
    delay=5
fi

#define user
username="$(user_randomname)"
password=univention

function smbc
{
    python -c '
import subprocess,sys,time
subprocess.Popen(["/usr/bin/smbclient4", "-U%s%%%s" % (sys.argv[1],sys.argv[2]), "//localhost/sysvol"])
' "$username" "$password"
}

function start_round
{

    let i=0
    while [ $i -lt $amountPerRound  ]
    do
	smbc > /dev/null
    	echo Nr. $i
	sleep ${delayArray[$i]}

    	let i=$i+1
    done
	
    let roundIndex=$roundIndex+1

    if [ $roundIndex -ne $totalRounds ]; then
	echo "Wait for $delay seconds"
    	sleep $delay
	start_round
    fi
}

function calculate_startdelay
{
    sum=0
    sum2=0

	#create a random number f√ºr every authentification at startup
    for ((j=0;j<amountPerRound;j++))
    do
        delayArray[$j]=$(($RANDOM%9999+1))
        delayArray[$j]=$(echo "scale=5;${delayArray[j]}/10000" | bc)
        sum=$(echo "scale=5;$sum+${delayArray[$j]}" | bc)
    done

	#adjust numbers so that the sum of them equals $startTime,
	#hence authentifications start in this time interval 
    for ((j=0;j<amountPerRound;j++))
    do
        delayArray[$j]=$(echo "scale=5;${delayArray[$j]}/$sum*$roundTime" | bc)
	
        sum2=$(echo "scale=5;$sum2+${delayArray[$j]}" | bc)
    done
}

function cleanup
{
    user_remove "$username"
    pids=($(ps aux | grep "smbclient4" | grep -v grep | grep "$username" | awk '{print $2}'))

    for pid in ${pids[*]} 
    do
	kill -9 "$pid"
    done
    stty sane
}

#Beginning
if $random;then 
    calculate_startdelay
fi

user_create "$username"

#waiting for user replcation
i=0
while true
do
    let i=$i+1
    sleep 3
    ldbsearch -H "ldap://localhost" -U"$username%$password" "cn=$username" | grep dn: && break
    if [ "$i" == 10 ]; then
	echo "TIMEOUT: The user or share could not be found in samba ldb"
	break
    fi
done

roundIndex=0
#starts the first round, this function works recursively.
start_round


#Calculate result
result="$(smbstatus | grep -c "$username")"		
i=0
while true
do
    let i=$i+1
    sleep 1
    result="$(smbstatus | grep -c "$username")"		
    echo "Result: $result"
    if [ "$result" -ge "$amount" ]; then
	echo $i
	echo "Result: $result"
	break
    fi
    if [ "$i" == 40 ]; then
        fail_test 1 "Only $result of $amount authentifications have been successful"
	break
    fi
done

exit $RETVAL

# vim: set filetype=sh tabstop=4 :
