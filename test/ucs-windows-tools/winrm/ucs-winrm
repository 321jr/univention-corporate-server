#!/usr/bin/python2.7
# -*- coding: utf-8 -*-
#
# Copyright (C) 2010-2016 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.

import sys
import os
import argparse
import winrm
import inspect
import socket
import time
import functools
import ConfigParser
import glob
import base64
import pkgutil

from functools import partial

COMMAND_DIR = '/usr/share/ucs-winrm/scripts'

if os.path.exists('./scripts'):
	sys.path.append('./scripts')
	COMMAND_DIR= './scripts'

class UcsWinFail(Exception):
	pass

class RedirectStdOut(object):
	def __init__(self, stdout=None):
		self._stdout = stdout or sys.stdout

	def __enter__(self):
		self.old_stdout = sys.stdout
		self.old_stdout.flush()
		sys.stdout = self._stdout
	
	def __exit__(self, exc_type, exc_value, traceback):
	    self._stdout.flush()
	    sys.stdout = self.old_stdout

class UcsWin(object):

	def __init__(self):

		# get commands
		self.commands = dict()
		for importer, package_name, _ in pkgutil.iter_modules([COMMAND_DIR]):
			full_package_name = '%s.%s' % (COMMAND_DIR, package_name)
			if full_package_name not in sys.modules:
				module = importer.find_module(package_name).load_module(full_package_name)
				if not hasattr(module, 'name') or not hasattr(module, 'description'):
					continue
				self.commands[module.name] = dict(description=module.description, module=module)

		# parser
		self.parser = argparse.ArgumentParser( description='Run various commands on windows clients')
		self.parser.usage = '%(prog)s COMMAND [OPTIONS]\n'
		self.parser.usage += 'Known commands are:\n'
		for i in self.commands:
			self.parser.usage += '\t%s - %s\n' % (i, self.commands[i]['description'])
		self.parser.add_argument('command', help='Subcommand to run')

		# command?
		args = self.parser.parse_args(sys.argv[1:2])
		if not args.command in self.commands:
			print 'ERR: Unrecognized command'
			self.parser.print_help()
			sys.exit(1)

		# config file
		self.config = ConfigParser.ConfigParser()
		self.config.read(os.path.join(os.environ['HOME'], '.ucs-winrm.ini'))

		# global options
		self.parser.add_argument('--client',
			default=self.get_param_default('client'), help='The IP of the windows client')
		self.parser.add_argument('--user',
			default=self.get_param_default('user'), help='username')
		self.parser.add_argument('--password',
			default=self.get_param_default('password'), help='password')
		self.parser.add_argument('--debug', action='store_true',
			default=self.get_param_default('debug', default=False), help='enable debug')
		self.parser.add_argument('--krb5', action='store_true',
			default=self.get_param_default('krb5', default=False), help='use kerberos authentication')

		# make module a method of myself
		for name in self.commands:
			module = self.commands[name]['module']
			setattr(self.__class__, module.name, partial(self.__run_module, module))
	
		# run command
		getattr(self, args.command)()

	def __run_module(self, module, **kwargs):
		if not kwargs:
			if hasattr(module, 'args'):
				for arg in module.args:
					default = self.get_param_default(arg)
					if not 'default' in module.args[arg]:
						 module.args[arg]['default'] = self.get_param_default(arg)
					self.parser.add_argument('--' + arg, **module.args[arg])
			self.args = self.parser.parse_args()
			self.__check_args()

		# execute pre hook
		if hasattr(module, 'pre'):
			module.pre(self)

		if hasattr(module, 'ps'):
			cmd = module.ps % kwargs if kwargs else module.ps % vars(self.args)
			self.run(cmd, ps=True, verbose=True)

		# execute post hook
		if hasattr(module, 'post'):
			module.post(self)

	def __check_args(self):
		args = vars(self.args)
		for i in args:
			if self.args.krb5 and i == 'password':
				# password not requierd if kerberos is used
				continue
			if args[i] is None:
				print 'ERR: argument %s required!' % i
				self.parser.print_help()
				sys.exit(1)

	def get_param_default(self, parameter, default=None):
		val = None
		# check env variable
		env = 'WINRM_' + parameter.replace('-', '_').upper()
		val = os.environ.get(env)
		if self.config.has_section('default') and self.config.has_option('default', parameter):
			val = self.config.get('default', parameter)
		if val is None:
			val = default
		return val

	##########
	# helper #
	##########

	def run(self, command, ps=False, verbose=False, winrm_warnings=False):
		if self.args.krb5:
			s = winrm.Session(self.args.client, auth=(self.args.user, None), transport='kerberos')
		else:
			s = winrm.Session(self.args.client, auth=(self.args.user, self.args.password), transport='plaintext')
		if self.args.debug:
			print 'running command:\n%s' % command
		if ps:
			# run_ps hits the windows Maximum Length of Command Line String
			w_file = 'c:\\.tmp.winrm-ucs.ps1'
			s.run_ps('If (Test-Path "%s") { Remove-Item "%s" }' % (w_file, w_file))
			# copy script
			_chunks = 2500
			_b64 = command.encode('base64').replace('\n', '')
			for i in range(0, len(_b64), _chunks):
				_r = s.run_ps('[System.IO.File]::AppendAllText("%s", "%s")' % (w_file, _b64[i:i+_chunks]))
				if _r.status_code != 0:
					raise UcsWinFail('failed to copy command \ncode: %s\nout: %s\nerr: %s' % (_r.status_code, _r.std_out, _r.std_err))
			# run script, ignore some winrm warngins on stdout
			_cmd = '''
				$ErrorActionPreference = "Stop"
				$content = [IO.File]::ReadAllText("%s")
				$code = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($content))
				[Threading.Thread]::CurrentThread.CurrentUICulture = 'en-US'; Invoke-Expression $code
			''' % w_file
			if winrm_warnings:
				with RedirectStdOut(stdout=open(os.devnull, 'w')):
					r = s.run_ps(_cmd)
			else:
				r = s.run_ps(_cmd)
			s.run_ps('If (Test-Path "%s") { Remove-Item "%s" }' % (w_file, w_file))
		else:
			r = s.run_cmd(command)
		if r.status_code != 0:
			raise UcsWinFail('command %s failed with\ncode: %s\nout: %s\nerr: %s' % (command, r.status_code, r.std_out, r.std_err))
		if verbose is True or self.args.debug:
			print r.std_out

	def client_reachable(self):
		try:
			s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			s.settimeout(2)
			s.connect((self.args.client, 5985))
			return True
		except socket.error, e:
			return False

	def wait_until_client_is_gone(self, timeout=120):
		for i in range(timeout):
			if not self.client_reachable():
				return True
			time.sleep(1)
		raise UcsWinFail('wait_until_client_is_gone for %s failed (timeout=%s)' % (self.args.client, timeout))

	def wait_for_client(self, timeout=120):
		for i in range(timeout):
			if self.client_reachable():
				return True
			time.sleep(1)
		raise UcsWinFail('wait_for_client for %s failed (timeout=%s)' % (self.args.client, timeout))

if __name__ == '__main__':
	UcsWin()
