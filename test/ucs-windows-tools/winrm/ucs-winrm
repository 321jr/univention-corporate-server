#!/usr/bin/python2.7
# -*- coding: utf-8 -*-
#
# Copyright (C) 2010-2016 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.

import sys
import os
import argparse
import winrm
import inspect
import socket
import time
import functools
import ConfigParser
import glob
import base64

COMMAND_DIR = '/usr/share/ucs-winrm/scripts'

if os.path.exists('./scripts'):
	COMMAND_DIR= './scripts'

class UcsWinFail(Exception):
	pass

# command decorator
def wcommand(desc, *args, **kw):
	parameters = kw.get('args', [])
	def wrapper(func):
		# indicate that this is a command
		func._command = True
		func._desc = desc
		@functools.wraps(func)
		def func_wrapper(self, *args, **kw):
			# get parameter defaults
			for param in parameters:
				self.parser.add_argument('--%s' % param, default=self.get_param_default(param), help=parameters[param])
			# parse args
			self.args = self.parser.parse_args()
			# check args
			self.check_args()
			# do it
			func(self, *args, **kw)
		return func_wrapper
	return wrapper

class UcsWin(object):

	def __init__(self):

		# get commands
		self.commands = dict()
		for name, fn in inspect.getmembers(self, predicate=inspect.ismethod):
			if hasattr(fn, '_command') and hasattr(fn, '_desc'):
				self.commands[fn.__name__] = fn._desc

		# parser
		self.parser = argparse.ArgumentParser( description='Run various commands on windows clients')
		self.parser.usage = '%(prog)s COMMAND [OPTIONS]\n'
		self.parser.usage += 'Known commands are:\n'
		for i in self.commands:
			self.parser.usage += '\t%s - %s\n' % (i, self.commands[i])
		self.parser.add_argument('command', help='Subcommand to run')

		# command?
		args = self.parser.parse_args(sys.argv[1:2])
		if not args.command in self.commands:
			print 'ERR: Unrecognized command'
			self.parser.print_help()
			sys.exit(1)

		# config file
		self.config = ConfigParser.ConfigParser()
		self.config.read(os.path.join(os.environ['HOME'], '.ucs-winrm.ini'))

		# global options
		self.parser.add_argument('--client',
			default=self.get_param_default('client'), help='The IP of the windows client')
		self.parser.add_argument('--user',
			default=self.get_param_default('user'), help='username')
		self.parser.add_argument('--password',
			default=self.get_param_default('password'), help='password')
		self.parser.add_argument('--debug', action='store_true',
			default=self.get_param_default('debug', default=False), help='enable debug')
		self.parser.add_argument('--krb5', action='store_true',
			default=self.get_param_default('krb5', default=False), help='use kerberos authentication')

		# run command
		getattr(self, args.command)()

	##########
	# helper #
	##########

	def check_args(self):
		args = vars(self.args)
		for i in args:
			if self.args.krb5 and i == 'password':
				# password not requierd if kerberos is used
				continue
			if args[i] is None:
				print 'ERR: argument %s required!' % i
				self.parser.print_help()
				sys.exit(1)

	def get_param_default(self, parameter, default=None):
		val = None
		# check env variable
		env = 'WINRM_' + parameter.replace('-', '_').upper()
		val = os.environ.get(env)
		if self.config.has_section('default') and self.config.has_option('default', parameter):
			val = self.config.get('default', parameter)
		if val is None:
			val = default
		return val

	def run(self, command, ps=False, verbose=False):
		if self.args.krb5:
			s = winrm.Session(self.args.client, auth=(self.args.user, None), transport='kerberos')
		else:
			s = winrm.Session(self.args.client, auth=(self.args.user, self.args.password), transport='plaintext')
		if self.args.debug:
			print 'running command:\n%s' % command
		if ps:
			# run_ps hits the windows Maximum Length of Command Line String
			w_file = 'c:\\.tmp.winrm-ucs.ps1'
			s.run_ps('If (Test-Path "%s") { Remove-Item "%s" }' % (w_file, w_file))
			# copy script
			_chunks = 2500
			_b64 = command.encode('base64').replace('\n', '')
			for i in range(0, len(_b64), _chunks):
				_r = s.run_ps('[System.IO.File]::AppendAllText("%s", "%s")' % (w_file, _b64[i:i+_chunks]))
				if _r.status_code != 0:
					raise UcsWinFail('failed to copy command \ncode: %s\nout: %s\nerr: %s' % (_r.status_code, _r.std_out, _r.std_err))
			# run script
			r = s.run_ps('''
				$ErrorActionPreference = "Stop"	
				$content = [IO.File]::ReadAllText("%s")
				$code = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($content))
				Invoke-Expression $code
			''' % w_file)
			s.run_ps('If (Test-Path "%s") { Remove-Item "%s" }' % (w_file, w_file))
		else:
			r = s.run_cmd(command)
		if r.status_code != 0:
			raise UcsWinFail('command %s failed with\ncode: %s\nout: %s\nerr: %s' % (command, r.status_code, r.std_out, r.std_err))
		if verbose is True or self.args.debug:
			print r.std_out

	def run_predefined_command(self, *args, **kwargs):
		command_file = os.path.join(COMMAND_DIR, args[0] + '.ps1')
		command = "".join(open(command_file, 'r').readlines())
		if len(args) > 1:
			command = command % args[1]
		self.run(command, verbose=True, ps=True)

	def client_reachable(self):
		try:
			s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			s.settimeout(2)
			s.connect((self.args.client, 5985))
			return True
		except socket.error, e:
			pass
        	return False

	def wait_until_client_is_gone(self, timeout=120):
		for i in range(timeout):
			if not self.client_reachable():
				return True
			time.sleep(1)
		raise UcsWinFail('wait_until_client_is_gone for %s failed (timeout=%s)' % (self.args.client, timeout))

	def wait_for_client(self, timeout=120):
		for i in range(timeout):
			if self.client_reachable():
				return True
			time.sleep(1)
		raise UcsWinFail('wait_for_client for %s failed (timeout=%s)' % (self.args.client, timeout))

	############
	# commands #
	############

	@wcommand('Wait for client', args={'timeout':'timeout before fail'})
	def wait_for_windows(self):
		self.wait_for_client(timeout=int(self.args.timeout))

	@wcommand('Run windows batch command',
		args={'cmd':'Run batch command'})
	def run_cmd(self):
		self.run(self.args.cmd, verbose=True)


	@wcommand('Copy from windows to share',
		args={
			'src':'src in windows (c:\windows)',
			'dest':'destination on windows (u:\, \\\\server\share)'})
	def copy_from_windows(self):
		self.run_predefined_command('copy_from_windows', vars(self.args))

	@wcommand('Run windows powershell script',
		args={'cmd':'Run powershell command (\'Get-Process *\')'})
	def run_ps(self):
		self.run(self.args.cmd, verbose=True, ps=True)

	@wcommand('Set dns server for all non DHCP interfaces',
		args={'dns-server':'DNS Server to use for join'})
	def set_dns_server(self):
		self.run_predefined_command('set_dns_server', vars(self.args))

	@wcommand('Disable firewall')
	def disable_firewall(self):
		self.run_predefined_command('disable_firewall', dict(state=off))

	@wcommand('Join windows client into domain',
		args={
			'dns-server':'DNS Server to use for join',
			'domain':'The windows domain name',
			'domain-user':'Username to use for the join',
			'domain-password':'Username to use for the join'})
	def domain_join(self):
		self.run_predefined_command('set_dns_server', vars(self.args))
		self.run_predefined_command('disable_firewall', dict(state='off'))
		self.run_predefined_command('domain_join', vars(self.args))
		self.run_predefined_command('reboot')
		self.wait_until_client_is_gone()
		self.wait_for_client()
		self.run_predefined_command('domain_user_validate_password', vars(self.args))

	@wcommand('check if system is part of domain and return domain name')
	def get_domain_name(self):
		self.run_predefined_command('get_domain_name', vars(self.args))

	@wcommand('update the windows system')
	def windows_update(self):
		raise NotImplementedError
		self.run_predefined_command('windows_update', vars(self.args))

	@wcommand('Shut down windows client')
	def shutdown(self):
		self.run_predefined_command('shutdown')
		self.wait_until_client_is_gone()

	@wcommand('Change user password',
		args={
			'domain':'The windows domain name',
			'domain-user':'Username to use for the join',
			'domain-password':'Username to use for the join',
			'user-name':'change password for this userr',
			'user-password':'The password string'})
	def change_user_password(self):
		self.run_predefined_command('change_user_password', vars(self.args))

if __name__ == '__main__':
	UcsWin()
