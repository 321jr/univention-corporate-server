#!/usr/bin/python2.7
# -*- coding: utf-8 -*-
"""
Run various powershell commands on windows clients via winrm
"""
#
# Copyright (C) 2010-2017 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.

import sys
import os
import argparse
import winrm
import socket
import time
import ConfigParser
import pkgutil
import importlib

from functools import partial

COMMAND_DIR = '/usr/share/ucs-winrm/scripts'
if os.path.exists('./scripts'):
	COMMAND_DIR = './scripts'


class UcsWinFail(Exception):
	pass


class RedirectStdOut(object):

	def __init__(self, stdout=None):
		self._stdout = stdout or sys.stdout

	def __enter__(self):
		self.old_stdout = sys.stdout
		self.old_stdout.flush()
		sys.stdout = self._stdout

	def __exit__(self, exc_type, exc_value, traceback):
		self._stdout.flush()
		sys.stdout = self.old_stdout


def check_debug(f):
	def wrapped(self, *args, **kwargs):
		if self.args.debug:
			print('-> {name}({kwargs})'.format(name=f.func_name, kwargs=kwargs))
			print('   args: {args}'.format(args=vars(self.args)))
			for a in args:
				print(a)
			print
		if self.args.dry_run:
			return 0
		return f(self, *args, **kwargs)
	return wrapped


class Plugins(object):
	pass


class UcsWin(object):

	PS = '''
		$ErrorActionPreference = "Stop"
		$content = [IO.File]::ReadAllText("%(psfile)s");
		$code = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($content))
		[System.Threading.Thread]::CurrentThread.CurrentCulture = 'en-US';
		[System.Threading.Thread]::CurrentThread.CurrentUICulture = 'en-US';
		Invoke-Expression $code
	'''

	PS_AS = '''
		$strUser = '%(run_as)s'
		$strPass = ConvertTo-SecureString -String "%(run_as_password)s" -AsPlainText -Force
		$objCred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList ($strUser, $strPass)
		$content = [IO.File]::ReadAllText("%(psfile)s");
		[System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($content)) > out.ps1
		Invoke-Command -ComputerName localhost -Credential $objCred -FilePath "out.ps1"
		#Start-Job -Credential $objCred -FilePath "out.ps1"
		#Get-Job | Wait-Job
		#Get-Job | Receive-Job
		##Wait-Job $job
		##Receive-Job b $job
		##$r = Receive-Job $job
		##$r
		##get-job -job $job
	'''

	def __init__(self):

		# read config file
		self.config = ConfigParser.ConfigParser()
		self.config.read(os.path.join(os.environ['HOME'], '.ucs-winrm.ini'))

		# parser
		self.parser = argparse.ArgumentParser(description=sys.modules[__name__].__doc__)
		self.parser.usage = '%(prog)s COMMAND [OPTIONS]'
		self.subparsers = self.parser.add_subparsers(description='type %(prog)s <action> --help for further help and possible arguments', metavar='commands')

		# load plugins
		self.plugins = Plugins()
		for loader, name, is_pkg in pkgutil.walk_packages(COMMAND_DIR):
			module = importlib.import_module(name)
			if hasattr(module, 'name') and hasattr(module, 'description'):
				# global options
				subparser = self.subparsers.add_parser(module.name, description=module.description, help=module.description)
				subparser.set_defaults(func=partial(self.__run_module, module))
				subparser.add_argument('--client', default=self.__get_default('client'), help='The IP of the windows client')
				subparser.add_argument('--user', default=self.__get_default('user'), help='username')
				subparser.add_argument('--password', default=self.__get_default('password'), help='password')
				subparser.add_argument('--debug', action='store_true', default=self.__get_default('debug', default=False), help='enable debug')
				subparser.add_argument('--dry-run', action='store_true', default=self.__get_default('debug', default=False), help='dry run')
				subparser.add_argument('--run-as', default=self.__get_default('run-as', default=False), help='dry run')
				subparser.add_argument('--run-as-password', default=self.__get_default('run-as-password', default=False), help='dry run')
				# command options
				if hasattr(module, 'args'):
					for arg in module.args:
						if 'default' not in module.args[arg]:
							module.args[arg]['default'] = self.__get_default(arg)
						subparser.add_argument('--%s' % arg, **module.args[arg])
				# make module a method of myself
				setattr(self.plugins, module.name, partial(self.__run_module, module))

		self.args = self.parser.parse_args()
		self.__check_args()
		self.args.func()
		sys.exit(0)

	def __run_module(self, module, **kwargs):
		# execute pre hook
		if hasattr(module, 'pre'):
			module.pre(self)
		if hasattr(module, 'ps'):
			cmd = module.ps % kwargs if kwargs else module.ps % vars(self.args)
			self.run(cmd)
		# execute post hook
		if hasattr(module, 'post'):
			module.post(self)

	def __check_args(self):
		args = vars(self.args)
		for arg in args:
			if args[arg] is None:
				print('ERR: argument --%s required!' % arg)
				self.parser.print_help()
				sys.exit(1)

	def __get_default(self, parameter, default=None):
		val = None
		# check env variable
		env = 'WINRM_' + parameter.replace('-', '_').upper()
		val = os.environ.get(env)
		if self.config.has_section('default') and self.config.has_option('default', parameter):
			val = self.config.get('default', parameter)
		if val is None:
			val = default
		return val

	##########
	# helper #
	##########

	def copy_file(self, session, remote_file, data=None, filename=None):
		if filename:
			# TODO get data
			data = filename
		chunks = 2500
		b64 = data.encode('base64').replace('\n', '')
		# remove remote file
		with RedirectStdOut(stdout=open(os.devnull, 'w')):
			session.run_ps('If (Test-Path "%(rfile)s") { Remove-Item "%(rfile)s" }' % dict(rfile=remote_file))
		for i in range(0, len(b64), chunks):
			r = session.run_ps('[System.IO.File]::AppendAllText("%s", "%s")' % (remote_file, b64[i:i + chunks]))
			if r.status_code != 0:
				raise UcsWinFail('failed to copy command \ncode: %s\nout: %s\nerr: %s' % (r.status_code, r.std_out, r.std_err))

	@check_debug
	def run(self, command):
		s = winrm.Session(self.args.client, auth=(self.args.user, self.args.password), transport='plaintext')
		# run_ps hits the windows Maximum Length of Command Line String
		psfile = 'c:\\.tmp.winrm-ucs.ps1'
		self.copy_file(s, psfile, data=command)
		if self.args.run_as and self.args.run_as_password:
			cmd = self.PS_AS % dict(psfile=psfile, run_as=self.args.run_as, run_as_password=self.args.run_as_password)
		else:
			cmd = self.PS % dict(psfile=psfile)
		with RedirectStdOut(stdout=open(os.devnull, 'w')):
			r = s.run_ps(cmd)
		if r.status_code != 0:
			raise UcsWinFail('command %s failed with\ncode: %s\nout: %s\nerr: %s' % (command, r.status_code, r.std_out, r.std_err))
		if r.std_out:
			print(r.std_out)

	@check_debug
	def client_reachable(self):
		try:
			s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			s.settimeout(2)
			s.connect((self.args.client, 5985))
			return True
		except socket.error:
			return False

	@check_debug
	def wait_until_client_is_gone(self, timeout=120):
		for i in range(timeout):
			if not self.client_reachable():
				return True
			time.sleep(1)
		raise UcsWinFail('wait_until_client_is_gone for %s failed (timeout=%s)' % (self.args.client, timeout))

	@check_debug
	def wait_for_client(self, timeout=120):
		for i in range(timeout):
			if self.client_reachable():
				return True
			time.sleep(1)
		raise UcsWinFail('wait_for_client for %s failed (timeout=%s)' % (self.args.client, timeout))


if __name__ == '__main__':
	UcsWin()
