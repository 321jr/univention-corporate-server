#!/usr/bin/python2.7
# -*- coding: utf-8 -*-
#
# Copyright (C) 2010-2016 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.

import sys
import os
import argparse
import winrm
import inspect
import socket
import time
import functools

COMMAND_DIR = '/usr/share/ucs-winrm/scripts'

if os.path.exists('./lib'):
	COMMAND_DIR= './lib'

class UcsWinFail(Exception):
	pass

# command decorator
def wcommand(desc, *args, **kw):
	parameters = kw.get('args', [])
	def wrapper(func):
		# indicate that this is a command
		func._command = True
		func._desc = desc
		@functools.wraps(func)
		def func_wrapper(self, *args, **kw):
			# setup parameters, default is WINRM_PARAMETERNAME
			for param in parameters:
				env = 'WINRM_' + param.replace('-', '_').upper()
				help_msg = parameters[param]
				self.parser.add_argument('--%s' % param, default=os.environ.get(env), help=help_msg)
			# parse args
			self.args = self.parser.parse_args()
			# check args
			self.check_args()
			# do it
			func(self, *args, **kw)
		return func_wrapper
	return wrapper

class UcsWin(object):

	def __init__(self):

		# get commands
		self.commands = dict()
		for name, fn in inspect.getmembers(self, predicate=inspect.ismethod):
			if hasattr(fn, '_command') and hasattr(fn, '_desc'):
				self.commands[fn.__name__] = fn._desc

		# parser
		self.parser = argparse.ArgumentParser( description='Run various commands on windows clients')
		self.parser.usage = '%(prog)s COMMAND [OPTIONS]\n'
		self.parser.usage += 'Known commands are:\n'
		for i in self.commands:
			self.parser.usage += '\t%s - %s\n' % (i, self.commands[i])
		self.parser.add_argument('command', help='Subcommand to run')

		# command?
		args = self.parser.parse_args(sys.argv[1:2])
		if not args.command in self.commands:
			print 'ERR: Unrecognized command'
			self.parser.print_help()
			sys.exit(1)

		# global options
		self.parser.add_argument('--client', help='The IP of the windows client')
		self.parser.add_argument('--user', help='username')
		self.parser.add_argument('--password', help='password')
		self.parser.add_argument('--debug', default=False, action='store_true', help='enable debug')
		self.parser.add_argument('--krb5', default=False, action='store_true', help='use kerberos authentication')

		# run command
		getattr(self, args.command)()


	##########
	# helper #
	##########

	def check_args(self):
		args = vars(self.args)
		for i in args:
			if self.args.krb5 and i == 'password':
				# password not requierd if kerberos is used
				continue
			if args[i] is None:
				print 'ERR: argument %s required!' % i
				self.parser.print_help()
				sys.exit(1)

	def run(self, command, ps=False, verbose=False):
		if self.args.krb5:
			s = winrm.Session(self.args.client, auth=(self.args.user, None), transport='kerberos')
		else:
			s = winrm.Session(self.args.client, auth=(self.args.user, self.args.password), transport='plaintext')
		if self.args.debug:
			print 'running command:\n%s' % command
		if ps:
			r = s.run_ps(command)
		else:
			r = s.run_cmd(command)
		if r.status_code != 0:
			raise UcsWinFail('command %s failed with %s:\n%s' % (command, r.status_code, r.std_out))
		if verbose is True or self.args.debug:
			print r.std_out

	def run_predefined_command(self, *args, **kwargs):
		command_file = os.path.join(COMMAND_DIR, args[0] + '.ps1')
		command = "".join(open(command_file, 'r').readlines())
		if len(args) > 1:
			command = command % args[1]
		self.run(command, ps=True)

	def client_reachable(self):
		try:
			s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			s.settimeout(2)
			s.connect((self.args.client, 5985))
			return True
		except socket.error, e:
			pass
        	return False

	def wait_until_client_is_gone(self, timeout=120):
		for i in range(timeout):
			if not self.client_reachable():
				return True
			time.sleep(1)
		raise UcsWinFail('wait_until_client_is_gone for %s failed (timeout=%s)' % (self.args.client, timeout))

	def wait_for_client(self, timeout=120):
		for i in range(timeout):
			if self.client_reachable():
				return True
			time.sleep(1)
		raise UcsWinFail('wait_for_client for %s failed (timeout=%s)' % (self.args.client, timeout))

	############
	# commands #
	############

	@wcommand('Run windows batch command',
		args={'cmd':'Run batch command'})
	def run_cmd(self):
		self.run(self.args.cmd, verbose=True)


	@wcommand('Copy from windows to share',
		args={
			'src':'src in windows (c:\windows)',
			'dest':'destination on windows (u:\, \\\\server\share)'})
	def copy_from_windows(self):
		self.run_predefined_command('copy_from_windows', vars(self.args))

	@wcommand('Run windows powershell script',
		args={'cmd':'Run powershell command (\'Get-Process *\')'})
	def run_ps(self):
		self.run(self.args.cmd, verbose=True, ps=True)

	@wcommand('Set dns server for all non DHCP interfaces',
		args={'dns-server':'DNS Server to use for join'})
	def set_dns_server(self):
		self.run_predefined_command('set_dns_server', vars(self.args))

	@wcommand('Disable firewall')
	def disable_firewall(self):
		self.run_predefined_command('disable_firewall', dict(state=off))

	@wcommand('Join windows client into domain',
		args={
			'dns-server':'DNS Server to use for join',
			'domain':'The windows domain name',
			'domain-user':'Username to use for the join',
			'domain-password':'Username to use for the join'})
	def domain_join(self):
		self.run_predefined_command('set_dns_server', vars(self.args))
		self.run_predefined_command('disable_firewall', dict(state='off'))
		self.run_predefined_command('domain_join', vars(self.args))
		self.run_predefined_command('reboot')
		self.wait_until_client_is_gone()
		self.wait_for_client()
		self.run_predefined_command('domain_user_validate_password', vars(self.args))

	@wcommand('Shut down windows client')
	def shutdown(self):
		self.run_predefined_command('shutdown')
		self.wait_until_client_is_gone()

if __name__ == '__main__':
	UcsWin()
