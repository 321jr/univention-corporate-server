#!/usr/bin/python
# vim:set shiftwidth=4 tabstop=4:
#
# Copyright 2013 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.

import ConfigParser
from optparse import OptionParser
import os
import paramiko
import string
import subprocess
import sys
import glob
import time
import traceback
from socket import error as socket_error
from select import select

import boto
from boto.ec2 import regions,blockdevicemapping


class VM:
	def __init__(self, section, config):
		''' Initialize a VM instance '''
		self.section = section
		self.aws_cfg = {}

		# Copy some global settings to the local VM config
		# but only if the setting is not set in the local VM section
		params = ['ec2_ami', 'ec2_security_group', 'ec2_instance_type', 'ec2_keypair', 'ec2_region', 'ec2_subnet_id', 'ec2_partition_size']
		for key in params:
			if not config.has_option(section, key):
				if config.has_option('Global', key):
					config.set(section, key, config.get('Global', key))

		for key in params + ['ec2_reuse']:
			if config.has_option(section, key):
				self.aws_cfg[key] = config.get(section, key)
					
		self.private_key = os.path.expanduser(config.get('Global', 'ec2_keypair_file'))

		# Save the profile, it will be later written to the VM
		if config.has_option(section, 'profile'):
			self.profile = config.get(section, 'profile')
		else:
			self.profile = None

		# Read and save the file lines and ignore comments
		self.files = []
		if config.has_option(section, 'files'):
			for line in config.get(section, 'files').strip().split('\n'):
				line = line.strip()
				# ignore comments
				if line.startswith('#'):
					continue
				self.files.append(line)

		# list of commands
		self.commands=[]
		i=1
		while config.has_option(section, 'command%d' % i ):
			self.commands.append(config.get(section, 'command%d' % i).strip().split('\n'))
			i = i+1

		# logfile
		for s in section, 'Global':
			if config.has_option(s, 'logfile'):
				self.logfile = os.path.expanduser(config.get(s, 'logfile'))
				break

		# Create the logfile
		if self.logfile:
			fd = open(self.logfile, 'a+')
			fd.write('Created instance %s at %s\n' % (section, time.strftime("%Y-%m-%d %H:%M:%S", time.gmtime())))
			fd.close()

	def _get_blockdevicemapping(self):
		bdm = None
		if self.aws_cfg.get('ec2_subnet_id'):
			dev_sda1 = blockdevicemapping.EBSBlockDeviceType()
			dev_sda1.size = self.aws_cfg.get('ec2_partition_size')
			bdm = blockdevicemapping.BlockDeviceMapping()
			bdm['/dev/sda1'] = dev_sda1 
		return bdm

	def start(self):
		''' Start the VM '''
		# self.ec2 = boto.connect_ec2(**self.aws_cfg)
		aws_cfg = {}
		for region in regions(**aws_cfg):
			if region.name == self.aws_cfg['ec2_region']:
				aws_cfg['region'] = region
				break

		user_data = ''

		if self.aws_cfg.get('ec2_reuse'):
			self.ec2 = boto.connect_vpc(**aws_cfg)
			reservation = self.ec2.get_all_instances(instance_ids=[self.aws_cfg.get('ec2_reuse')])[0]
		elif self.aws_cfg.get('ec2_subnet_id'):
			self.ec2 = boto.connect_vpc(**aws_cfg)
			ami = self.ec2.get_image(self.aws_cfg['ec2_ami'])
			reservation = ami.run(min_count=1,
				max_count=1,
				key_name=self.aws_cfg['ec2_keypair'],
				subnet_id=self.aws_cfg['ec2_subnet_id'],
				user_data=user_data,
				security_group_ids=[self.aws_cfg['ec2_security_group']],
				instance_type=self.aws_cfg['ec2_instance_type'],
				instance_initiated_shutdown_behavior='terminate',  # 'save'
				block_device_map = self._get_blockdevicemapping()
				)
		else:
			self.ec2 = boto.connect_ec2(**aws_cfg)
			ami = self.ec2.get_image(self.aws_cfg['ec2_ami'])
			reservation = ami.run(min_count=1,
				max_count=1,
				key_name=self.aws_cfg['ec2_keypair'],
				user_data=user_data,
				security_groups=[self.aws_cfg['ec2_security_group']],
				instance_type=self.aws_cfg['ec2_instance_type'],
				instance_initiated_shutdown_behavior='terminate',  # 'save'
				block_device_map = self._get_blockdevicemapping()
				)

		self.instance = reservation.instances[0]

		self.instance.add_tag('Name', 'Test-%s-%s' % (os.getenv('USER'), self.section))

		start = now = time.time()
		# TODO: make the timeout configurable
		timeout = 300
		while now - start < timeout:
			if self.instance.state == 'running':
				break
			if self.instance.state == 'pending':
				self._log('Pending %d...' % (timeout - now + start))
			time.sleep(10)

			try:
				self.instance.update()
			except boto.exception.EC2ResponseError, ex:
				for error in ex.errors:
					self._log('Error code: %r', error.error_code)
					if error.error_code == 'InvalidInstanceID.NotFound':
						break
				else:
					self._log('Unexcpected error waiting for instance: %s', ex)
					raise
			now = time.time()
		else:
			self._log('Timeout waiting for instance')
			raise

	def connect(self):
		''' Wait until the connection is ready '''
		self.client = paramiko.SSHClient()
		self.client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
		start = now = time.time()
		# TODO: make the timeout configurable
		timeout=300
		while now - start < timeout:
			try:
				self.client.connect(self.get_ip(),
					port=22,
					username='root',
					key_filename=self.private_key)
				break
			except socket_error, e:
				self._log('Pending %d...'  % (timeout - now + start))
				time.sleep(5)
				now = time.time()
			except paramiko.AuthenticationException, e:
				self._log('Authentication failed %d...' % (timeout - now + start))
				time.sleep(5)
				now = time.time()
			except:
				self._log('Pending %d...'  % (timeout - now + start))
				time.sleep(5)
				now = time.time()
		else:
			raise
		pass

	def create_profiles(self):
		''' Write the given profile to the instance '''
		if not self.profile:
			return

		self._open_sftp_connection()

		remote_profile = self.sftp.file('/var/cache/univention-system-setup/profile', 'w')
		print >> remote_profile, self.profile
		remote_profile.close()
		
		self._close_sftp_connection()

	def copy_files(self):
		''' Copy the given files to the instance '''
		if not self.files:
			return

		self._open_sftp_connection()

		for line in self.files:
			localfiles, remotedir = line.rsplit(' ', 1)
			expanded_files = glob.glob(os.path.expanduser(localfiles))
			self._remote_mkdir(remotedir)

			for localfile in expanded_files:
				if os.path.exists(localfile):
					f = os.path.basename(localfile)
					remfile = os.path.join(remotedir, f)
					self.sftp.put(localfile, remfile)
					self.sftp.chmod(remfile, os.stat(localfile).st_mode & 0777)

		self._close_sftp_connection()

	def _is_local_command(self, command):
		if not command:
			return False
		if command.startswith('LOCAL'):
			return True

		return False

	def _exec_local(self, cmdline):
		self._log('Execute local command: %s' % cmdline)

		self._open_logfile()
			
		rt = subprocess.call(cmdline, shell=True, stdout=self.logfile_fd, stderr=self.logfile_fd)

		self._close_logfile()

		return rt

	def _open_logfile(self):
		if self.logfile:
			self.logfile_fd = open(self.logfile, 'a+')
		else:
			self.logfile_fd = sys.stdout
		
	def _close_logfile(self):
		if self.logfile_fd:
			self.logfile_fd.close()
		self.logfile_fd = None

	def run_commands(self, phase):
		''' Run all commands for a given phase e.g. for command1 '''
		for cmdline in self.commands[phase]:
			try:
				_print_process('  %s' % cmdline)
				if self._is_local_command(cmdline):
					local_cmdline = self._remove_local_from_cmd(cmdline)
					rt = self._exec_local(local_cmdline)
				else:
					rt = self._ssh_exec(cmdline)
				if rt != 0:
					_print_done('fail (return code %s)' % rt)
				else:
					_print_done()
			except paramiko.ssh_exception.SSHException:
				self.connect()
				try:
					rt = self._ssh_exec(cmdline)
					if rt != 0:
						_print_done('fail (return code %s)' % rt)
					else:
						_print_done()
				except Exception,e:
					self._print_exception_to_file()
					_print_done('fail')
					pass
			except Exception,e:
				self._print_exception_to_file()
				_print_done('fail')
				pass
		pass

	def _remove_local_from_cmd(self, cmd):
		return string.replace(cmd, 'LOCAL', '', 1).strip()

	def _print_exception_to_file(self):
		self._open_logfile()
		traceback.print_exc(file=self.logfile_fd)
		self._close_logfile()

	def command_count(self):
		''' Retrun the  IP address of the started VM '''
		return len(self.commands)

	def is_vpc(self):
		return self.instance.vpc_id

	def get_ip(self):
		''' Retrun the IP address of the started VM '''
		if self.instance.vpc_id:
			return self.instance.private_ip_address
		else:
			return self.instance.ip_address

	def get_name(self):
		'''	Return the configured name for the VM, this is the section for
			this host in the config file '''
		return '[%s]' % self.section

	# Helper functions
	def _ssh_exec(self, command):
		'''	Execute command using ssh and writes output to logfile.'''
		transport = self.client.get_transport()
		transport.set_keepalive(15)
		session = transport.open_session()
		try:
			self._log('Execute: %s' % command)
			session.exec_command(command)
			# Close STDIN for remote command
			session.shutdown_write()
			while True:
				r_list, _w_list, _e_list = select([session], [], [], 10)
				if r_list:
					if session.recv_ready():
						data = session.recv(4096)
						self._log(data, newline=False)
						continue
					elif session.recv_stderr_ready():
						data = session.recv_stderr(4096)
						self._log(data, newline=False)
						continue
					else:
						pass  # EOF
				if session.exit_status_ready():
					break
			if session.exit_status != 0:
				self._log('*** Failed %d: %s' % (session.exit_status, command))
		finally:
			session.close()
		return session.exit_status

	def _open_sftp_connection(self):
		'''	Open the SFTP connection and save the connection as self.sftp '''
		self.sftp = self.client.open_sftp()

	def _close_sftp_connection(self):
		'''	Close the SFTP connection '''
		self.sftp.close()
	
	def _remote_mkdir(self, directory):
		'''	Helpder function to create the given directory structure through
			the SFTP connection '''
		if not directory.startswith('/'):
			return

		try:
			if os.path.exists(directory):
				mode = os.stat(directory).st_mode & 0777
			else:
				mode = 0777
			self.sftp.mkdir(directory, mode=mode)
		except IOError, e:
			self._remote_mkdir(directory.rsplit("/", 1)[0])

	# Write a message to the log file
	def _log(self, msg, newline=True):
		'''	Write a message to self.logfile '''
		if self.logfile:
			fd = open(self.logfile, 'a+')
			fd.write(str(msg))
			if newline:
				fd.write('\n')
			fd.close()
		else:
			print 'I: no logfile is configured, print to stdout'
			print msg
	
def _print_process(msg):
	'''	Print s status line '''
	if len(msg) > 64:
		print '%s..' % msg[:63],
	else:
		print '%-65s' % msg,
	sys.stdout.flush()

def _print_done(msg='done'):
	'''	Close the status line opend with _print_process '''
	print '%s' % msg
	sys.stdout.flush()


class Parser(ConfigParser.ConfigParser):
	def set_filename(self, filename):
		self._filename = filename

	def hosts(self):
		''' Gives a list of all sections expect Global '''
		hosts = []
		fp = open(self._filename, 'r')
		while True:
			line = fp.readline()
			if not line:
				break
			if line.strip() == '' or line[0] in '#;':
				continue
			mo = ConfigParser.ConfigParser.SECTCRE.match(line)
			if mo:
				sectname = mo.group('header')
				if sectname != 'Global':
					hosts.append(sectname)
		return hosts

def main():
	# A list of all VMs
	vms = []

	# Parse options and the config file
	_print_process('Parse options and config files')
	usage = '''%s [options] -c config_file ''' % sys.argv[0]
	parser = OptionParser(usage=usage)
	parser.add_option("-c", "--conf", action="store",
			dest="config_file", help="Config file for %s" % sys.argv[0])

	(options, args) = parser.parse_args()

	if not options.config_file:
		_print_done('fail (-c config_file is required)')
		sys.exit(2)
	if not os.path.exists(options.config_file):
		_print_done('fail (%s does not exist)' % options.config_file)
		sys.exit(2)

	# config parser
	config = Parser()
	config.set_filename(options.config_file)
	config.read(options.config_file)
	_print_done()

	
	_print_process('Checking for ~/.boto')

	if os.path.exists(os.path.expanduser('~/.boto')):
		_print_done()
	else:
		_print_done('fail (See http://code.google.com/p/boto/wiki/BotoConfig or https://hutten.knut.univention.de/mediawiki/index.php/UCS_EC2_Tools#.boto_Datei)')

	for host in config.hosts():
		_print_process('Creating VM [%s]' % host)
		vms.append( VM(host, config) )
		_print_done()

	# start instances
	for vm in vms:
		_print_process('Starting VM %s' % vm.get_name())
		vm.start()
		_print_done('done (IP: %s)' % vm.get_ip())

	# conenct to instances
	for vm in vms:
		_print_process('Connect to VM %s' % vm.get_name())
		vm.connect()
		_print_done()

	# replace profile variables and commands
	replace_list = []
	for vm in vms:
		replace_list.append( ('[%s_IP]' % vm.section, vm.get_ip()) )
	for vm in vms:
		if vm.profile:
			for (host_str, ip) in replace_list:
				vm.profile = vm.profile.replace(host_str, ip)
		for i in range(0,len(vm.commands)):
			for (host_str, ip) in replace_list:
				vm.commands[i] = [cmd.replace(host_str, ip) for cmd in vm.commands[i]]

	# create profiles
	for vm in vms:
		_print_process('Create profile for VM %s' % vm.get_name())
		vm.create_profiles()
		_print_done()

	# copy files
	for vm in vms:
		_print_process('Copy files to VM %s' % vm.get_name())
		vm.copy_files()
		_print_done()

	max_command = 0
	for vm in vms:
		max_command = max(max_command, vm.command_count())

	# run commands
	for phase in range(0,max_command):
		for vm in vms:
			print 'Running command phase (%d/%d) on VM %s' % (phase+1, max_command, vm.get_name())
			vm.run_commands(phase)

if __name__ == '__main__':
	main()

