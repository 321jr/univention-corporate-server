#!/bin/sh -e
#
# Univention Thin Client Basesystem
#  init script: checking for new flash images
#
# Copyright 2007-2010 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.

. /lib/lsb/init-functions

log_action_msg "Installing new Thin Client base system on flash, this may take a while"

FLAGNFSBOOT=`univention-thin-client-detect-nfsboot`

eval $(univention-config-registry shell thinclient/flash/update thinclient/flash/update/disk thinclient/flash/update/url thinclient/flash/update/image univentionDesktopServer interfaces/eth0/address hostname domainname)

if [ -z "$thinclient_flash_update" ] || [ -n "$thinclient_flash_update" -a "$thinclient_flash_update" = "no" ]; then
	echo "The UCR variable thinclient/flash/update is not set or is set to no."
	echo "If you want to use the flash update, please activate a UCR policy"
	echo "with thinclient/flash/update=yes for this Thin Client."
	log_action_end_msg 0
	exit 0
fi

if [ -z "$thinclient_flash_update_url" ]; then
	url="http://${univentionDesktopServer}/univention-thin-client-flash/"
else
	url=$thinclient_flash_update_url
fi

if [ -z "$thinclient_flash_update_image" ]; then
	image="root.img"
else
	image="$thinclient_flash_update_image"
fi

# get current version from server
echo -n "  retrieve version information ... "
new_version=$(wget -qqq -O - "$url/$image.vers")
if [ -z "$new_version" ]; then
	echo "not found"
	exit 0
else
	echo "$new_version"
fi

# Find flashdrive
if [ "$thinclient_flash_update_disk" ];
    then
    disk="$thinclient_flash_update_disk"
else
    echo -n "  search for flash disk drive ... "
    disk=""
    parts=$(sed -n '1,2d;p' < /proc/partitions | awk '{print $4;}' | grep "^[^0-9]*$")
    for i in $parts ; do
	if [ -n "$disk" ]; then
		# echo "verbose" > /proc/splash
		echo "failed"
		echo "  error: More than one disk found. Not installing base system."
		log_action_end_msg 1
		exit 1
	fi
	disk="/dev/$i"
	echo $disk
    done
fi

if [ -z "$disk" ]; then
	# echo "verbose" > /proc/splash
	echo "failed"
	echo "error: No disks found. Not installing base system."
	log_action_end_msg 1
	exit 1
fi

bootpart=${disk}1
rootpart=${disk}2

echo "	determined partitions: boot=$bootpart root=$rootpart"

mount -t ext2 $bootpart /mnt || true
trap "umount /mnt" 0
version="0"
if [ -f "/mnt/${image}.vers" ]; then
	version=$(cat "/mnt/${image}.vers")
fi

# create partition table
if [ "$version" = "0" ]; then
	umount /mnt || true
	trap - 0
	echo -n "	partioning the drive ..."
	# first partition: 16 MB, type 4 (FAT16 < 32MB), bootable
	# second partition: rest, type Linux
	sfdisk -uM -D $disk <<EOF >/dev/null 2>/dev/null
,16,L,*
,,L
EOF
	echo "done"
	if ! [ -b "$bootpart" ] || ! [ -b "$rootpart" ]; then
		echo "  error: could not find partions on flash drive."
		log_action_end_msg 1
		exit 1
	fi

	echo -n "  setting up boot partition ..."
	umount $bootpart || true
	mkfs -t ext2 $bootpart
	mount -t ext2 $bootpart /mnt
	extlinux --install /mnt
	trap "umount /mnt" 0
	echo "done"
fi

nameserver=$(cat /proc/cmdline | grep DNSSERVER | sed -e 's/.*DNSSERVER=//g' | awk '{print $1;}')
ldapserver=$(cat /proc/cmdline | grep ldapServer | sed -e 's/.*ldapServer=//g' | awk '{print "ldapServer="$1;}')
ldapport=$(cat /proc/cmdline | grep ldapPort | sed -e 's/.*ldapPort=//g' | awk '{print "ldapPort="$1;}')
vga=$(cat /proc/cmdline | grep vga | sed -e 's/.*vga=//g' | awk '{print "vga="$1;}')
quiet_cmdline=$(cat /proc/cmdline | grep " quiet" >/dev/null || true)
quiet=""
if [ -n "$quiet_cmdline" ]; then
	quiet="quiet"
fi


if [ "$version" -lt "$new_version" ]; then
	/sbin/usplash_write "TIMEOUT 0"
	# echo "verbose" > /proc/splash
    echo "	newer version available. Updating filesystem:"
    echo

    PATH_EXTLINUX=/mnt/extlinux.conf
    PATH_NETWORKCONFIG=/mnt/network.conf
    PATH_KERNEL=/mnt/linux
    PATH_INITRD=/mnt/initrd.splash
    PATH_ROOTTXT=/mnt/root.txt
    PATH_BASE=/mnt
    PATH_WGET=/usr/bin/wget
    PATH_SYNC=/bin/sync
    PATH_UMOUNT=/bin/umount
    PATH_REBOOT=/sbin/reboot
    PATH_MBR=/usr/lib/syslinux/mbr.bin

    if [ "$FLAGNFSBOOT" = "0" ] ; then
    # FLASH BOOT
	PATH_EXTLINUX=/config/extlinux.conf
	PATH_NETWORKCONFIG=/config/network.conf
	PATH_KERNEL=/config/linux
	PATH_INITRD=/config/initrd.splash
	PATH_CONFIG=/config/root.txt
	PATH_BASE=/config/
	cp /bin/sync /ramdisk
	cp /usr/bin/wget /ramdisk
	cp /bin/umount /ramdisk
	cp /sbin/reboot /ramdisk
	cp /usr/lib/syslinux/mbr.bin /ramdisk
	PATH_WGET=/ramdisk/wget
	PATH_SYNC=/ramdisk/sync
	PATH_UMOUNT=/ramdisk/umount
	PATH_REBOOT=/ramdisk/reboot
	PATH_MBR=/ramdisk/mbr.bin
    fi

    echo "default linux initrd=initrd.splash root=$rootpart DNSSERVER=$nameserver $vga $quiet splash=silent $ldapserver $ldapport" > $PATH_EXTLINUX

    # store current network configuration
    echo "FLASH_HOSTNAME=$hostname" > $PATH_NETWORKCONFIG
    echo "FLASH_DOMAIN=$domainname" >> $PATH_NETWORKCONFIG
    echo "FLASH_NAMESERVER=$nameserver" >> $PATH_NETWORKCONFIG

    echo -n "    downloading kernel image ..."
    $PATH_WGET -O $PATH_KERNEL "$url/linux"
    if [ ! "$?" = "0" ] ; then
		/sbin/usplash_write "QUIT" || true
		echo "not found"
		log_action_end_msg 1
		read
		halt
    fi
    echo "done"

    echo -n "    downloading initrd ..."
    $PATH_WGET -O $PATH_INITRD "$url/initrd.splash"
    if [ ! "$?" = "0" ] ; then
		/sbin/usplash_write "QUIT" || true
		echo "not found"
		log_action_end_msg 1
		read
		halt
    fi
    echo "done"

    echo "$rootpart" > $PATH_ROOTTXT

    echo -n "    downloading root filesystem ..."
    $PATH_WGET -O $rootpart "$url/$image"
    if [ ! "$?" = "0" ] ; then
		/sbin/usplash_write "QUIT" || true
		echo " failed"
		log_action_end_msg 1
		read
		halt
    fi
    echo "done"
    echo "$new_version" > $PATH_BASE/${image}.vers

    $PATH_UMOUNT $PATH_BASE
    $PATH_SYNC
    # create MBR on flash disk
    cat $PATH_MBR > ${disk}
    echo
    echo "The update was successful. Rebooting the system."
    log_action_end_msg 0
    log_action_msg "Rebooting"
    $PATH_REBOOT
    log_action_end_msg 0
else
    echo "	filesystem seems to be up-to-date."
fi

$PATH_UMOUNT /mnt
trap - 0

log_action_end_msg 0

