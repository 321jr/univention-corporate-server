#!/usr/bin/python2.4 -OO
#
# LTSP mount daemon
#
# Copyright (C) 2007,2008 Univention GmbH
#
# http://www.univention.de/
# 
# All rights reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# Binary versions of this file provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

import ldap, traceback
import univention_baseconfig
import glob
import sys, string, os, time, signal, shutil, re
import traceback
import glob
import os.path
import subprocess
import univention.uldap
import univention.debug as ud
import pwd

class LdapConnection:
	__lo = None
	__basedn = ''
	__binddn = ''
	__bindpw = ''

	def __init__(self):
		if not LdapConnection.__lo:
			self.connect()

	def get_basedn(self):
		return LdapConnection.__basedn

	def get_binddn(self):
		return LdapConnection.__binddn

	def __nonzero__( self ):
		return LdapConnection.__lo != None

	def __getattr__(self, attr):
		""" Delegate access to implementation """
		return getattr(LdapConnection.__lo, attr)


	def __setattr__(self, attr, value):
		""" Delegate access to implementation """
		return setattr(LdapConnection.__lo, attr, value)


	def connected(self):
		return (LdapConnection.__lo != None)


	def connect( self, host = None, port = 389, binddn = '', bindpw = '', base = None, start_tls=2 ):

		baseConfig = univention_baseconfig.baseConfig()
		baseConfig.load()

		if not host:
			host = baseConfig[ 'ldap/server/name' ]
		if not base:
			base = baseConfig[ 'ldap/base' ]

		LdapConnection.__base = base


		try:
			LdapConnection.__lo = univention.uldap.access(host, port, base, binddn, bindpw, start_tls)
		except ldap.INVALID_CREDENTIALS,ex:
			LdapConnection.__lo = None
			ud.debug( ud.LDAP, ud.ERROR, 'ldapconn: authentication failed' )
		except ldap.UNWILLING_TO_PERFORM,ex:
			LdapConnection.__lo = None
			ud.debug( ud.LDAP, ud.ERROR, 'ldapconn: authentication failed' )
		except:
			LdapConnection.__lo = None
			ud.debug( ud.LDAP, ud.ERROR, 'ldapconn: unable to get ldap connection' )

		if LdapConnection.__lo:
			ud.debug( ud.LDAP, ud.INFO, 'ldapconn: got new connection to ldap server (binddn="%s")' % binddn )
			LdapConnection.__binddn = binddn
			LdapConnection.__bindpw = bindpw

	def disconnect( self ):
		if self:
			LdapConnection.__lo.lo.unbind()
			LdapConnection.__lo = None




baseConfig=univention_baseconfig.baseConfig()
baseConfig.load()

spool_dir = "/var/lib/univention/ltsp"

poll_sleep = 3
if baseConfig.has_key('thinclient/ltsp/interval'):
	poll_sleep=int(baseConfig['thinclient/ltsp/interval'])

debug_level=1
if baseConfig.has_key('thinclient/ltsp/debug/level'):
	debug_level=int(baseConfig['thinclient/ltsp/debug/level'])

def daemon():
	try:
		pid = os.fork()
	except OSError, e:
		print 'Daemon Mode Error: %s' % e.strerror

	if (pid == 0):
		os.setsid()
		signal.signal(signal.SIGHUP, signal.SIG_IGN)
		try:
			pid = os.fork()
		except OSError, e:
			print 'Daemon Mode Error: %s' % e.strerror
		if (pid == 0):
			os.chdir("/")
			os.umask(0)
		else:
			pf=open('/var/run/univention-ltsp-mountd.pid', 'w+')
			pf.write(str(pid))
			pf.close()
			os._exit(0)
	else:
		os._exit(0)

	try:
		maxfd = os.sysconf("SC_OPEN_MAX")
	except (AttributeError, ValueError):
		maxfd = 256       # default maximum

	for fd in range(0, maxfd):
		try:
			os.close(fd)
		except OSError:   # ERROR (ignore)
			pass

	os.open("/dev/null", os.O_RDONLY)
	os.open("/dev/null", os.O_RDWR)
	os.open("/dev/null", os.O_RDWR)



def reject_file(file):
	if os.path.exists(os.path.join(spool_dir, "rejected")):
		shutil.move(file, os.path.join(spool_dir, "rejected"))
	else:
		ud.debug(ud.LDAP, ud.WARN, "univention-ltsp-mountd: Could not access rejected/ directory of LTSP spool dir")

def retire_file(file):
	if os.path.exists(os.path.join(spool_dir, "done")):
		shutil.move(file, os.path.join(spool_dir, 'done'))
	else:
		ud.debug(ud.LDAP, ud.WARN, "univention-ltsp-mountd: Could not access done/ directory of LTSP spool dir")



def track_mounts():


	baseConfig=univention_baseconfig.baseConfig()
	baseConfig.load()

	retry_rejected=0

	while True:
		change_counter=1

		mount_list = glob.glob(os.path.join(spool_dir, '*mnt'))

		for mountpoint in mount_list:
			ud.debug(ud.LDAP, ud.PROCESS, 'Found new file(s): %s' % mount_list)

			mount_file = open(mountpoint)
			mount_elements = mount_file.readlines()
			mount_file.close()

			# The format is exactly one line per mount point, e.g.
			# mount 10.200.3.65:/var/run/drives/usbdisk-sda1 /media/sda250 jmm
			#
			# 0. "mount" or "unmount"	
			# 1. The mount point on the thin client
			# 2. The mount point on the terminal server
			# 3. The user mounting the share


			chunks = mount_elements[0].split(" ")

			command = ""


			if chunks[0] == "mount":
				ud.debug(ud.LDAP, ud.PROCESS, 'mounting device, parameter: %s' % chunks)

				if not os.path.exists(chunks[2]):
					os.mkdir(chunks[2], 0700)			

				if os.path.ismount(chunks[2]):
					ud.debug(ud.LDAP, ud.WARN, "univention-ltsp-mountd: Warning: Not mounting %s since it's already an existing mount point" % chunks[2])
					reject_file(mountpoint)

				user_to_mount = chunks[3][:-1]
				uid_to_mount = pwd.getpwnam(user_to_mount)[2]
				gid_to_mount = pwd.getpwnam(user_to_mount)[3]

				command = "/usr/bin/ltspfs " + chunks[1] + " " + chunks[2]
				command += " -o allow_other,sync,default_permissions,uid=" + str(uid_to_mount) + ",gid=" + str(gid_to_mount)
				ret = subprocess.call(command, shell=True)
				if ret < 0:	
					ud.debug(ud.LDAP, ud.ERROR, "univention-ltsp-mountd: Error: Mounting %s failed" % chunks[2])
				else:
					retire_file(mountpoint)

					ldapc = LdapConnection()
					sfilter = '(&(objectClass=person)(uid=%s))' % (user_to_umount)
					sdn = ldapc.searchDn(filter = sfilter)
                                        homedir = ldapc.getAttr(sdn[0], "homeDirectory")
                                        desktop_filename = homedir[0] + "/Desktop/" + chunks[2].split("/")[-1]
                                        desktop_file = open(desktop_filename, "w")
					ldapc.disconnect()

					# TODO: Exceptions + Logging
					desktop_file.write("[Desktop Entry]\n")
					desktop_file.write("Name=Media\n")# " + chunks[3] + "\n")
					desktop_file.write("Name[de]=Medium\n")# " + chunks[3] + "\n")
					desktop_file.write("GenericName=Removable Media\n")
					desktop_file.write("GenericName[de]=Wechselmedium\n")
					desktop_file.write("URL=" + chunks[2] + "\n")
					desktop_file.write("Icon=usbpendrive_mount\n")
					desktop_file.write("Type=Link\n")
					desktop_file.close()
					
					os.chown(desktop_filename, uid_to_mount, gid_to_mount)


			elif chunks[0] == "umount":
				ud.debug(ud.LDAP, ud.PROCESS, 'umounting device, parameter: %s' % chunks)
				if not os.path.ismount(chunks[2]):
					ud.debug(ud.LDAP, ud.WARN, "univention-ltsp-mountd: Warning: Not unmounting %s since it's not mounted" % chunks[2])
				command = "umount " + chunks[2]

				user_to_umount = chunks[3][:-1]

				ret = subprocess.call(command, shell=True)
				if ret < 0:	
					ud.debug(ud.LDAP, ud.ERROR, "univention-ltsp-mountd: Error: Unmounting %s failed" % chunks[2])
				else:
					retire_file(mountpoint)

					ldapc = LdapConnection()
					sfilter = '(&(objectClass=person)(uid=%s))' % (user_to_umount)
					sdn = ldapc.searchDn(filter = sfilter)
					homedir = ldapc.getAttr(sdn[0], "homeDirectory")
					ldapc.disconnect()

					desktop_filename = homedir[0] + "/Desktop/" + chunks[2].split("/")[-1]
					if os.path.exists(desktop_filename):
						os.unlink(desktop_filename)

		time.sleep(poll_sleep)
	ad.close_debug()

def main():

	daemon()

	ud.init('/var/log/univention/ltsp-mounts.log', 1, 0)
	ud.set_level( ud.LDAP, debug_level)

	while True:
		try:
			track_mounts()
		except:
			text = ''
			exc_info = sys.exc_info()
			lines = apply(traceback.format_exception, exc_info)
			text = text + '\n'
			for line in lines:
				text += line
			try:
				ud.debug(ud.LDAP, ud.ERROR , 'Connection failed (retry in %d seconds): %s' % (poll_sleep,text))
			except:
				ud.debug(ud.LDAP, ud.ERROR , 'Connection failed (retry in %d seconds)' % (poll_sleep))
			time.sleep(poll_sleep)


if __name__ == "__main__":
	main()

