#!/usr/bin/python2.4
# -*- coding: utf-8 -*-
#
# Univention Virtual Machine Manager Daemon
#  UVMM commandline tool
#
# Copyright 2010 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.
"""UVMM command line interface."""

import sys
import os
import locale
from optparse import OptionParser
from univention.uvmm import protocol, client
from univention.uvmm.helpers import TranslatableException, _, N_
import PAM
from getpass import getpass
__builtins__._ = _

def create_socket(options):
	"""Create socket for communication with UVMMd.

	Either SSL, TCP or UNIX."""
	if options.ssl:
		if ':' in options.ssl:
			host, port = options.ssl.rsplit(':', 1)
		else:
			host, port = options.ssl, 2106
		sock = client.UVMM_ClientSSLSocket(host, int(port))
	elif options.tcp:
		if ':' in options.tcp:
			host, port = options.tcp.rsplit(':', 1)
		else:
			host, port = options.tcp, 2105
		sock = client.UVMM_ClientTCPSocket(host, int(port))
	else:
		sock = client.UVMM_ClientUnixSocket(options.socket)
	if options.verbose:
		print >>sys.stderr, "sock=%s" % (sock,)
	return sock

def request(options, req):
	"""Send request and wait for answer."""
	sock = create_socket(options)
	try:
		if options.verbose:
			print >>sys.stderr, "request=%s" % (req,)
		res = sock.send(req)
		while isinstance(res, protocol.Response_AUTHENTICATION):
			resp = []
			for query, type in res.challenge:
				if type == PAM.PAM_PROMPT_ECHO_ON:
					val = raw_input(query)
					resp.append((val, PAM.PAM_SUCCESS))
				elif type == PAM.PAM_PROMPT_ECHO_OFF:
					val = getpass(query)
					resp.append((val, PAM.PAM_SUCCESS))
				elif type == PAM.PAM_PROMPT_ERROR_MSG:
					print >>sys.stderr, query
					resp.append(('', PAM.PAM_SUCCESS))
				elif type == PAM.PAM_PROMPT_TEXT_INFO:
					print >>sys.stdout, query
					resp.append(('', PAM.PAM_SUCCESS))
			req2 = protocol.Request_AUTHENTICATION(response=resp)
			res = sock.send(req2)
			if isinstance(res, protocol.Response_OK):
				# repeat original request
				res = sock.send(req)
		if isinstance(res, protocol.Response_DUMP):
			print "DATA:"
			try:
				from pprint import pprint
				if isinstance(res.data, list):
					pprint([i._json() for i in res.data])
				else:
					pprint(res.data._json())
			except AttributeError, e:
				print str(res)
			except Exception, e:
				import traceback
				traceback.print_exc()
				print 'Exception', e
				print str(res)
		elif isinstance(res, protocol.Response_ERROR):
			raise TranslatableException(res.translatable_text, res.values)
		else:
			print "OK."
	finally:
		sock.close()

def from_ldap(options):
	"""Add all nodes registered in LDAP."""
	from univention.uvmm.uvmm_ldap import ldap_uris, LdapError
	try:
		uris = ldap_uris(options.ldap_uri)
	except LdapError, (translatable_text, dict):
		print >>sys.stderr, "ERROR:"
		print >>sys.stderr, _(translatable_text) % dict
		return False

	if len(uris) == 0:
		print >>sys.stderr, _("No nodes found.")
		return False

	result = True
	sock = create_socket(options)
	for uri in uris:
		try:
			req = protocol.Request_NODE_ADD(uri=uri)
			res = sock.send(req)
			if isinstance(res, protocol.Response_ERROR):
				raise client.ClientError(res.translatable_text, res.values)
		except client.ClientError, (translatable_text, dict):
			print >>sys.stderr, _(translatable_text) % dict
			result = False
	sock.close()

	return result

# Daemon
modes = ['bye']
# Groups
modes += ['groups', 'nodes']
# Nodes
modes += ['add', 'remove', 'frequency', 'nodes', 'query', 'ldap']
# Domain
modes += ['save', 'restore', 'migrate', 'state', 'define', 'undefine']
# Storage
modes += ['pools', 'volumes', 'volume_define']

if __name__ == '__main__':
	locale.setlocale(locale.LC_ALL, '')

	progname = os.path.basename(sys.argv[0])
	if progname[len('univention-virtual-machine-manager-'):] in modes:
		mode = progname[len('univention-virtual-machine-manager-'):]
		usage = _("usage: %prog [options] uri")
	else:
		mode = None
		usage = _("usage: %%prog [options] {%(modes)s} uri") % {'modes':','.join(modes)}

	parser = OptionParser( usage=usage )
	parser.add_option('-u', '--unix',
			action='store', dest='socket', default="/var/run/uvmm.socket",
			help=_('Path to the UNIX socket'))
	parser.add_option('-t', '--tcp',
			action='store', dest='tcp', default=None, metavar=_("HOST:PORT"),
			help=_('HOST and PORT number of the TCP socket'))
	parser.add_option('-s', '--ssl',
			action='store', dest='ssl', default=False, metavar=_("HOST:PORT"),
			help=_('HOST and PORT number of the SSL encrypted TCP socket'))
	parser.add_option( '-v', '--verbose',
			action='store_true', dest='verbose', default=False,
			help=_('Print additional information'))
	parser.add_option('-b', '--ldap-base',
			action='store', dest='ldap_uri', metavar=_("ldap://HOST:PORT/BASE"),
			help=_('LDAP-uri for searching initial nodes'))

	(options, arguments) = parser.parse_args()

	try:
		if mode is None:
			try:
				mode = arguments.pop(0)
			except IndexError:
				raise TranslatableException(N_('No mode specified'))
		if mode not in modes:
			raise TranslatableException(N_('Unknown mode "%(mode)s"'), mode=mode)

		if options.verbose:
			print >>sys.stderr, "mode=%s" % (mode,)

		if mode == 'ldap':
			result = from_ldap(options)
			sys.exit(result and 0 or 1)
		elif mode == 'add':
			try: req = protocol.Request_NODE_ADD(uri=arguments.pop(0))
			except IndexError: raise TranslatableException(N_('URI required'))
		elif mode == 'remove':
			try: req = protocol.Request_NODE_REMOVE(uri=arguments.pop(0))
			except IndexError: raise TranslatableException(N_('URI required'))
		elif mode == 'query':
			try: req = protocol.Request_NODE_QUERY(uri=arguments.pop(0))
			except IndexError: raise TranslatableException(N_('URI required'))
		elif mode == 'frequency':
			try: hz = arguments.pop(0)
			except IndexError: raise TranslatableException(N_('Frequency required'))
			if len(arguments) >= 1:
				uri = arguments.pop(0)
			else:
				uri = None
			req = protocol.Request_NODE_FREQUENCY(hz=hz, uri=uri)
		elif mode == 'groups':
			req = protocol.Request_GROUP_LIST()
		elif mode == 'nodes':
			try: req = protocol.Request_NODE_LIST(group=arguments.pop(0))
			except IndexError: raise TranslatableException(N_('URI required'))
		elif mode == 'bye':
			req = protocol.Request_BYE()
		elif mode == 'save':
			try: uri = arguments.pop(0)
			except IndexError: raise TranslatableException(N_('URI required'))
			try: domain = arguments.pop(0)
			except IndexError: raise TranslatableException(N_('Domain required'))
			try: statefile = arguments.pop(0)
			except IndexError: raise TranslatableException(N_('File name required'))
			req = protocol.Request_DOMAIN_SAVE(uri=uri, domain=domain, statefile=statefile)
		elif mode == 'restore':
			try: uri = arguments.pop(0)
			except IndexError: raise TranslatableException(N_('URI required'))
			try: statefile = arguments.pop(0)
			except IndexError: raise TranslatableException(N_('File name required'))
			req = protocol.Request_DOMAIN_RESTORE(uri=uri, statefile=statefile)
		elif mode == 'migrate':
			try: uri = arguments.pop(0)
			except IndexError: raise TranslatableException(N_('URI required'))
			try: domain = arguments.pop(0)
			except IndexError: raise TranslatableException(N_('Domain required'))
			try: target_uri = arguments.pop(0)
			except IndexError: raise TranslatableException(N_('URI required'))
			req = protocol.Request_DOMAIN_MIGRATE(uri=uri, domain=domain, target_uri=target_uri)
		elif mode == 'state':
			try: uri = arguments.pop(0)
			except IndexError: raise TranslatableException(N_('URI required'))
			try: domain = arguments.pop(0)
			except IndexError: raise TranslatableException(N_('Domain required'))
			try: state = arguments.pop(0)
			except IndexError: raise TranslatableException(N_('State required'))
			req = protocol.Request_DOMAIN_STATE(uri=uri, domain=domain, state=state)
		elif mode == 'define':
			try: uri = arguments.pop(0)
			except IndexError: raise TranslatableException(N_('URI required'))
			try: file_or_xml = arguments.pop(0)
			except IndexError: raise TranslatableException(N_('File name or XML required'))
			try:
				import xml.etree.ElementTree as ET
			except ImportError:
				import elementtree.ElementTree as ET
			if file_or_xml.startswith('<'):
				root = ET.fromstring(file_or_xml)
			else:
				tree = ET.parse(file_or_xml)
				root = tree.getroot() # domain
			domain = protocol.Data_Domain()
			domain.domain_type = root.attrib['type']
			domain.uuid = root.findtext('uuid')
			domain.name = root.findtext('name')
			domain.os_type = root.find('os').findtext('type')
			try: domain.arch = root.find('os').find('type').attrib['arch']
			except KeyError: domain.arch = 'i686' # FIXME
			if domain.os_type == 'linux':
				domain.kernel = root.find('os').findtext('kernel')
				domain.cmdline = root.find('os').findtext('cmdline')
				domain.initrd = root.find('os').findtext('initrd')
			elif domain.os_type == 'hvm':
				try: domain.boot = [boot.attrib['dev'] for boot in root.find('os').findall('boot')]
				except AttributeError: pass
				except KeyError: pass
			else:
				raise "Unknown os/typ='%s'" % (domain.os_type,)
			domain.maxMem = int(root.findtext('memory')) << 10
			from univention.uvmm.node import Disk, Interface, Graphic
			for disk in root.find('devices').findall('disk'):
				d = Disk()
				d.type = d.map_type(name=disk.attrib['type'])
				try: d.device = d.map_device(name=disk.attrib['device'])
				except KeyError: pass
				try: d.driver = disk.find('driver').attrib['name']
				except AttributeError: pass
				except KeyError: pass
				d.source = disk.find('source').attrib['file']
				try: d.target_dev = disk.find('target').attrib['dev']
				except AttributeError: pass
				except KeyError: pass
				try: d.target_bus = disk.find('target').attrib['bus']
				except AttributeError: pass
				except KeyError: pass
				domain.disks.append(d)
			for interface in root.find('devices').findall('interface'):
				i = Interface()
				i.type = i.map_type(name=interface.attrib['type'])
				try: i.mac_address = interface.find('mac').attrib['address']
				except AttributeError: pass
				except KeyError: pass
				try: i.source = interface.find('source').attrib['bridge']
				except AttributeError: pass
				except KeyError: pass
				try: i.target = interface.find('script').attrib['path']
				except AttributeError: pass
				except KeyError: pass
				try: i.target = interface.find('target').attrib['dev']
				except AttributeError: pass
				except KeyError: pass
				domain.interfaces.append(i)
			for graphics in root.find('devices').findall('graphics'):
				g = Graphic()
				g.type = g.map_type(name=graphics.attrib['type'])
				try: g.port = graphics.attrib['port']
				except KeyError: pass
				try: g.autoport = graphics.attrib['autoport'] == 'yes'
				except KeyError: pass
				try: g.keymap = graphics.attrib['keymap']
				except KeyError: pass
				try: g.listen = graphics.attrib['listen']
				except KeyError: pass
				domain.graphics.append(g)
			try:
				for annotation in root.find('annotations').findall('annotation'):
					key = annotation.findtext('key')
					value = annotation.findtext('value')
					domain.annotations[key] = value
			except AttributeError: pass
			from pprint import pprint
			pprint(domain._json())
			req = protocol.Request_DOMAIN_DEFINE(uri=uri, domain=domain)
		elif mode == 'undefine':
			try: uri = arguments.pop(0)
			except IndexError: raise TranslatableException(N_('URI required'))
			try: domain = arguments.pop(0)
			except IndexError: raise TranslatableException(N_('Domain required'))
			req = protocol.Request_DOMAIN_UNDEFINE(uri=uri, domain=domain, volumes=arguments)
		elif mode == 'pools':
			try: uri = arguments.pop(0)
			except IndexError: raise TranslatableException(N_('URI required'))
			req = protocol.Request_STORAGE_POOLS(uri=uri)
		elif mode == 'volumes':
			try: uri = arguments.pop(0)
			except IndexError: raise TranslatableException(N_('URI required'))
			try: pool = arguments.pop(0)
			except IndexError: raise TranslatableException(N_('Pool name required'))
			try: type = arguments.pop(0)
			except IndexError: type = None
			req = protocol.Request_STORAGE_VOLUMES(uri=uri, pool=pool, type=type)
		elif mode == 'volume_define':
			try: uri = arguments.pop(0)
			except IndexError: raise TranslatableException(N_('URI required'))
			try: pool = arguments.pop(0)
			except IndexError: raise TranslatableException(N_('Pool name required'))
			try: name = arguments.pop(0)
			except IndexError: raise TranslatableException(N_('Volume name required'))
			try: size = int(arguments.pop(0))
			except IndexError: raise TranslatableException(N_('Volume size required'))
			except ValueError: raise TranslatableException(N_('Volume size required'))
			req = protocol.Request_STORAGE_DEFINE(uri=uri, pool=pool, name=name, size=size)
		else:
			raise TranslatableException(N_('Unknown mode "%(mode)s"'), mode=mode)
	except TranslatableException, (translatable_text, dict):
		print >>sys.stderr, _(translatable_text) % dict
		parser.print_usage()
		sys.exit(2)

	try:
		request(options, req)
		sys.exit(0)
	except TranslatableException, (translatable_text, dict):
		print >>sys.stderr, "ERROR:"
		print >>sys.stderr, _(translatable_text) % dict
		sys.exit(1)
