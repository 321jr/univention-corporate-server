#!/usr/bin/python2.4
# -*- coding: utf-8 -*-
#
# Univention Virtual Machine Manager Daemon
#  UVMM commandline tool
#
# Copyright (C) 2010 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# Binary versions of this file provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA	 02110-1301	 USA
"""UVMM command line interface."""

import sys
import os
import locale
from optparse import OptionParser
from univention.uvmm import protocol, client

def request(options, req):
	"""Send request and wait for answer."""
	try:
		if options.ssl:
			if ':' in options.ssl:
				host, port = options.ssl.rsplit(':', 1)
			else:
				host, port = options.ssl, 2106
			sock = client.UVMM_ClientSSLSocket(host, int(port))
		elif options.tcp:
			if ':' in options.tcp:
				host, port = options.tcp.rsplit(':', 1)
			else:
				host, port = options.tcp, 2105
			sock = client.UVMM_ClientTCPSocket(host, int(port))
		else:
			sock = client.UVMM_ClientUnixSocket(options.socket)
		if options.verbose:
			print >>sys.stderr, "sock=%s" % (sock,)
			print >>sys.stderr, "request=%s" % (req,)
		res = sock.send(req)
		if isinstance(res, protocol.Response_DUMP):
			try:
				from pprint import pprint
				pprint(res.data._json())
			except AttributeError, e:
				print str(res)
			except Exception, e:
				import traceback
				print traceback.print_exc()
				print 'Exception', e
				print str(res)
		elif isinstance(res, protocol.Response_ERROR):
			print(res.msg)
		else:
			print "OK."
		sock.close()
	except client.ClientError, (msg,):
		print >>sys.stderr, msg
		return False

def from_ldap(options):
	"""Add all nodes registered in LDAP."""
	import univention.uvmm.ldap as ldap
	try:
		uris = ldap.ldap2uri()
	except ldap.LdapError, msg:
		print >>sys.stderr, msg
		return False

	if len(uris) == 0:
		print >>sys.stderr, "No nodes found."
		return False

	result = True
	sock = client.UVMM_ClientSocket(options.socket)
	if not sock:
		print >>sys.stderr, "Failed to connect to UVMM daemon."
		return False
	for uri in uris:
		try:
			req = protocol.Request_NODE_ADD(uri=uri)
			res = sock.send(req)
			if isinstance(res, protocol.Response_ERROR):
				raise client.ClientError(res.msg)
		except client.ClientError, (msg,):
			print >>sys.stderr, msg
			result = False
	sock.close()

	return result

# Daemon
modes = ['bye']
# Groups
modes += ['groups', 'nodes']
# Nodes
modes += ['add', 'remove', 'frequency', 'nodes', 'query', 'ldap']
# Domain
modes += ['save', 'restore', 'migrate', 'state', 'define', 'undefine']

if __name__ == '__main__':
	locale.setlocale(locale.LC_ALL, '')

	progname = os.path.basename(sys.argv[0])
	if progname[len('univention-virtual-machine-manager-'):] in modes:
		mode = progname[len('univention-virtual-machine-manager-'):]
		usage="usage: %prog [options] uri"
	else:
		mode = None
		usage="usage: %%prog [options] {%s} uri" % (','.join(modes),)

	parser = OptionParser( usage=usage )
	parser.add_option('-u', '--unix',
			action='store', dest='socket', default="/var/run/uvmm.socket",
			help='Path to the UNIX socket')
	parser.add_option('-t', '--tcp',
			action='store', dest='tcp', default=None,
			help='Host and port number of the TCP socket')
	parser.add_option('-s', '--ssl',
			action='store', dest='ssl', default=False,
			help='Host and port number of the SSL encrypted TCP socket')
	parser.add_option( '-v', '--verbose',
			action='store_true', dest='verbose', default=False,
			help='Print additional information' )

	(options, arguments) = parser.parse_args()

	if mode is None:
		try:
			mode = arguments.pop(0)
		except IndexError:
			print >>sys.stderr, 'Error: No mode specified'
			parser.print_usage()
			sys.exit(2)
	if mode not in modes:
		print >>sys.stderr, 'Error: Unknown mode "%s"' % (mode,)
		parser.print_usage()
		sys.exit(2)

	if options.verbose:
		print >>sys.stderr, "mode=%s" % (mode,)
	try:
		if mode == 'ldap':
			result = from_ldap(options)
			sys.exit({True:0}.get(result, 1))
		if mode == 'add':
			req = protocol.Request_NODE_ADD(uri=arguments.pop(0))
		elif mode == 'remove':
			req = protocol.Request_NODE_REMOVE(uri=arguments.pop(0))
		elif mode == 'query':
			req = protocol.Request_NODE_QUERY(uri=arguments.pop(0))
		elif mode == 'frequency':
			hz = arguments.pop(0)
			if len(arguments) >= 1:
				uri = arguments.pop(0)
			else:
				uri = None
			req = protocol.Request_NODE_FREQUENCY(hz=hz, uri=uri)
		elif mode == 'groups':
			req = protocol.Request_GROUP_LIST()
		elif mode == 'nodes':
			req = protocol.Request_NODE_LIST(group=arguments.pop(0))
		elif mode == 'bye':
			req = protocol.Request_BYE()
		elif mode == 'save':
			uri = arguments.pop(0)
			domain = arguments.pop(0)
			statefile = arguments.pop(0)
			req = protocol.Request_DOMAIN_SAVE(uri=uri, domain=domain, statefile=statefile)
		elif mode == 'restore':
			uri = arguments.pop(0)
			statefile = arguments.pop(0)
			req = protocol.Request_DOMAIN_RESTORE(uri=uri, statefile=statefile)
		elif mode == 'migrate':
			uri = arguments.pop(0)
			domain = arguments.pop(0)
			target_uri = arguments.pop(0)
			req = protocol.Request_DOMAIN_MIGRATE(uri=uri, domain=domain, target_uri=target_uri)
		elif mode == 'state':
			uri = arguments.pop(0)
			domain = arguments.pop(0)
			state = arguments.pop(0)
			req = protocol.Request_DOMAIN_STATE(uri=uri, domain=domain, state=state)
		elif mode == 'define':
			uri = arguments.pop(0)
			file_or_xml = arguments.pop(0)
			try:
				import xml.etree.ElementTree as ET
			except ImportError:
				import elementtree.ElementTree as ET
			if file_or_xml.startswith('<'):
				tree = ET.fromstring(file_or_xml)
			else:
				tree = ET.parse(file_or_xml)
			root = tree.getroot() # domain
			domain = protocol.Data_Domain()
			domain.uuid = root.findtext('uuid')
			domain.name = root.findtext('name')
			domain.virt_tech = root.find('os').findtext('type')
			if domain.virt_tech == 'linux':
				domain.kernel = root.find('os').findtext('kernel')
				domain.cmdline = root.find('os').findtext('cmdline')
				domain.initrd = root.find('os').findtext('initrd')
			elif domain.virt_tech == 'hvm':
				try: domain.boot = root.find('os').find('boot').attrib['dev']
				except AttributeError: pass
				except KeyError: pass
			else:
				raise "Unknown virtualization technique '%s'" % (domain.virt_tech,)
			domain.maxMem = int(root.findtext('memory')) << 10
			from univention.uvmm.node import Disk, Interface, Graphic
			for disk in root.find('devices').findall('disk'):
				d = Disk()
				d.type = d.map_type(name=disk.attrib['type'])
				try: d.device = d.map_device(name=disk.attrib['device'])
				except KeyError: pass
				try: d.driver = disk.find('driver').attrib['name']
				except AttributeError: pass
				except KeyError: pass
				d.source = disk.find('source').attrib['file']
				try: d.target_dev = disk.find('target').attrib['dev']
				except AttributeError: pass
				except KeyError: pass
				try: d.target_bus = disk.find('target').attrib['bus']
				except AttributeError: pass
				except KeyError: pass
				domain.disks.append(d)
			for interface in root.find('devices').findall('interface'):
				i = Interface()
				i.type = i.map_type(name=interface.attrib['type'])
				try: i.mac_address = interface.find('mac').attrib['address']
				except AttributeError: pass
				except KeyError: pass
				try: i.source = interface.find('source').attrib['bridge']
				except AttributeError: pass
				except KeyError: pass
				try: i.target = interface.find('script').attrib['path']
				except AttributeError: pass
				except KeyError: pass
				try: i.target = interface.find('target').attrib['dev']
				except AttributeError: pass
				except KeyError: pass
				domain.interfaces.append(i)
			for graphics in root.find('devices').findall('graphics'):
				g = Graphic()
				g.type = g.map_type(name=graphics.attrib['type'])
				try: g.port = graphics.attrib['port']
				except KeyError: pass
				try: g.autoport = graphics.attrib['autoport'] == 'yes'
				except KeyError: pass
				try: g.keymap = graphics.attrib['keymap']
				except KeyError: pass
				domain.graphics.append(g)
			req = protocol.Request_DOMAIN_DEFINE(uri=uri, domain=domain)
		elif mode == 'undefine':
			uri = arguments.pop(0)
			domain = arguments.pop(0)
			req = protocol.Request_DOMAIN_UNDEFINE(uri=uri, domain=domain, volumes=arguments)
		else:
			print >>sys.stderr, 'Error: Unknown mode "%s"' % (mode,)
			parser.print_usage()
			sys.exit(2)
	except IndexError:
		print >>sys.stderr, 'Error: An URI is required'
		parser.print_usage()
		sys.exit(2)

	res = request(options, req)
	if res == False:
		sys.exit(1)
