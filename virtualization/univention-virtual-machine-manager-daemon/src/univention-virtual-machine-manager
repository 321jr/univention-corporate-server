#!/usr/bin/python2.4
# -*- coding: utf-8 -*-
#
# Univention Virtual Machine Manager Daemon
#  UVMM commandline tool
#
# Copyright (C) 2010 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
# Binary versions of this file provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA	 02110-1301	 USA
"""UCS-Virt command line interface."""

import sys
import os
import locale
from optparse import OptionParser
from univention.uvmm import protocol, client

def request(options, req):
	"""Send request and wait for answer."""
	try:
		if options.verbose:
			print >>sys.stderr, "socket=%s" % (options.socket,)
			print >>sys.stderr, "request=%s" % (req,)
		sock = client.UVMM_ClientSocket(options.socket)
		res = sock.send(req)
		if isinstance(res, protocol.Response_DUMP):
			try:
				from pprint import pprint
				pprint(res.data._json())
			except AttributeError, e:
				print str(res)
			except Exception, e:
				import traceback
				print traceback.print_exc()
				print 'Exception', e
				print str(res)
		elif isinstance(res, protocol.Response_ERROR):
			print(res.msg)
		else:
			print "OK."
		sock.close()
	except client.ClientError, (msg,):
		print >>sys.stderr, msg
		return False

def from_ldap(options):
	"""Add all nodes registered in LDAP."""
	import univention.uvmm.ldap as ldap
	try:
		uris = ldap.ldap2uri()
	except ldap.LdapError, msg:
		print >>sys.stderr, msg
		return False

	if len(uris) == 0:
		print >>sys.stderr, "No nodes found."
		return False

	result = True
	sock = client.UVMM_ClientSocket(options.socket)
	if not sock:
		print >>sys.stderr, "Failed to connect to UVMM daemon."
		return False
	for uri in uris:
		try:
			req = protocol.Request_NODE_ADD(uri=uri)
			res = sock.send(req)
			if isinstance(res, protocol.Response_ERROR):
				raise client.ClientError(res.msg)
		except client.ClientError, (msg,):
			print >>sys.stderr, msg
			result = False
	sock.close()

	return result

modes = ('add', 'remove', 'query', 'frequency', 'nodes', 'groups', 'bye', 'save', 'restore', 'migrate', 'state', 'ldap')

if __name__ == '__main__':
	locale.setlocale(locale.LC_ALL, '')

	progname = os.path.basename(sys.argv[0])
	if progname in ['univention-virtual-machine-manager-%s' % mode for mode in modes]:
		mode = progname[len('univention-virtual-machine-manager-'):]
		usage="usage: %prog [options] uri"
	else:
		mode = None
		usage="usage: %%prog [options] {%s} uri" % (','.join(modes),)

	parser = OptionParser( usage=usage )
	parser.add_option('-s', '--socket',
			action='store', dest='socket', default="/var/run/uvmm.socket",
			help='Path to the UNIX socket')
	parser.add_option( '-v', '--verbose',
			action='store_true', dest='verbose', default=False,
			help='Print additional information' )

	(options, arguments) = parser.parse_args()

	if mode == None:
		if len(arguments) >= 1 and arguments[0] in modes:
			mode = arguments.pop(0)
		else:
			print >>sys.stderr, 'Error: A mode is required'
			parser.print_usage()
			sys.exit(2)

	if options.verbose:
		print >>sys.stderr, "mode=%s" % (mode,)
	try:
		if mode == 'ldap':
			result = from_ldap(options)
			sys.exit({True:0}.get(result, 1))
		if mode == 'add':
			req = protocol.Request_NODE_ADD(uri=arguments.pop(0))
		elif mode == 'remove':
			req = protocol.Request_NODE_REMOVE(uri=arguments.pop(0))
		elif mode == 'query':
			req = protocol.Request_NODE_QUERY(uri=arguments.pop(0))
		elif mode == 'frequency':
			hz = arguments.pop(0)
			if len(arguments) >= 1:
				uri = arguments.pop(0)
			else:
				uri = None
			req = protocol.Request_NODE_FREQUENCY(hz=hz, uri=uri)
		elif mode == 'groups':
			req = protocol.Request_GROUP_LIST()
		elif mode == 'nodes':
			req = protocol.Request_NODE_LIST(group=arguments.pop(0))
		elif mode == 'bye':
			req = protocol.Request_BYE()
		elif mode == 'save':
			uri = arguments.pop(0)
			domain = arguments.pop(0)
			statefile = arguments.pop(0)
			req = protocol.Request_DOMAIN_SAVE(uri=uri, domain=domain, statefile=statefile)
		elif mode == 'restore':
			uri = arguments.pop(0)
			statefile = arguments.pop(0)
			req = protocol.Request_DOMAIN_RESTORE(uri=uri, statefile=statefile)
		elif mode == 'migrate':
			uri = arguments.pop(0)
			domain = arguments.pop(0)
			target_uri = arguments.pop(0)
			req = protocol.Request_DOMAIN_MIGRATE(uri=uri, domain=domain, target_uri=target_uri)
		elif mode == 'state':
			uri = arguments.pop(0)
			domain = arguments.pop(0)
			state = arguments.pop(0)
			req = protocol.Request_DOMAIN_STATE(uri=uri, domain=domain, state=state)
		else:
			print >>sys.stderr, 'Error: Unknown mode "%s"' % (mode,)
			parser.print_usage()
			sys.exit(2)
	except IndexError:
		print >>sys.stderr, 'Error: An URI is required'
		parser.print_usage()
		sys.exit(2)

	res = request(options, req)
	if res == False:
		sys.exit(1)
