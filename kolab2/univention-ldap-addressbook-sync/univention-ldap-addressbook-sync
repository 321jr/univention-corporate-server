#!/usr/bin/python2.4
# -*- coding: utf-8 -*-
#
# Univention LDAP addressbook synchronisation
#
# Copyright 2008-2010 Univention GmbH
#
# http://www.univention.de/
#
# All rights reserved.
#
# The source code of this program is made available
# under the terms of the GNU Affero General Public License version 3
# (GNU AGPL V3) as published by the Free Software Foundation.
#
# Binary versions of this program provided by Univention to you as
# well as other copyrighted, protected or trademarked materials like
# Logos, graphics, fonts, specific documentations and configurations,
# cryptographic keys etc. are subject to a license agreement between
# you and Univention and not subject to the GNU AGPL V3.
#
# In the case you use this program under the terms of the GNU AGPL V3,
# the program is provided in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License with the Debian GNU/Linux or Univention distribution in file
# /usr/share/common-licenses/AGPL-3; if not, see
# <http://www.gnu.org/licenses/>.

from optparse import OptionParser
import copy
import datetime
import fnmatch
import grp
import xml.dom
import imaplib
import email.MIMEMultipart
import email.MIMEText
import email.Charset
import cPickle, os, sys, fcntl, time, re

import univention.debug as ud
import univention.config_registry as ucr
import univention.uldap

cfgRegistry = ucr.ConfigRegistry()
cfgRegistry.load()
_options = None
ldapConnection = None

class LDAP_Connection( univention.uldap.access ):
	def __init__( self ):
		bindpw = open( '/etc/machine.secret' ).read()
		if bindpw[ -1 ] == '\n':
			bindpw=bindpw[ 0 : -1 ]
		univention.uldap.access.__init__( self, host = cfgRegistry[ 'ldap/server/name' ], base = cfgRegistry[ 'ldap/base' ], binddn = cfgRegistry[ 'ldap/hostdn' ], bindpw = bindpw )

	def is_member( self, username, group ):
		result = self.search( filter = '(&(objectClass=univentionGroup)(cn=%s)(memberUid=%s))' % ( group, username ), attr = [ 'dn' ] )
		return len( result ) > 0

	def member_addresses( self, dn ):
		result = self.search( base = dn, attr = ['uniqueMember'] )
		ud.debug( ud.ADMIN, ud.INFO, 'LDAP_Connection: %s ' % ( result ) )
		members = []
		if result[0][1].has_key('uniqueMember'):
			for member_dn in result[0][1]['uniqueMember']:
				try:
					user_result = self.search( base = member_dn, attr = ['mail', 'displayName'] )	
					if user_result[0][1].has_key( 'mail' ):
						members.append( '%s <%s>' % ( user_result[0][1]['displayName'][0], user_result[0][1]['mail'][0] ) )
				except:
					ud.debug( ud.ADMIN, ud.INFO, 'LDAP_Connection: cannot find user %s ' % ( member_dn ) )
					pass
					
		return members

class KolabContact( email.MIMEMultipart.MIMEMultipart, object ):
	def __init__( self, dn ):
		email.MIMEMultipart.MIMEMultipart.__init__( self )
		self._id = '%s@%s.%s' % ( time.time(), cfgRegistry.get( 'hostname', '' ), cfgRegistry.get( 'domainname', '' ) )
		self[ 'subject' ] = self._id
		self[ 'X-Univention-LDAP-DN' ] = dn
		self.dn = dn
		self.__setup_object()
		self.__attached = False

	def __setup_object( self ):
		'''creates the Kolab XML part of the message'''

		#create document
		implement = xml.dom.getDOMImplementation()
		self._doc = implement.createDocument( None, "contact", None )

		# id
		self.__create_element( 'uid', self._id, self._doc.documentElement )

		# categories
		self.__create_element( 'categories', parent = self._doc.documentElement )

		# dates
		now = datetime.datetime.now()
		self.__create_element( 'creation-date', text = now.isoformat(),
							   parent = self._doc.documentElement )
		self.__create_element( 'last-modification-date', text = now.isoformat(),
							   parent = self._doc.documentElement )

		# sensitivity
		self.__create_element( 'sensitivity', text = 'public', parent = self._doc.documentElement )

		# product
		self.__create_element( 'product-id', text = 'Univention LDAP Addressbook Sync',
							   parent = self._doc.documentElement )

		# name
		elem = self._doc.createElement( 'name' )
		self.__create_element( 'given-name', parent = elem, prefix = 'name' )
		self.__create_element( 'last-name', parent = elem, prefix = 'name' )
		self.__create_element( 'full-name', parent = elem, prefix = 'name' )
		self.__create_element( 'prefix', parent = elem, prefix = 'name' )
		self._doc.documentElement.appendChild( elem )

		# organization
		for item in ( 'organization', 'department', 'office-location', 'profession', 'job-title',
					  'manager-name', 'assistant', 'birthday' ):
			self.__create_element( item, parent = self._doc.documentElement )

		# addresses
		for addr in ( 'home', 'business' ):
			elem = self._doc.createElement( 'address' )
			self.__create_element( 'type', text = addr, parent = elem, prefix = addr )
			self.__create_element( 'street', parent = elem, prefix = addr )
			self.__create_element( 'locality', parent = elem, prefix = addr )
			self.__create_element( 'region', parent = elem, prefix = addr )
			self.__create_element( 'postal-code', parent = elem, prefix = addr )
			self.__create_element( 'country', parent = elem, prefix = addr )
			self._doc.documentElement.appendChild( elem )

		# phone numbers
		for phone in ( 'business1', 'businessfax', 'home1', 'mobile' ):
			elem = self._doc.createElement( 'phone' )
			self.__create_element( 'type', text = phone, parent = elem, prefix = phone )
			self.__create_element( 'number', parent = elem, prefix = phone )
			self._doc.documentElement.appendChild( elem )

		# comment
		try:
			self.__create_element( 'body', text = '\n'.join( ldapConnection.member_addresses( self.dn ) ), parent = self._doc.documentElement )
			ud.debug( ud.ADMIN, ud.INFO, 'KolabContact: created body for %s (dn: %s)' % ( self._id, self.dn ) )
		except:
			ud.debug( ud.ADMIN, ud.INFO, 'KolabContact: did not create body for %s' % ( self._id ) )


	def add_email_addresses(  self, display, addresses ):
		i = 0
		ignore = cfgRegistry.get( 'ldap/addressbook/sync/mail/ignore', '' )
		for addr in addresses:
			# email address
			if fnmatch.fnmatch( addr, ignore ):
				continue
			elem = self._doc.createElement( 'email' )
			self.__create_element( 'display-name', text = display, parent = elem, prefix = 'email%d' % i )
			self.__create_element( 'smtp-address', text = addr, parent = elem, prefix = 'email%d' % i )
			self._doc.documentElement.appendChild( elem )
			i += 1

	def add_infotext( self ):
		'''creates the information part of the message, explaining the content'''

		info = '''
Die ist ein Kolab-Groupware-Objekt. Um dieses Objekt anzuzeigen, benötigen
Sie ein E-Mail-Programm, das das Kolab-Groupware-Format unterstützt. Eine
Liste solcher Programme finden Sie unter
http://www.kolab.org/kolab2-clients.html
'''
		charset = email.Charset.Charset( 'utf-8' )
		charset.body_encoding = email.Charset.QP
		info_text = email.MIMEText.MIMEText( charset.body_encode( info ), 'plain', 'utf-8' )
		info_text.set_charset( charset )
		info_text.set_payload( charset.body_encode( info ) )
		info_text.add_header( 'Content-Disposition', 'inline' )
		del info_text[ 'Content-Transfer-Encoding' ]
		info_text[ 'Content-Transfer-Encoding' ] = charset.get_body_encoding()
		self.attach( info_text )

	def __create_element( self, name, text = '', parent = None, prefix = None ):
		if prefix:
			attr_name = prefix + '_' + name
		else:
			attr_name = name
		attr_name = attr_name.replace( '-', '_' )
		setattr( self, attr_name, self._doc.createTextNode( text ) )
		elem = self._doc.createElement( name )
		elem.appendChild( getattr( self, attr_name ) )
		if parent:
			parent.appendChild( elem )

	def __setattr__( self, attr, value ):
		'''Support setting the kolab contact attributes directly via <object>.<attribute>'''

		if hasattr( self, attr ) and isinstance( getattr( self, attr ), xml.dom.Node ):
			getattr( self, attr ).data = value
		else:
			object.__setattr__( self, attr, value )

	def add_contact( self ):
		charset = email.Charset.Charset( 'utf-8' )
 		charset.body_encoding = email.Charset.BASE64
		app = email.MIMEText.MIMEText( '', 'x-vnd.kolab.contact', 'utf-8' )
		app.set_charset( charset )
		xml = self._doc.toxml( encoding = 'utf-8' )
		app.set_payload( charset.body_encode( xml ) )
		app.set_type( 'application/x-vnd.kolab.contact' )
		app.add_header( 'Content-Disposition', 'attachment', filename = 'contacts.xml' )
		self.attach( app )

	def create_message( self ):
		if not self.__attached:
			self.add_infotext()
			self.add_contact()
			self.__attached = True

	def __str__( self ):
		self.create_message()
		return self.as_string()

class IMAP_Client( object ):
	def __init__( self, folder = None, groups = None, filter = [], dnpattern = None ):
		
		self.dnpattern = dnpattern

		if not folder:
			# check for IMAP folder
			self.folder = cfgRegistry.get( 'ldap/addressbook/sync/folder', '' )
			if not self.folder:
				raise RuntimeError( 'Global IMAP folder for synchronisation is not set!' )
		else:
			self.folder = folder

		if not groups:
			self.groups = cfgRegistry.get( 'ldap/addressbook/sync/groups', [] )
			if self.groups:
				self.groups = self.groups.split( ';' )
		else:
			self.groups = groups

		self.imap4 = None
		# try to connect and authenticate
		self.auth()

		# set filter
		self.filter = filter

		# set ACLs (required!)
		(type, data) = self.imap4.setacl( self.folder, 'cyrus', 'lrswipcda' )
		if type != 'OK':
			raise RuntimeError( 'SetACL failed: %s folder: %s' % ( repr(data), folder ) )

		# select mailbox (checks existance)
		(type, data) = self.imap4.select( self.folder )
		if type != 'OK':
			raise RuntimeError( 'Select folder failed: %s' % repr(data) )

	def auth( self ):
		reconnect = False
		if not self.imap4:
			reconnect = True
		elif self.imap4.socket():
			try:
				peer = self.imap4.socket().getpeername()
			except:
				reconnect = True
		if reconnect:
			ud.debug( ud.ADMIN, ud.INFO, 'Trying to reconnect to IMAP server' )
			try:
				self.imap4 = imaplib.IMAP4( 'localhost' )
			except Exception, e:
				raise RuntimeError( 'Connection to local IMAP server failed!' )
				sys.exit( 1 )

		try:
			fd = open( '/etc/cyrus.secret', 'r' )
		except:
			ud.debug( ud.ADMIN, ud.ERROR, 'Failed to read password for user cyrus. Is there a IMAP server installed?' )
			sys.exit( 1 )
		password = fd.readline().rstrip('\n')
		fd.close()

		# try to log in
		try:
			self.imap4.login( 'cyrus', password )
			ud.debug( ud.ADMIN, ud.INFO, 'logged in to IMAP server' )
		except:
			raise RuntimeError( 'Login to IMAP server failed!' )
			sys.exit( 1 )

	def find( self, dn ):
		# find it
		typ, data = self.imap4.search( 'UTF-8', '(HEADER "X-Univention-LDAP-DN" "%s")' % dn )

		if data and data[ 0 ]:
			ud.debug( ud.ADMIN, ud.INFO, 'IMAP: found message: %s' % data[ 0 ].split()[ 0 ] )
			return data[ 0 ].split()[ 0 ]

		return None

	def remove_all( self ):
		typ, data = self.imap4.search( None, 'ALL' )
		if not data:
			return

		# mark as deleted
		for i in data[ 0 ].split():
			self.imap4.store( i, '+FLAGS', '\\Deleted' )

		# expunge
		self.imap4.expunge()

	def remove( self, dn ):
		id = self.find( dn )
		if not id:
			ud.debug( ud.ADMIN, ud.INFO, 'IMAP: remove message: not found' )
			return

		# mark as deleted
		ud.debug( ud.ADMIN, ud.INFO, 'IMAP: remove message with id %s' % id )
		if _options.simulate:
			return

		self.imap4.store( id, '+FLAGS', '\\Deleted' )

		# expunge
		self.imap4.expunge()

	def _checkRelevance( self, contact, uid = None ):
		'''check constraints given by group membership and regular expression if object is relevant for sync'''
		if self.groups and uid:
			for group in self.groups:
				ud.debug( ud.ADMIN, ud.INFO, 'IMAP_Client: check if %s is in group %s' % ( uid, group ) )
				if ldapConnection.is_member( uid, group ):
					ud.debug( ud.ADMIN, ud.INFO, 'IMAP_Client: %s is member of group %s' % ( uid, group ) )
					return True
			else:
				ud.debug( ud.ADMIN, ud.INFO, 'IMAP_Client: do NOT add %s to folder %s' % ( uid, self.folder ) )
				return False

		if self.dnpattern:
			ud.debug( ud.ADMIN, ud.INFO, 'IMAP_Client: check if %s matches %s' % ( contact.dn, self.dnpattern.pattern ) )
			if self.dnpattern.match(contact.dn):
				ud.debug( ud.ADMIN, ud.INFO, 'IMAP_Client: %s matches %s' % ( contact.dn, self.dnpattern.pattern ) )
				return True
			else:
				ud.debug( ud.ADMIN, ud.INFO, 'IMAP_Client: do NOT add %s to folder %s' % ( uid, self.folder ) )
				return False
		return True # default: if no constraints given sync all


	def add( self, contact, uid = None ):
		if not self._checkRelevance( contact, uid = None ):
			return False

		for item in (self.filter + _filter):
			if item == 'homePostalAddress':
				contact.home_street = ''
				contact.home_postal_code = ''
				contact.home_locality = ''
			elif item == 'uniqueMember':
				contact.body = ''
			else:
                        	try:
                                	setattr(contact, _mapping[item], '')
                        	except:
                                	pass

		# add new message
		self.imap4.append( self.folder, None, None, str( contact ) )


class Synchronisation( object ):
	def __init__( self ):
		self.display_user = cfgRegistry.get( 'ldap/addressbook/sync/display/user',
											 '%(sn)s, %(givenName)s' )
		self.display_group = cfgRegistry.get( 'ldap/addressbook/sync/display/group',
											  '%(cn)s (Gruppe)' )
		self.display_list = cfgRegistry.get( 'ldap/addressbook/sync/display/list',
											 '%(cn)s (Liste)' )
		if cfgRegistry.get( 'ldap/addressbook/sync/folder', None ) not in [None, '']:
			self.imap_clients = [ IMAP_Client(), ]
		else:
			# no default folder given
			self.imap_clients = [ ]
		self._check_additional_folders()

	def _check_additional_folders( self ):
		ud.debug( ud.ADMIN, ud.INFO, 'Synchronisation: search for additional folders' )
		for key in cfgRegistry.keys():
			if key.startswith( 'ldap/addressbook/sync/additional/folder/' ):
				folder = cfgRegistry[ key ]
				name = key[ key.rfind( '/' ) + 1 : ]
				ud.debug( ud.ADMIN, ud.INFO, 'Synchronisation: found additional folder %s' % name )
				groups = cfgRegistry.get( 'ldap/addressbook/sync/additional/groups/' + name, [] )
				if groups:
					groups = groups.split( ';' )
				ud.debug( ud.ADMIN, ud.INFO, 'IMAP_Client: folder: %s / groups:  %s' % ( folder, groups ) )
                                filter = cfgRegistry.get('ldap/addressbook/sync/additional/attributefilter/' + name, '').split(" ")
				dnpattern = re.compile(cfgRegistry.get('ldap/addressbook/sync/additional/dnregexp/' + name, ''))
                                self.imap_clients.append( IMAP_Client( folder, groups, filter = filter, dnpattern = dnpattern ) )

	def remove_all( self ):
		for client in self.imap_clients:
			client.remove_all()

	def process( self, dn , old, new ):
		if old and new:
			self.modify( dn, old, new )
		elif not old and new:
			self.add( dn, old, new )
		elif old and not new:
			self.remove( dn )

	def modify( self, dn, old, new ):
		self.remove( dn )
		self.add( dn, old, new )

	def __map_displayname( self, obj, display ):
		for key in obj.keys():
			if not obj[ key ]:
				obj[ key ] = ''
			else:
				obj[ key ] = obj[ key ][ 0 ]

		while True:
			try:
				text = display % obj
			except KeyError, e:
				obj[ str( e )[ 1 : -1 ] ] = ''
			else:
				break

		return text

	def add( self, dn, old, new ):
		contact = KolabContact( dn )
		obj_classes = new.get( 'objectClass', [] )
		# IMPORTANT: if another attribute is added, than the listener
		# module MUST be changed as the pickle file is just created if a
		# relevant attribute has been modified.

		# user contact
		if 'inetOrgPerson' in obj_classes:
			homeAddress = new.get( 'homePostalAddress', False)
			addresses = copy.deepcopy( new.get( 'mail', [] ) )
			displayName = self.__map_displayname( new, self.display_user )
			contact.name_given_name = new.get( 'givenName', '' )
			contact.name_last_name = new.get( 'sn', '' )
			contact.name_full_name = displayName
			contact.name_prefix = new.get( 'title', '' )
			ud.debug( ud.ADMIN, ud.INFO, 'IMAP: add mail addresses: %s' % addresses )
			contact.add_email_addresses( displayName, addresses )
			contact.business1_number = new.get( 'telephoneNumber', '' )
			contact.home1_number = new.get( 'homePhone', '' )
			contact.mobile_number = new.get( 'mobile', '' )
			contact.organization = new.get( 'o', '' )
			contact.business_postal_code = new.get( 'postalCode', '' )
			contact.business_street = new.get( 'street', '' )
			contact.business_locality = new.get( 'l', '' )
			contact.department = new.get( 'departmentNumber', '' )
			if 'univentionPerson' in obj_classes:
				# bd -> yyyy-mm-dd
				bd = new.get( 'univentionBirthday', '' )
				if re.match("^\d\d\d\d-\d\d-\d\d$", bd):
					contact.birthday = bd
			if homeAddress:
				if len(homeAddress) > 0:
					addr = homeAddress[0].split('$')
					if len(addr) > 2:
						contact.home_street = addr[0]
						contact.home_postal_code = addr[1]
						contact.home_locality = addr[2]
		elif 'univentionGroup' in obj_classes:
			displayName = self.__map_displayname( new, self.display_group )
			contact.name_given_name = new.get( 'cn', '' )
			contact.name_full_name = displayName
			contact.add_email_addresses( displayName, [ new.get( 'mailPrimaryAddress', '' ) ] )
		elif 'univentionKolabGroup' in obj_classes:
			displayName = self.__map_displayname( new, self.display_list )
			contact.name_given_name = new.get( 'cn', '' )
			contact.name_full_name = displayName
			contact.add_email_addresses( displayName, [ new.get( 'mailPrimaryAddress', '' ) ] )

		if _options.simulate:
			ud.debug( ud.ADMIN, ud.INFO, 'IMAP: add message: %s' % str( contact ) )
			return

		for client in self.imap_clients:
			client.add( copy.deepcopy( contact ), new.get( 'uid', None ) )

	def remove( self, dn ):
		ud.debug( ud.ADMIN, ud.INFO, 'IMAP: remove message: %s' % dn )
		for client in self.imap_clients:
			client.remove( dn )

def read_changes( dirname ):
	sync = Synchronisation()

	for fn in sorted( os.listdir( dirname ) ):
		target_fn = os.path.join( dirname, fn )
		ud.debug( ud.ADMIN, ud.INFO, 'Processing %s' % fn )
		try:
			fd = open( target_fn, 'r+' )
			obj = cPickle.load( fd )
			fd.close()
			dn, new, old = obj
		except:
			raise RuntimeError( 'Loading %s failed!' % target_fn )

		# process file
		try:
			sync.process( dn, old, new )
			ud.debug(ud.ADMIN, ud.INFO, 'Processed %s successfully' % fn)
			if not _options.simulate:
				os.remove(target_fn)
		except Exception, e:
			ud.debug(ud.ADMIN, ud.ERROR, 'Processing %s failed (exitcode %s)' % ( fn, str( e ) ) )

def main():
	global _options
	global _filter 
        global _mapping

	debug_level = int( cfgRegistry.get( 'ldap/addressbook/sync/debug/level','0' ) )

	parser = OptionParser()
	parser.add_option( '-d', '--debug', action = 'store', type = 'int',
					   dest = 'debug', default = debug_level,
					   help = 'if given than debugging is activated and set to the specified level' )
	parser.add_option( '-s', '--simulate', action = 'store_true',
					   dest = 'simulate', default = False,
					   help = 'if given the synchronisation is just simulated, no modifications are done' )
	parser.add_option( '', '--remove-all-contacts', action = 'store_true',
					   dest = 'remove_all_contacts', default = False,
					   help = 'if given all contacts in the global folder will be deleted' )

	( _options, args ) = parser.parse_args()

        _filter = cfgRegistry.get('ldap/addressbook/sync/attributefilter', '').split(" ")

        _mapping = {'givenName':'name_given_name',
                    'sn':'name_last_name',
                    'displayName':'name_full_name',
                    'telephoneNumber':'business1_number',
                    'homePhone':'home1_number',
                    'mobile':'mobile_number',
                    'o':'organization',
                    'postalCode':'business_postal_code',
                    'street':'business_street',
                    'l':'business_locality',
                    'departmentNumber':'department',
                    'title':'job_title',
		    'univentionBirthday':'birthday'}

	# open logging
	ud.init( '/var/log/univention/ldap-addressbook-sync.log', 1, 1 )
	ud.set_level( ud.ADMIN, _options.debug )
	ud.debug(ud.ADMIN, ud.ERROR, 'started LDAP addressbook sync script: %s' % str( sys.argv ) )

	# Prevent univention-ldap-addressbook-sync from being started twice
	fn = '/var/run/univention-ldap-addressbook-sync.pid'
	fd = open( fn, 'w' )
	try:
		fcntl.lockf( fd, fcntl.LOCK_EX | fcntl.LOCK_NB )
	except IOError, e:
		message = 'Failed to get lock for %s - another instance seems to be running: %s' % ( fn, str( e ) )
		ud.debug( ud.ADMIN, ud.ERROR, message )
		print >> sys.stderr, message
		sys.exit( 1 )
	fd.write( str( os.getpid() ) + '\n' )

	# clean up mode?
	if _options.remove_all_contacts:
		ud.debug(ud.ADMIN, ud.ERROR, 'remove all existing contacts')

		try:
			sync = Synchronisation()
			sync.remove_all()
		except RuntimeError, e:
			ud.debug( ud.ADMIN, ud.ERROR, str( e ) )
			print >> sys.stderr, str( e )
	else:
		# process datadir
		datadir = cfgRegistry.get( 'ldap/addressbook/sync/listener/dir',
								   '/var/lib/univention-ldap-addressbook-sync')
		ud.debug( ud.ADMIN, ud.WARN, 'datadir=%s' % datadir )
		try:
			read_changes( datadir )
		except RuntimeError, e:
			ud.debug( ud.ADMIN, ud.ERROR, str( e ) )
			print >> sys.stderr, str( e )

	# free lock and exit
	fcntl.lockf( fd, fcntl.LOCK_UN )
	fd.close()

if __name__ == "__main__":
	ldapConnection = LDAP_Connection()
	main()
